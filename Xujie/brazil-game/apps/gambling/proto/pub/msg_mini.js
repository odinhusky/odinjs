/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const mini = $root.mini = (() => {

    /**
     * Namespace mini.
     * @exports mini
     * @namespace
     */
    const mini = {};

    /**
     * SHOT_TYPE enum.
     * @name mini.SHOT_TYPE
     * @enum {number}
     * @property {number} ST_NONE=0 ST_NONE value
     * @property {number} ST_FREE=1 ST_FREE value
     * @property {number} ST_NORMAL=2 ST_NORMAL value
     * @property {number} ST_GOLDEN=3 ST_GOLDEN value
     */
    mini.SHOT_TYPE = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ST_NONE"] = 0;
        values[valuesById[1] = "ST_FREE"] = 1;
        values[valuesById[2] = "ST_NORMAL"] = 2;
        values[valuesById[3] = "ST_GOLDEN"] = 3;
        return values;
    })();

    /**
     * SHOT_AREA enum.
     * @name mini.SHOT_AREA
     * @enum {number}
     * @property {number} SA_NONE=0 SA_NONE value
     * @property {number} SA_CENTER=1 SA_CENTER value
     * @property {number} SA_INNER=2 SA_INNER value
     * @property {number} SA_OUTER=3 SA_OUTER value
     */
    mini.SHOT_AREA = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SA_NONE"] = 0;
        values[valuesById[1] = "SA_CENTER"] = 1;
        values[valuesById[2] = "SA_INNER"] = 2;
        values[valuesById[3] = "SA_OUTER"] = 3;
        return values;
    })();

    mini.ShotReward = (function() {

        /**
         * Properties of a ShotReward.
         * @memberof mini
         * @interface IShotReward
         * @property {mini.SHOT_AREA|null} [area] ShotReward area
         * @property {number|null} [cash] ShotReward cash
         * @property {number|null} [bonus] ShotReward bonus
         */

        /**
         * Constructs a new ShotReward.
         * @memberof mini
         * @classdesc Represents a ShotReward.
         * @implements IShotReward
         * @constructor
         * @param {mini.IShotReward=} [properties] Properties to set
         */
        function ShotReward(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShotReward area.
         * @member {mini.SHOT_AREA} area
         * @memberof mini.ShotReward
         * @instance
         */
        ShotReward.prototype.area = 0;

        /**
         * ShotReward cash.
         * @member {number} cash
         * @memberof mini.ShotReward
         * @instance
         */
        ShotReward.prototype.cash = 0;

        /**
         * ShotReward bonus.
         * @member {number} bonus
         * @memberof mini.ShotReward
         * @instance
         */
        ShotReward.prototype.bonus = 0;

        /**
         * Creates a new ShotReward instance using the specified properties.
         * @function create
         * @memberof mini.ShotReward
         * @static
         * @param {mini.IShotReward=} [properties] Properties to set
         * @returns {mini.ShotReward} ShotReward instance
         */
        ShotReward.create = function create(properties) {
            return new ShotReward(properties);
        };

        /**
         * Encodes the specified ShotReward message. Does not implicitly {@link mini.ShotReward.verify|verify} messages.
         * @function encode
         * @memberof mini.ShotReward
         * @static
         * @param {mini.IShotReward} message ShotReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShotReward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.area);
            if (message.cash != null && Object.hasOwnProperty.call(message, "cash"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.cash);
            if (message.bonus != null && Object.hasOwnProperty.call(message, "bonus"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.bonus);
            return writer;
        };

        /**
         * Encodes the specified ShotReward message, length delimited. Does not implicitly {@link mini.ShotReward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ShotReward
         * @static
         * @param {mini.IShotReward} message ShotReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShotReward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShotReward message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ShotReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ShotReward} ShotReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShotReward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ShotReward();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.area = reader.int32();
                    break;
                case 2:
                    message.cash = reader.int32();
                    break;
                case 3:
                    message.bonus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShotReward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ShotReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ShotReward} ShotReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShotReward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShotReward message.
         * @function verify
         * @memberof mini.ShotReward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShotReward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.area != null && message.hasOwnProperty("area"))
                switch (message.area) {
                default:
                    return "area: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.cash != null && message.hasOwnProperty("cash"))
                if (!$util.isInteger(message.cash))
                    return "cash: integer expected";
            if (message.bonus != null && message.hasOwnProperty("bonus"))
                if (!$util.isInteger(message.bonus))
                    return "bonus: integer expected";
            return null;
        };

        /**
         * Creates a ShotReward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ShotReward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ShotReward} ShotReward
         */
        ShotReward.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ShotReward)
                return object;
            let message = new $root.mini.ShotReward();
            switch (object.area) {
            case "SA_NONE":
            case 0:
                message.area = 0;
                break;
            case "SA_CENTER":
            case 1:
                message.area = 1;
                break;
            case "SA_INNER":
            case 2:
                message.area = 2;
                break;
            case "SA_OUTER":
            case 3:
                message.area = 3;
                break;
            }
            if (object.cash != null)
                message.cash = object.cash | 0;
            if (object.bonus != null)
                message.bonus = object.bonus | 0;
            return message;
        };

        /**
         * Creates a plain object from a ShotReward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ShotReward
         * @static
         * @param {mini.ShotReward} message ShotReward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShotReward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.area = options.enums === String ? "SA_NONE" : 0;
                object.cash = 0;
                object.bonus = 0;
            }
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = options.enums === String ? $root.mini.SHOT_AREA[message.area] : message.area;
            if (message.cash != null && message.hasOwnProperty("cash"))
                object.cash = message.cash;
            if (message.bonus != null && message.hasOwnProperty("bonus"))
                object.bonus = message.bonus;
            return object;
        };

        /**
         * Converts this ShotReward to JSON.
         * @function toJSON
         * @memberof mini.ShotReward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShotReward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShotReward;
    })();

    mini.ShotStateEvent = (function() {

        /**
         * Properties of a ShotStateEvent.
         * @memberof mini
         * @interface IShotStateEvent
         * @property {number|null} [freeRefresh] ShotStateEvent freeRefresh
         * @property {mini.SHOT_TYPE|null} [shotType] ShotStateEvent shotType
         * @property {number|null} [shotRemain] ShotStateEvent shotRemain
         * @property {number|null} [placeType] ShotStateEvent placeType
         * @property {string|null} [shotParams] ShotStateEvent shotParams
         * @property {Array.<mini.IShotReward>|null} [reward] ShotStateEvent reward
         * @property {mini.SHOT_TYPE|null} [buyType] ShotStateEvent buyType
         * @property {number|null} [buyPrice] ShotStateEvent buyPrice
         * @property {number|null} [buyShotTimes] ShotStateEvent buyShotTimes
         * @property {number|null} [goalsPosX] ShotStateEvent goalsPosX
         * @property {number|null} [goalsPosY] ShotStateEvent goalsPosY
         * @property {Array.<mini.IShotBall>|null} [balls] ShotStateEvent balls
         */

        /**
         * Constructs a new ShotStateEvent.
         * @memberof mini
         * @classdesc Represents a ShotStateEvent.
         * @implements IShotStateEvent
         * @constructor
         * @param {mini.IShotStateEvent=} [properties] Properties to set
         */
        function ShotStateEvent(properties) {
            this.reward = [];
            this.balls = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShotStateEvent freeRefresh.
         * @member {number} freeRefresh
         * @memberof mini.ShotStateEvent
         * @instance
         */
        ShotStateEvent.prototype.freeRefresh = 0;

        /**
         * ShotStateEvent shotType.
         * @member {mini.SHOT_TYPE} shotType
         * @memberof mini.ShotStateEvent
         * @instance
         */
        ShotStateEvent.prototype.shotType = 0;

        /**
         * ShotStateEvent shotRemain.
         * @member {number} shotRemain
         * @memberof mini.ShotStateEvent
         * @instance
         */
        ShotStateEvent.prototype.shotRemain = 0;

        /**
         * ShotStateEvent placeType.
         * @member {number} placeType
         * @memberof mini.ShotStateEvent
         * @instance
         */
        ShotStateEvent.prototype.placeType = 0;

        /**
         * ShotStateEvent shotParams.
         * @member {string} shotParams
         * @memberof mini.ShotStateEvent
         * @instance
         */
        ShotStateEvent.prototype.shotParams = "";

        /**
         * ShotStateEvent reward.
         * @member {Array.<mini.IShotReward>} reward
         * @memberof mini.ShotStateEvent
         * @instance
         */
        ShotStateEvent.prototype.reward = $util.emptyArray;

        /**
         * ShotStateEvent buyType.
         * @member {mini.SHOT_TYPE} buyType
         * @memberof mini.ShotStateEvent
         * @instance
         */
        ShotStateEvent.prototype.buyType = 0;

        /**
         * ShotStateEvent buyPrice.
         * @member {number} buyPrice
         * @memberof mini.ShotStateEvent
         * @instance
         */
        ShotStateEvent.prototype.buyPrice = 0;

        /**
         * ShotStateEvent buyShotTimes.
         * @member {number} buyShotTimes
         * @memberof mini.ShotStateEvent
         * @instance
         */
        ShotStateEvent.prototype.buyShotTimes = 0;

        /**
         * ShotStateEvent goalsPosX.
         * @member {number} goalsPosX
         * @memberof mini.ShotStateEvent
         * @instance
         */
        ShotStateEvent.prototype.goalsPosX = 0;

        /**
         * ShotStateEvent goalsPosY.
         * @member {number} goalsPosY
         * @memberof mini.ShotStateEvent
         * @instance
         */
        ShotStateEvent.prototype.goalsPosY = 0;

        /**
         * ShotStateEvent balls.
         * @member {Array.<mini.IShotBall>} balls
         * @memberof mini.ShotStateEvent
         * @instance
         */
        ShotStateEvent.prototype.balls = $util.emptyArray;

        /**
         * Creates a new ShotStateEvent instance using the specified properties.
         * @function create
         * @memberof mini.ShotStateEvent
         * @static
         * @param {mini.IShotStateEvent=} [properties] Properties to set
         * @returns {mini.ShotStateEvent} ShotStateEvent instance
         */
        ShotStateEvent.create = function create(properties) {
            return new ShotStateEvent(properties);
        };

        /**
         * Encodes the specified ShotStateEvent message. Does not implicitly {@link mini.ShotStateEvent.verify|verify} messages.
         * @function encode
         * @memberof mini.ShotStateEvent
         * @static
         * @param {mini.IShotStateEvent} message ShotStateEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShotStateEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.freeRefresh != null && Object.hasOwnProperty.call(message, "freeRefresh"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.freeRefresh);
            if (message.shotType != null && Object.hasOwnProperty.call(message, "shotType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.shotType);
            if (message.shotRemain != null && Object.hasOwnProperty.call(message, "shotRemain"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.shotRemain);
            if (message.placeType != null && Object.hasOwnProperty.call(message, "placeType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.placeType);
            if (message.shotParams != null && Object.hasOwnProperty.call(message, "shotParams"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.shotParams);
            if (message.reward != null && message.reward.length)
                for (let i = 0; i < message.reward.length; ++i)
                    $root.mini.ShotReward.encode(message.reward[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.buyType != null && Object.hasOwnProperty.call(message, "buyType"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.buyType);
            if (message.buyPrice != null && Object.hasOwnProperty.call(message, "buyPrice"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.buyPrice);
            if (message.buyShotTimes != null && Object.hasOwnProperty.call(message, "buyShotTimes"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.buyShotTimes);
            if (message.goalsPosX != null && Object.hasOwnProperty.call(message, "goalsPosX"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.goalsPosX);
            if (message.goalsPosY != null && Object.hasOwnProperty.call(message, "goalsPosY"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.goalsPosY);
            if (message.balls != null && message.balls.length)
                for (let i = 0; i < message.balls.length; ++i)
                    $root.mini.ShotBall.encode(message.balls[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ShotStateEvent message, length delimited. Does not implicitly {@link mini.ShotStateEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ShotStateEvent
         * @static
         * @param {mini.IShotStateEvent} message ShotStateEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShotStateEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShotStateEvent message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ShotStateEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ShotStateEvent} ShotStateEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShotStateEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ShotStateEvent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.freeRefresh = reader.int32();
                    break;
                case 2:
                    message.shotType = reader.int32();
                    break;
                case 3:
                    message.shotRemain = reader.int32();
                    break;
                case 4:
                    message.placeType = reader.int32();
                    break;
                case 5:
                    message.shotParams = reader.string();
                    break;
                case 6:
                    if (!(message.reward && message.reward.length))
                        message.reward = [];
                    message.reward.push($root.mini.ShotReward.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.buyType = reader.int32();
                    break;
                case 8:
                    message.buyPrice = reader.int32();
                    break;
                case 9:
                    message.buyShotTimes = reader.int32();
                    break;
                case 10:
                    message.goalsPosX = reader.int32();
                    break;
                case 11:
                    message.goalsPosY = reader.int32();
                    break;
                case 12:
                    if (!(message.balls && message.balls.length))
                        message.balls = [];
                    message.balls.push($root.mini.ShotBall.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShotStateEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ShotStateEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ShotStateEvent} ShotStateEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShotStateEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShotStateEvent message.
         * @function verify
         * @memberof mini.ShotStateEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShotStateEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.freeRefresh != null && message.hasOwnProperty("freeRefresh"))
                if (!$util.isInteger(message.freeRefresh))
                    return "freeRefresh: integer expected";
            if (message.shotType != null && message.hasOwnProperty("shotType"))
                switch (message.shotType) {
                default:
                    return "shotType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.shotRemain != null && message.hasOwnProperty("shotRemain"))
                if (!$util.isInteger(message.shotRemain))
                    return "shotRemain: integer expected";
            if (message.placeType != null && message.hasOwnProperty("placeType"))
                if (!$util.isInteger(message.placeType))
                    return "placeType: integer expected";
            if (message.shotParams != null && message.hasOwnProperty("shotParams"))
                if (!$util.isString(message.shotParams))
                    return "shotParams: string expected";
            if (message.reward != null && message.hasOwnProperty("reward")) {
                if (!Array.isArray(message.reward))
                    return "reward: array expected";
                for (let i = 0; i < message.reward.length; ++i) {
                    let error = $root.mini.ShotReward.verify(message.reward[i]);
                    if (error)
                        return "reward." + error;
                }
            }
            if (message.buyType != null && message.hasOwnProperty("buyType"))
                switch (message.buyType) {
                default:
                    return "buyType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.buyPrice != null && message.hasOwnProperty("buyPrice"))
                if (!$util.isInteger(message.buyPrice))
                    return "buyPrice: integer expected";
            if (message.buyShotTimes != null && message.hasOwnProperty("buyShotTimes"))
                if (!$util.isInteger(message.buyShotTimes))
                    return "buyShotTimes: integer expected";
            if (message.goalsPosX != null && message.hasOwnProperty("goalsPosX"))
                if (!$util.isInteger(message.goalsPosX))
                    return "goalsPosX: integer expected";
            if (message.goalsPosY != null && message.hasOwnProperty("goalsPosY"))
                if (!$util.isInteger(message.goalsPosY))
                    return "goalsPosY: integer expected";
            if (message.balls != null && message.hasOwnProperty("balls")) {
                if (!Array.isArray(message.balls))
                    return "balls: array expected";
                for (let i = 0; i < message.balls.length; ++i) {
                    let error = $root.mini.ShotBall.verify(message.balls[i]);
                    if (error)
                        return "balls." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ShotStateEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ShotStateEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ShotStateEvent} ShotStateEvent
         */
        ShotStateEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ShotStateEvent)
                return object;
            let message = new $root.mini.ShotStateEvent();
            if (object.freeRefresh != null)
                message.freeRefresh = object.freeRefresh | 0;
            switch (object.shotType) {
            case "ST_NONE":
            case 0:
                message.shotType = 0;
                break;
            case "ST_FREE":
            case 1:
                message.shotType = 1;
                break;
            case "ST_NORMAL":
            case 2:
                message.shotType = 2;
                break;
            case "ST_GOLDEN":
            case 3:
                message.shotType = 3;
                break;
            }
            if (object.shotRemain != null)
                message.shotRemain = object.shotRemain | 0;
            if (object.placeType != null)
                message.placeType = object.placeType | 0;
            if (object.shotParams != null)
                message.shotParams = String(object.shotParams);
            if (object.reward) {
                if (!Array.isArray(object.reward))
                    throw TypeError(".mini.ShotStateEvent.reward: array expected");
                message.reward = [];
                for (let i = 0; i < object.reward.length; ++i) {
                    if (typeof object.reward[i] !== "object")
                        throw TypeError(".mini.ShotStateEvent.reward: object expected");
                    message.reward[i] = $root.mini.ShotReward.fromObject(object.reward[i]);
                }
            }
            switch (object.buyType) {
            case "ST_NONE":
            case 0:
                message.buyType = 0;
                break;
            case "ST_FREE":
            case 1:
                message.buyType = 1;
                break;
            case "ST_NORMAL":
            case 2:
                message.buyType = 2;
                break;
            case "ST_GOLDEN":
            case 3:
                message.buyType = 3;
                break;
            }
            if (object.buyPrice != null)
                message.buyPrice = object.buyPrice | 0;
            if (object.buyShotTimes != null)
                message.buyShotTimes = object.buyShotTimes | 0;
            if (object.goalsPosX != null)
                message.goalsPosX = object.goalsPosX | 0;
            if (object.goalsPosY != null)
                message.goalsPosY = object.goalsPosY | 0;
            if (object.balls) {
                if (!Array.isArray(object.balls))
                    throw TypeError(".mini.ShotStateEvent.balls: array expected");
                message.balls = [];
                for (let i = 0; i < object.balls.length; ++i) {
                    if (typeof object.balls[i] !== "object")
                        throw TypeError(".mini.ShotStateEvent.balls: object expected");
                    message.balls[i] = $root.mini.ShotBall.fromObject(object.balls[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ShotStateEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ShotStateEvent
         * @static
         * @param {mini.ShotStateEvent} message ShotStateEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShotStateEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.reward = [];
                object.balls = [];
            }
            if (options.defaults) {
                object.freeRefresh = 0;
                object.shotType = options.enums === String ? "ST_NONE" : 0;
                object.shotRemain = 0;
                object.placeType = 0;
                object.shotParams = "";
                object.buyType = options.enums === String ? "ST_NONE" : 0;
                object.buyPrice = 0;
                object.buyShotTimes = 0;
                object.goalsPosX = 0;
                object.goalsPosY = 0;
            }
            if (message.freeRefresh != null && message.hasOwnProperty("freeRefresh"))
                object.freeRefresh = message.freeRefresh;
            if (message.shotType != null && message.hasOwnProperty("shotType"))
                object.shotType = options.enums === String ? $root.mini.SHOT_TYPE[message.shotType] : message.shotType;
            if (message.shotRemain != null && message.hasOwnProperty("shotRemain"))
                object.shotRemain = message.shotRemain;
            if (message.placeType != null && message.hasOwnProperty("placeType"))
                object.placeType = message.placeType;
            if (message.shotParams != null && message.hasOwnProperty("shotParams"))
                object.shotParams = message.shotParams;
            if (message.reward && message.reward.length) {
                object.reward = [];
                for (let j = 0; j < message.reward.length; ++j)
                    object.reward[j] = $root.mini.ShotReward.toObject(message.reward[j], options);
            }
            if (message.buyType != null && message.hasOwnProperty("buyType"))
                object.buyType = options.enums === String ? $root.mini.SHOT_TYPE[message.buyType] : message.buyType;
            if (message.buyPrice != null && message.hasOwnProperty("buyPrice"))
                object.buyPrice = message.buyPrice;
            if (message.buyShotTimes != null && message.hasOwnProperty("buyShotTimes"))
                object.buyShotTimes = message.buyShotTimes;
            if (message.goalsPosX != null && message.hasOwnProperty("goalsPosX"))
                object.goalsPosX = message.goalsPosX;
            if (message.goalsPosY != null && message.hasOwnProperty("goalsPosY"))
                object.goalsPosY = message.goalsPosY;
            if (message.balls && message.balls.length) {
                object.balls = [];
                for (let j = 0; j < message.balls.length; ++j)
                    object.balls[j] = $root.mini.ShotBall.toObject(message.balls[j], options);
            }
            return object;
        };

        /**
         * Converts this ShotStateEvent to JSON.
         * @function toJSON
         * @memberof mini.ShotStateEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShotStateEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShotStateEvent;
    })();

    mini.ShotBall = (function() {

        /**
         * Properties of a ShotBall.
         * @memberof mini
         * @interface IShotBall
         * @property {number|null} [tag] ShotBall tag
         * @property {number|null} [posX] ShotBall posX
         * @property {number|null} [posY] ShotBall posY
         */

        /**
         * Constructs a new ShotBall.
         * @memberof mini
         * @classdesc Represents a ShotBall.
         * @implements IShotBall
         * @constructor
         * @param {mini.IShotBall=} [properties] Properties to set
         */
        function ShotBall(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShotBall tag.
         * @member {number} tag
         * @memberof mini.ShotBall
         * @instance
         */
        ShotBall.prototype.tag = 0;

        /**
         * ShotBall posX.
         * @member {number} posX
         * @memberof mini.ShotBall
         * @instance
         */
        ShotBall.prototype.posX = 0;

        /**
         * ShotBall posY.
         * @member {number} posY
         * @memberof mini.ShotBall
         * @instance
         */
        ShotBall.prototype.posY = 0;

        /**
         * Creates a new ShotBall instance using the specified properties.
         * @function create
         * @memberof mini.ShotBall
         * @static
         * @param {mini.IShotBall=} [properties] Properties to set
         * @returns {mini.ShotBall} ShotBall instance
         */
        ShotBall.create = function create(properties) {
            return new ShotBall(properties);
        };

        /**
         * Encodes the specified ShotBall message. Does not implicitly {@link mini.ShotBall.verify|verify} messages.
         * @function encode
         * @memberof mini.ShotBall
         * @static
         * @param {mini.IShotBall} message ShotBall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShotBall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tag != null && Object.hasOwnProperty.call(message, "tag"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tag);
            if (message.posX != null && Object.hasOwnProperty.call(message, "posX"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.posX);
            if (message.posY != null && Object.hasOwnProperty.call(message, "posY"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.posY);
            return writer;
        };

        /**
         * Encodes the specified ShotBall message, length delimited. Does not implicitly {@link mini.ShotBall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ShotBall
         * @static
         * @param {mini.IShotBall} message ShotBall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShotBall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShotBall message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ShotBall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ShotBall} ShotBall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShotBall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ShotBall();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tag = reader.int32();
                    break;
                case 2:
                    message.posX = reader.int32();
                    break;
                case 3:
                    message.posY = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShotBall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ShotBall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ShotBall} ShotBall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShotBall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShotBall message.
         * @function verify
         * @memberof mini.ShotBall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShotBall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tag != null && message.hasOwnProperty("tag"))
                if (!$util.isInteger(message.tag))
                    return "tag: integer expected";
            if (message.posX != null && message.hasOwnProperty("posX"))
                if (!$util.isInteger(message.posX))
                    return "posX: integer expected";
            if (message.posY != null && message.hasOwnProperty("posY"))
                if (!$util.isInteger(message.posY))
                    return "posY: integer expected";
            return null;
        };

        /**
         * Creates a ShotBall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ShotBall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ShotBall} ShotBall
         */
        ShotBall.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ShotBall)
                return object;
            let message = new $root.mini.ShotBall();
            if (object.tag != null)
                message.tag = object.tag | 0;
            if (object.posX != null)
                message.posX = object.posX | 0;
            if (object.posY != null)
                message.posY = object.posY | 0;
            return message;
        };

        /**
         * Creates a plain object from a ShotBall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ShotBall
         * @static
         * @param {mini.ShotBall} message ShotBall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShotBall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.tag = 0;
                object.posX = 0;
                object.posY = 0;
            }
            if (message.tag != null && message.hasOwnProperty("tag"))
                object.tag = message.tag;
            if (message.posX != null && message.hasOwnProperty("posX"))
                object.posX = message.posX;
            if (message.posY != null && message.hasOwnProperty("posY"))
                object.posY = message.posY;
            return object;
        };

        /**
         * Converts this ShotBall to JSON.
         * @function toJSON
         * @memberof mini.ShotBall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShotBall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShotBall;
    })();

    mini.ShotBuyReq = (function() {

        /**
         * Properties of a ShotBuyReq.
         * @memberof mini
         * @interface IShotBuyReq
         * @property {mini.SHOT_TYPE|null} [type] ShotBuyReq type
         */

        /**
         * Constructs a new ShotBuyReq.
         * @memberof mini
         * @classdesc Represents a ShotBuyReq.
         * @implements IShotBuyReq
         * @constructor
         * @param {mini.IShotBuyReq=} [properties] Properties to set
         */
        function ShotBuyReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShotBuyReq type.
         * @member {mini.SHOT_TYPE} type
         * @memberof mini.ShotBuyReq
         * @instance
         */
        ShotBuyReq.prototype.type = 0;

        /**
         * Creates a new ShotBuyReq instance using the specified properties.
         * @function create
         * @memberof mini.ShotBuyReq
         * @static
         * @param {mini.IShotBuyReq=} [properties] Properties to set
         * @returns {mini.ShotBuyReq} ShotBuyReq instance
         */
        ShotBuyReq.create = function create(properties) {
            return new ShotBuyReq(properties);
        };

        /**
         * Encodes the specified ShotBuyReq message. Does not implicitly {@link mini.ShotBuyReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ShotBuyReq
         * @static
         * @param {mini.IShotBuyReq} message ShotBuyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShotBuyReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ShotBuyReq message, length delimited. Does not implicitly {@link mini.ShotBuyReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ShotBuyReq
         * @static
         * @param {mini.IShotBuyReq} message ShotBuyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShotBuyReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShotBuyReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ShotBuyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ShotBuyReq} ShotBuyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShotBuyReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ShotBuyReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShotBuyReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ShotBuyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ShotBuyReq} ShotBuyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShotBuyReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShotBuyReq message.
         * @function verify
         * @memberof mini.ShotBuyReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShotBuyReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a ShotBuyReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ShotBuyReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ShotBuyReq} ShotBuyReq
         */
        ShotBuyReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ShotBuyReq)
                return object;
            let message = new $root.mini.ShotBuyReq();
            switch (object.type) {
            case "ST_NONE":
            case 0:
                message.type = 0;
                break;
            case "ST_FREE":
            case 1:
                message.type = 1;
                break;
            case "ST_NORMAL":
            case 2:
                message.type = 2;
                break;
            case "ST_GOLDEN":
            case 3:
                message.type = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ShotBuyReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ShotBuyReq
         * @static
         * @param {mini.ShotBuyReq} message ShotBuyReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShotBuyReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.type = options.enums === String ? "ST_NONE" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.mini.SHOT_TYPE[message.type] : message.type;
            return object;
        };

        /**
         * Converts this ShotBuyReq to JSON.
         * @function toJSON
         * @memberof mini.ShotBuyReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShotBuyReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShotBuyReq;
    })();

    mini.ShotPreHitReq = (function() {

        /**
         * Properties of a ShotPreHitReq.
         * @memberof mini
         * @interface IShotPreHitReq
         * @property {mini.SHOT_TYPE|null} [shotType] ShotPreHitReq shotType
         */

        /**
         * Constructs a new ShotPreHitReq.
         * @memberof mini
         * @classdesc Represents a ShotPreHitReq.
         * @implements IShotPreHitReq
         * @constructor
         * @param {mini.IShotPreHitReq=} [properties] Properties to set
         */
        function ShotPreHitReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShotPreHitReq shotType.
         * @member {mini.SHOT_TYPE} shotType
         * @memberof mini.ShotPreHitReq
         * @instance
         */
        ShotPreHitReq.prototype.shotType = 0;

        /**
         * Creates a new ShotPreHitReq instance using the specified properties.
         * @function create
         * @memberof mini.ShotPreHitReq
         * @static
         * @param {mini.IShotPreHitReq=} [properties] Properties to set
         * @returns {mini.ShotPreHitReq} ShotPreHitReq instance
         */
        ShotPreHitReq.create = function create(properties) {
            return new ShotPreHitReq(properties);
        };

        /**
         * Encodes the specified ShotPreHitReq message. Does not implicitly {@link mini.ShotPreHitReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ShotPreHitReq
         * @static
         * @param {mini.IShotPreHitReq} message ShotPreHitReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShotPreHitReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shotType != null && Object.hasOwnProperty.call(message, "shotType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.shotType);
            return writer;
        };

        /**
         * Encodes the specified ShotPreHitReq message, length delimited. Does not implicitly {@link mini.ShotPreHitReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ShotPreHitReq
         * @static
         * @param {mini.IShotPreHitReq} message ShotPreHitReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShotPreHitReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShotPreHitReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ShotPreHitReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ShotPreHitReq} ShotPreHitReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShotPreHitReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ShotPreHitReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shotType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShotPreHitReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ShotPreHitReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ShotPreHitReq} ShotPreHitReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShotPreHitReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShotPreHitReq message.
         * @function verify
         * @memberof mini.ShotPreHitReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShotPreHitReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shotType != null && message.hasOwnProperty("shotType"))
                switch (message.shotType) {
                default:
                    return "shotType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a ShotPreHitReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ShotPreHitReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ShotPreHitReq} ShotPreHitReq
         */
        ShotPreHitReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ShotPreHitReq)
                return object;
            let message = new $root.mini.ShotPreHitReq();
            switch (object.shotType) {
            case "ST_NONE":
            case 0:
                message.shotType = 0;
                break;
            case "ST_FREE":
            case 1:
                message.shotType = 1;
                break;
            case "ST_NORMAL":
            case 2:
                message.shotType = 2;
                break;
            case "ST_GOLDEN":
            case 3:
                message.shotType = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ShotPreHitReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ShotPreHitReq
         * @static
         * @param {mini.ShotPreHitReq} message ShotPreHitReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShotPreHitReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.shotType = options.enums === String ? "ST_NONE" : 0;
            if (message.shotType != null && message.hasOwnProperty("shotType"))
                object.shotType = options.enums === String ? $root.mini.SHOT_TYPE[message.shotType] : message.shotType;
            return object;
        };

        /**
         * Converts this ShotPreHitReq to JSON.
         * @function toJSON
         * @memberof mini.ShotPreHitReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShotPreHitReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShotPreHitReq;
    })();

    mini.ShotResultReq = (function() {

        /**
         * Properties of a ShotResultReq.
         * @memberof mini
         * @interface IShotResultReq
         * @property {mini.SHOT_TYPE|null} [shotType] ShotResultReq shotType
         * @property {number|null} [placeType] ShotResultReq placeType
         * @property {mini.SHOT_AREA|null} [area] ShotResultReq area
         */

        /**
         * Constructs a new ShotResultReq.
         * @memberof mini
         * @classdesc Represents a ShotResultReq.
         * @implements IShotResultReq
         * @constructor
         * @param {mini.IShotResultReq=} [properties] Properties to set
         */
        function ShotResultReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShotResultReq shotType.
         * @member {mini.SHOT_TYPE} shotType
         * @memberof mini.ShotResultReq
         * @instance
         */
        ShotResultReq.prototype.shotType = 0;

        /**
         * ShotResultReq placeType.
         * @member {number} placeType
         * @memberof mini.ShotResultReq
         * @instance
         */
        ShotResultReq.prototype.placeType = 0;

        /**
         * ShotResultReq area.
         * @member {mini.SHOT_AREA} area
         * @memberof mini.ShotResultReq
         * @instance
         */
        ShotResultReq.prototype.area = 0;

        /**
         * Creates a new ShotResultReq instance using the specified properties.
         * @function create
         * @memberof mini.ShotResultReq
         * @static
         * @param {mini.IShotResultReq=} [properties] Properties to set
         * @returns {mini.ShotResultReq} ShotResultReq instance
         */
        ShotResultReq.create = function create(properties) {
            return new ShotResultReq(properties);
        };

        /**
         * Encodes the specified ShotResultReq message. Does not implicitly {@link mini.ShotResultReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ShotResultReq
         * @static
         * @param {mini.IShotResultReq} message ShotResultReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShotResultReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shotType != null && Object.hasOwnProperty.call(message, "shotType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.shotType);
            if (message.placeType != null && Object.hasOwnProperty.call(message, "placeType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.placeType);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.area);
            return writer;
        };

        /**
         * Encodes the specified ShotResultReq message, length delimited. Does not implicitly {@link mini.ShotResultReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ShotResultReq
         * @static
         * @param {mini.IShotResultReq} message ShotResultReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShotResultReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShotResultReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ShotResultReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ShotResultReq} ShotResultReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShotResultReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ShotResultReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shotType = reader.int32();
                    break;
                case 2:
                    message.placeType = reader.int32();
                    break;
                case 3:
                    message.area = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShotResultReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ShotResultReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ShotResultReq} ShotResultReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShotResultReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShotResultReq message.
         * @function verify
         * @memberof mini.ShotResultReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShotResultReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shotType != null && message.hasOwnProperty("shotType"))
                switch (message.shotType) {
                default:
                    return "shotType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.placeType != null && message.hasOwnProperty("placeType"))
                if (!$util.isInteger(message.placeType))
                    return "placeType: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                switch (message.area) {
                default:
                    return "area: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a ShotResultReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ShotResultReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ShotResultReq} ShotResultReq
         */
        ShotResultReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ShotResultReq)
                return object;
            let message = new $root.mini.ShotResultReq();
            switch (object.shotType) {
            case "ST_NONE":
            case 0:
                message.shotType = 0;
                break;
            case "ST_FREE":
            case 1:
                message.shotType = 1;
                break;
            case "ST_NORMAL":
            case 2:
                message.shotType = 2;
                break;
            case "ST_GOLDEN":
            case 3:
                message.shotType = 3;
                break;
            }
            if (object.placeType != null)
                message.placeType = object.placeType | 0;
            switch (object.area) {
            case "SA_NONE":
            case 0:
                message.area = 0;
                break;
            case "SA_CENTER":
            case 1:
                message.area = 1;
                break;
            case "SA_INNER":
            case 2:
                message.area = 2;
                break;
            case "SA_OUTER":
            case 3:
                message.area = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ShotResultReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ShotResultReq
         * @static
         * @param {mini.ShotResultReq} message ShotResultReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShotResultReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.shotType = options.enums === String ? "ST_NONE" : 0;
                object.placeType = 0;
                object.area = options.enums === String ? "SA_NONE" : 0;
            }
            if (message.shotType != null && message.hasOwnProperty("shotType"))
                object.shotType = options.enums === String ? $root.mini.SHOT_TYPE[message.shotType] : message.shotType;
            if (message.placeType != null && message.hasOwnProperty("placeType"))
                object.placeType = message.placeType;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = options.enums === String ? $root.mini.SHOT_AREA[message.area] : message.area;
            return object;
        };

        /**
         * Converts this ShotResultReq to JSON.
         * @function toJSON
         * @memberof mini.ShotResultReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShotResultReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShotResultReq;
    })();

    /**
     * RB_AREA_TYPE enum.
     * @name mini.RB_AREA_TYPE
     * @enum {number}
     * @property {number} RB_NONE=0 RB_NONE value
     * @property {number} RB_SPADE=1 RB_SPADE value
     * @property {number} RB_HEART=2 RB_HEART value
     * @property {number} RB_CLUB=3 RB_CLUB value
     * @property {number} RB_DIAMOND=4 RB_DIAMOND value
     * @property {number} RB_JOKER=5 RB_JOKER value
     * @property {number} RB_RED=6 RB_RED value
     * @property {number} RB_BLACK=7 RB_BLACK value
     */
    mini.RB_AREA_TYPE = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RB_NONE"] = 0;
        values[valuesById[1] = "RB_SPADE"] = 1;
        values[valuesById[2] = "RB_HEART"] = 2;
        values[valuesById[3] = "RB_CLUB"] = 3;
        values[valuesById[4] = "RB_DIAMOND"] = 4;
        values[valuesById[5] = "RB_JOKER"] = 5;
        values[valuesById[6] = "RB_RED"] = 6;
        values[valuesById[7] = "RB_BLACK"] = 7;
        return values;
    })();

    mini.RBStateReq = (function() {

        /**
         * Properties of a RBStateReq.
         * @memberof mini
         * @interface IRBStateReq
         * @property {boolean|null} [completeTask] RBStateReq completeTask
         * @property {number|null} [gameId] RBStateReq gameId
         * @property {number|null} [roomId] RBStateReq roomId
         * @property {number|null} [initBet] RBStateReq initBet
         * @property {number|null} [queryType] RBStateReq queryType
         */

        /**
         * Constructs a new RBStateReq.
         * @memberof mini
         * @classdesc Represents a RBStateReq.
         * @implements IRBStateReq
         * @constructor
         * @param {mini.IRBStateReq=} [properties] Properties to set
         */
        function RBStateReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RBStateReq completeTask.
         * @member {boolean} completeTask
         * @memberof mini.RBStateReq
         * @instance
         */
        RBStateReq.prototype.completeTask = false;

        /**
         * RBStateReq gameId.
         * @member {number} gameId
         * @memberof mini.RBStateReq
         * @instance
         */
        RBStateReq.prototype.gameId = 0;

        /**
         * RBStateReq roomId.
         * @member {number} roomId
         * @memberof mini.RBStateReq
         * @instance
         */
        RBStateReq.prototype.roomId = 0;

        /**
         * RBStateReq initBet.
         * @member {number} initBet
         * @memberof mini.RBStateReq
         * @instance
         */
        RBStateReq.prototype.initBet = 0;

        /**
         * RBStateReq queryType.
         * @member {number} queryType
         * @memberof mini.RBStateReq
         * @instance
         */
        RBStateReq.prototype.queryType = 0;

        /**
         * Creates a new RBStateReq instance using the specified properties.
         * @function create
         * @memberof mini.RBStateReq
         * @static
         * @param {mini.IRBStateReq=} [properties] Properties to set
         * @returns {mini.RBStateReq} RBStateReq instance
         */
        RBStateReq.create = function create(properties) {
            return new RBStateReq(properties);
        };

        /**
         * Encodes the specified RBStateReq message. Does not implicitly {@link mini.RBStateReq.verify|verify} messages.
         * @function encode
         * @memberof mini.RBStateReq
         * @static
         * @param {mini.IRBStateReq} message RBStateReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RBStateReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.completeTask != null && Object.hasOwnProperty.call(message, "completeTask"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.completeTask);
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.gameId);
            if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.roomId);
            if (message.initBet != null && Object.hasOwnProperty.call(message, "initBet"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.initBet);
            if (message.queryType != null && Object.hasOwnProperty.call(message, "queryType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.queryType);
            return writer;
        };

        /**
         * Encodes the specified RBStateReq message, length delimited. Does not implicitly {@link mini.RBStateReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.RBStateReq
         * @static
         * @param {mini.IRBStateReq} message RBStateReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RBStateReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RBStateReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.RBStateReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.RBStateReq} RBStateReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RBStateReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.RBStateReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.completeTask = reader.bool();
                    break;
                case 2:
                    message.gameId = reader.int32();
                    break;
                case 3:
                    message.roomId = reader.int32();
                    break;
                case 4:
                    message.initBet = reader.int32();
                    break;
                case 5:
                    message.queryType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RBStateReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.RBStateReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.RBStateReq} RBStateReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RBStateReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RBStateReq message.
         * @function verify
         * @memberof mini.RBStateReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RBStateReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.completeTask != null && message.hasOwnProperty("completeTask"))
                if (typeof message.completeTask !== "boolean")
                    return "completeTask: boolean expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isInteger(message.gameId))
                    return "gameId: integer expected";
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                if (!$util.isInteger(message.roomId))
                    return "roomId: integer expected";
            if (message.initBet != null && message.hasOwnProperty("initBet"))
                if (!$util.isInteger(message.initBet))
                    return "initBet: integer expected";
            if (message.queryType != null && message.hasOwnProperty("queryType"))
                if (!$util.isInteger(message.queryType))
                    return "queryType: integer expected";
            return null;
        };

        /**
         * Creates a RBStateReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.RBStateReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.RBStateReq} RBStateReq
         */
        RBStateReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.RBStateReq)
                return object;
            let message = new $root.mini.RBStateReq();
            if (object.completeTask != null)
                message.completeTask = Boolean(object.completeTask);
            if (object.gameId != null)
                message.gameId = object.gameId | 0;
            if (object.roomId != null)
                message.roomId = object.roomId | 0;
            if (object.initBet != null)
                message.initBet = object.initBet | 0;
            if (object.queryType != null)
                message.queryType = object.queryType | 0;
            return message;
        };

        /**
         * Creates a plain object from a RBStateReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.RBStateReq
         * @static
         * @param {mini.RBStateReq} message RBStateReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RBStateReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.completeTask = false;
                object.gameId = 0;
                object.roomId = 0;
                object.initBet = 0;
                object.queryType = 0;
            }
            if (message.completeTask != null && message.hasOwnProperty("completeTask"))
                object.completeTask = message.completeTask;
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                object.roomId = message.roomId;
            if (message.initBet != null && message.hasOwnProperty("initBet"))
                object.initBet = message.initBet;
            if (message.queryType != null && message.hasOwnProperty("queryType"))
                object.queryType = message.queryType;
            return object;
        };

        /**
         * Converts this RBStateReq to JSON.
         * @function toJSON
         * @memberof mini.RBStateReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RBStateReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RBStateReq;
    })();

    mini.RBStateReply = (function() {

        /**
         * Properties of a RBStateReply.
         * @memberof mini
         * @interface IRBStateReply
         * @property {boolean|null} [isGuide] RBStateReply isGuide
         * @property {number|null} [remainFreeTimes] RBStateReply remainFreeTimes
         * @property {number|null} [totalFreeTimes] RBStateReply totalFreeTimes
         * @property {number|null} [freeAmount] RBStateReply freeAmount
         * @property {number|null} [availableBalance] RBStateReply availableBalance
         * @property {string|null} [history] RBStateReply history
         * @property {string|null} [payout] RBStateReply payout
         * @property {boolean|null} [showVipTask] RBStateReply showVipTask
         * @property {Array.<number>|null} [bets] RBStateReply bets
         * @property {number|null} [defaultBet] RBStateReply defaultBet
         * @property {number|null} [queryType] RBStateReply queryType
         */

        /**
         * Constructs a new RBStateReply.
         * @memberof mini
         * @classdesc Represents a RBStateReply.
         * @implements IRBStateReply
         * @constructor
         * @param {mini.IRBStateReply=} [properties] Properties to set
         */
        function RBStateReply(properties) {
            this.bets = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RBStateReply isGuide.
         * @member {boolean} isGuide
         * @memberof mini.RBStateReply
         * @instance
         */
        RBStateReply.prototype.isGuide = false;

        /**
         * RBStateReply remainFreeTimes.
         * @member {number} remainFreeTimes
         * @memberof mini.RBStateReply
         * @instance
         */
        RBStateReply.prototype.remainFreeTimes = 0;

        /**
         * RBStateReply totalFreeTimes.
         * @member {number} totalFreeTimes
         * @memberof mini.RBStateReply
         * @instance
         */
        RBStateReply.prototype.totalFreeTimes = 0;

        /**
         * RBStateReply freeAmount.
         * @member {number} freeAmount
         * @memberof mini.RBStateReply
         * @instance
         */
        RBStateReply.prototype.freeAmount = 0;

        /**
         * RBStateReply availableBalance.
         * @member {number} availableBalance
         * @memberof mini.RBStateReply
         * @instance
         */
        RBStateReply.prototype.availableBalance = 0;

        /**
         * RBStateReply history.
         * @member {string} history
         * @memberof mini.RBStateReply
         * @instance
         */
        RBStateReply.prototype.history = "";

        /**
         * RBStateReply payout.
         * @member {string} payout
         * @memberof mini.RBStateReply
         * @instance
         */
        RBStateReply.prototype.payout = "";

        /**
         * RBStateReply showVipTask.
         * @member {boolean} showVipTask
         * @memberof mini.RBStateReply
         * @instance
         */
        RBStateReply.prototype.showVipTask = false;

        /**
         * RBStateReply bets.
         * @member {Array.<number>} bets
         * @memberof mini.RBStateReply
         * @instance
         */
        RBStateReply.prototype.bets = $util.emptyArray;

        /**
         * RBStateReply defaultBet.
         * @member {number} defaultBet
         * @memberof mini.RBStateReply
         * @instance
         */
        RBStateReply.prototype.defaultBet = 0;

        /**
         * RBStateReply queryType.
         * @member {number} queryType
         * @memberof mini.RBStateReply
         * @instance
         */
        RBStateReply.prototype.queryType = 0;

        /**
         * Creates a new RBStateReply instance using the specified properties.
         * @function create
         * @memberof mini.RBStateReply
         * @static
         * @param {mini.IRBStateReply=} [properties] Properties to set
         * @returns {mini.RBStateReply} RBStateReply instance
         */
        RBStateReply.create = function create(properties) {
            return new RBStateReply(properties);
        };

        /**
         * Encodes the specified RBStateReply message. Does not implicitly {@link mini.RBStateReply.verify|verify} messages.
         * @function encode
         * @memberof mini.RBStateReply
         * @static
         * @param {mini.IRBStateReply} message RBStateReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RBStateReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isGuide != null && Object.hasOwnProperty.call(message, "isGuide"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isGuide);
            if (message.remainFreeTimes != null && Object.hasOwnProperty.call(message, "remainFreeTimes"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.remainFreeTimes);
            if (message.totalFreeTimes != null && Object.hasOwnProperty.call(message, "totalFreeTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.totalFreeTimes);
            if (message.freeAmount != null && Object.hasOwnProperty.call(message, "freeAmount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.freeAmount);
            if (message.availableBalance != null && Object.hasOwnProperty.call(message, "availableBalance"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.availableBalance);
            if (message.history != null && Object.hasOwnProperty.call(message, "history"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.history);
            if (message.payout != null && Object.hasOwnProperty.call(message, "payout"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.payout);
            if (message.showVipTask != null && Object.hasOwnProperty.call(message, "showVipTask"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.showVipTask);
            if (message.bets != null && message.bets.length) {
                writer.uint32(/* id 9, wireType 2 =*/74).fork();
                for (let i = 0; i < message.bets.length; ++i)
                    writer.int32(message.bets[i]);
                writer.ldelim();
            }
            if (message.defaultBet != null && Object.hasOwnProperty.call(message, "defaultBet"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.defaultBet);
            if (message.queryType != null && Object.hasOwnProperty.call(message, "queryType"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.queryType);
            return writer;
        };

        /**
         * Encodes the specified RBStateReply message, length delimited. Does not implicitly {@link mini.RBStateReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.RBStateReply
         * @static
         * @param {mini.IRBStateReply} message RBStateReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RBStateReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RBStateReply message from the specified reader or buffer.
         * @function decode
         * @memberof mini.RBStateReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.RBStateReply} RBStateReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RBStateReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.RBStateReply();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isGuide = reader.bool();
                    break;
                case 2:
                    message.remainFreeTimes = reader.int32();
                    break;
                case 3:
                    message.totalFreeTimes = reader.int32();
                    break;
                case 4:
                    message.freeAmount = reader.int32();
                    break;
                case 5:
                    message.availableBalance = reader.int32();
                    break;
                case 6:
                    message.history = reader.string();
                    break;
                case 7:
                    message.payout = reader.string();
                    break;
                case 8:
                    message.showVipTask = reader.bool();
                    break;
                case 9:
                    if (!(message.bets && message.bets.length))
                        message.bets = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.bets.push(reader.int32());
                    } else
                        message.bets.push(reader.int32());
                    break;
                case 10:
                    message.defaultBet = reader.int32();
                    break;
                case 11:
                    message.queryType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RBStateReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.RBStateReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.RBStateReply} RBStateReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RBStateReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RBStateReply message.
         * @function verify
         * @memberof mini.RBStateReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RBStateReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isGuide != null && message.hasOwnProperty("isGuide"))
                if (typeof message.isGuide !== "boolean")
                    return "isGuide: boolean expected";
            if (message.remainFreeTimes != null && message.hasOwnProperty("remainFreeTimes"))
                if (!$util.isInteger(message.remainFreeTimes))
                    return "remainFreeTimes: integer expected";
            if (message.totalFreeTimes != null && message.hasOwnProperty("totalFreeTimes"))
                if (!$util.isInteger(message.totalFreeTimes))
                    return "totalFreeTimes: integer expected";
            if (message.freeAmount != null && message.hasOwnProperty("freeAmount"))
                if (!$util.isInteger(message.freeAmount))
                    return "freeAmount: integer expected";
            if (message.availableBalance != null && message.hasOwnProperty("availableBalance"))
                if (!$util.isInteger(message.availableBalance))
                    return "availableBalance: integer expected";
            if (message.history != null && message.hasOwnProperty("history"))
                if (!$util.isString(message.history))
                    return "history: string expected";
            if (message.payout != null && message.hasOwnProperty("payout"))
                if (!$util.isString(message.payout))
                    return "payout: string expected";
            if (message.showVipTask != null && message.hasOwnProperty("showVipTask"))
                if (typeof message.showVipTask !== "boolean")
                    return "showVipTask: boolean expected";
            if (message.bets != null && message.hasOwnProperty("bets")) {
                if (!Array.isArray(message.bets))
                    return "bets: array expected";
                for (let i = 0; i < message.bets.length; ++i)
                    if (!$util.isInteger(message.bets[i]))
                        return "bets: integer[] expected";
            }
            if (message.defaultBet != null && message.hasOwnProperty("defaultBet"))
                if (!$util.isInteger(message.defaultBet))
                    return "defaultBet: integer expected";
            if (message.queryType != null && message.hasOwnProperty("queryType"))
                if (!$util.isInteger(message.queryType))
                    return "queryType: integer expected";
            return null;
        };

        /**
         * Creates a RBStateReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.RBStateReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.RBStateReply} RBStateReply
         */
        RBStateReply.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.RBStateReply)
                return object;
            let message = new $root.mini.RBStateReply();
            if (object.isGuide != null)
                message.isGuide = Boolean(object.isGuide);
            if (object.remainFreeTimes != null)
                message.remainFreeTimes = object.remainFreeTimes | 0;
            if (object.totalFreeTimes != null)
                message.totalFreeTimes = object.totalFreeTimes | 0;
            if (object.freeAmount != null)
                message.freeAmount = object.freeAmount | 0;
            if (object.availableBalance != null)
                message.availableBalance = object.availableBalance | 0;
            if (object.history != null)
                message.history = String(object.history);
            if (object.payout != null)
                message.payout = String(object.payout);
            if (object.showVipTask != null)
                message.showVipTask = Boolean(object.showVipTask);
            if (object.bets) {
                if (!Array.isArray(object.bets))
                    throw TypeError(".mini.RBStateReply.bets: array expected");
                message.bets = [];
                for (let i = 0; i < object.bets.length; ++i)
                    message.bets[i] = object.bets[i] | 0;
            }
            if (object.defaultBet != null)
                message.defaultBet = object.defaultBet | 0;
            if (object.queryType != null)
                message.queryType = object.queryType | 0;
            return message;
        };

        /**
         * Creates a plain object from a RBStateReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.RBStateReply
         * @static
         * @param {mini.RBStateReply} message RBStateReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RBStateReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.bets = [];
            if (options.defaults) {
                object.isGuide = false;
                object.remainFreeTimes = 0;
                object.totalFreeTimes = 0;
                object.freeAmount = 0;
                object.availableBalance = 0;
                object.history = "";
                object.payout = "";
                object.showVipTask = false;
                object.defaultBet = 0;
                object.queryType = 0;
            }
            if (message.isGuide != null && message.hasOwnProperty("isGuide"))
                object.isGuide = message.isGuide;
            if (message.remainFreeTimes != null && message.hasOwnProperty("remainFreeTimes"))
                object.remainFreeTimes = message.remainFreeTimes;
            if (message.totalFreeTimes != null && message.hasOwnProperty("totalFreeTimes"))
                object.totalFreeTimes = message.totalFreeTimes;
            if (message.freeAmount != null && message.hasOwnProperty("freeAmount"))
                object.freeAmount = message.freeAmount;
            if (message.availableBalance != null && message.hasOwnProperty("availableBalance"))
                object.availableBalance = message.availableBalance;
            if (message.history != null && message.hasOwnProperty("history"))
                object.history = message.history;
            if (message.payout != null && message.hasOwnProperty("payout"))
                object.payout = message.payout;
            if (message.showVipTask != null && message.hasOwnProperty("showVipTask"))
                object.showVipTask = message.showVipTask;
            if (message.bets && message.bets.length) {
                object.bets = [];
                for (let j = 0; j < message.bets.length; ++j)
                    object.bets[j] = message.bets[j];
            }
            if (message.defaultBet != null && message.hasOwnProperty("defaultBet"))
                object.defaultBet = message.defaultBet;
            if (message.queryType != null && message.hasOwnProperty("queryType"))
                object.queryType = message.queryType;
            return object;
        };

        /**
         * Converts this RBStateReply to JSON.
         * @function toJSON
         * @memberof mini.RBStateReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RBStateReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RBStateReply;
    })();

    mini.RBBetReq = (function() {

        /**
         * Properties of a RBBetReq.
         * @memberof mini
         * @interface IRBBetReq
         * @property {boolean|null} [isGuide] RBBetReq isGuide
         * @property {boolean|null} [isFree] RBBetReq isFree
         * @property {number|null} [amount] RBBetReq amount
         * @property {mini.RB_AREA_TYPE|null} [area] RBBetReq area
         */

        /**
         * Constructs a new RBBetReq.
         * @memberof mini
         * @classdesc Represents a RBBetReq.
         * @implements IRBBetReq
         * @constructor
         * @param {mini.IRBBetReq=} [properties] Properties to set
         */
        function RBBetReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RBBetReq isGuide.
         * @member {boolean} isGuide
         * @memberof mini.RBBetReq
         * @instance
         */
        RBBetReq.prototype.isGuide = false;

        /**
         * RBBetReq isFree.
         * @member {boolean} isFree
         * @memberof mini.RBBetReq
         * @instance
         */
        RBBetReq.prototype.isFree = false;

        /**
         * RBBetReq amount.
         * @member {number} amount
         * @memberof mini.RBBetReq
         * @instance
         */
        RBBetReq.prototype.amount = 0;

        /**
         * RBBetReq area.
         * @member {mini.RB_AREA_TYPE} area
         * @memberof mini.RBBetReq
         * @instance
         */
        RBBetReq.prototype.area = 0;

        /**
         * Creates a new RBBetReq instance using the specified properties.
         * @function create
         * @memberof mini.RBBetReq
         * @static
         * @param {mini.IRBBetReq=} [properties] Properties to set
         * @returns {mini.RBBetReq} RBBetReq instance
         */
        RBBetReq.create = function create(properties) {
            return new RBBetReq(properties);
        };

        /**
         * Encodes the specified RBBetReq message. Does not implicitly {@link mini.RBBetReq.verify|verify} messages.
         * @function encode
         * @memberof mini.RBBetReq
         * @static
         * @param {mini.IRBBetReq} message RBBetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RBBetReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isGuide != null && Object.hasOwnProperty.call(message, "isGuide"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isGuide);
            if (message.isFree != null && Object.hasOwnProperty.call(message, "isFree"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFree);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.amount);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.area);
            return writer;
        };

        /**
         * Encodes the specified RBBetReq message, length delimited. Does not implicitly {@link mini.RBBetReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.RBBetReq
         * @static
         * @param {mini.IRBBetReq} message RBBetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RBBetReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RBBetReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.RBBetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.RBBetReq} RBBetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RBBetReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.RBBetReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isGuide = reader.bool();
                    break;
                case 2:
                    message.isFree = reader.bool();
                    break;
                case 3:
                    message.amount = reader.int32();
                    break;
                case 4:
                    message.area = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RBBetReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.RBBetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.RBBetReq} RBBetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RBBetReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RBBetReq message.
         * @function verify
         * @memberof mini.RBBetReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RBBetReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isGuide != null && message.hasOwnProperty("isGuide"))
                if (typeof message.isGuide !== "boolean")
                    return "isGuide: boolean expected";
            if (message.isFree != null && message.hasOwnProperty("isFree"))
                if (typeof message.isFree !== "boolean")
                    return "isFree: boolean expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount))
                    return "amount: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                switch (message.area) {
                default:
                    return "area: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            return null;
        };

        /**
         * Creates a RBBetReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.RBBetReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.RBBetReq} RBBetReq
         */
        RBBetReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.RBBetReq)
                return object;
            let message = new $root.mini.RBBetReq();
            if (object.isGuide != null)
                message.isGuide = Boolean(object.isGuide);
            if (object.isFree != null)
                message.isFree = Boolean(object.isFree);
            if (object.amount != null)
                message.amount = object.amount | 0;
            switch (object.area) {
            case "RB_NONE":
            case 0:
                message.area = 0;
                break;
            case "RB_SPADE":
            case 1:
                message.area = 1;
                break;
            case "RB_HEART":
            case 2:
                message.area = 2;
                break;
            case "RB_CLUB":
            case 3:
                message.area = 3;
                break;
            case "RB_DIAMOND":
            case 4:
                message.area = 4;
                break;
            case "RB_JOKER":
            case 5:
                message.area = 5;
                break;
            case "RB_RED":
            case 6:
                message.area = 6;
                break;
            case "RB_BLACK":
            case 7:
                message.area = 7;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a RBBetReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.RBBetReq
         * @static
         * @param {mini.RBBetReq} message RBBetReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RBBetReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.isGuide = false;
                object.isFree = false;
                object.amount = 0;
                object.area = options.enums === String ? "RB_NONE" : 0;
            }
            if (message.isGuide != null && message.hasOwnProperty("isGuide"))
                object.isGuide = message.isGuide;
            if (message.isFree != null && message.hasOwnProperty("isFree"))
                object.isFree = message.isFree;
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = message.amount;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = options.enums === String ? $root.mini.RB_AREA_TYPE[message.area] : message.area;
            return object;
        };

        /**
         * Converts this RBBetReq to JSON.
         * @function toJSON
         * @memberof mini.RBBetReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RBBetReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RBBetReq;
    })();

    mini.RBBetReply = (function() {

        /**
         * Properties of a RBBetReply.
         * @memberof mini
         * @interface IRBBetReply
         * @property {number|null} [result] RBBetReply result
         * @property {number|null} [winBet] RBBetReply winBet
         */

        /**
         * Constructs a new RBBetReply.
         * @memberof mini
         * @classdesc Represents a RBBetReply.
         * @implements IRBBetReply
         * @constructor
         * @param {mini.IRBBetReply=} [properties] Properties to set
         */
        function RBBetReply(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RBBetReply result.
         * @member {number} result
         * @memberof mini.RBBetReply
         * @instance
         */
        RBBetReply.prototype.result = 0;

        /**
         * RBBetReply winBet.
         * @member {number} winBet
         * @memberof mini.RBBetReply
         * @instance
         */
        RBBetReply.prototype.winBet = 0;

        /**
         * Creates a new RBBetReply instance using the specified properties.
         * @function create
         * @memberof mini.RBBetReply
         * @static
         * @param {mini.IRBBetReply=} [properties] Properties to set
         * @returns {mini.RBBetReply} RBBetReply instance
         */
        RBBetReply.create = function create(properties) {
            return new RBBetReply(properties);
        };

        /**
         * Encodes the specified RBBetReply message. Does not implicitly {@link mini.RBBetReply.verify|verify} messages.
         * @function encode
         * @memberof mini.RBBetReply
         * @static
         * @param {mini.IRBBetReply} message RBBetReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RBBetReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.winBet != null && Object.hasOwnProperty.call(message, "winBet"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.winBet);
            return writer;
        };

        /**
         * Encodes the specified RBBetReply message, length delimited. Does not implicitly {@link mini.RBBetReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.RBBetReply
         * @static
         * @param {mini.IRBBetReply} message RBBetReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RBBetReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RBBetReply message from the specified reader or buffer.
         * @function decode
         * @memberof mini.RBBetReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.RBBetReply} RBBetReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RBBetReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.RBBetReply();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.winBet = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RBBetReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.RBBetReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.RBBetReply} RBBetReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RBBetReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RBBetReply message.
         * @function verify
         * @memberof mini.RBBetReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RBBetReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
            if (message.winBet != null && message.hasOwnProperty("winBet"))
                if (!$util.isInteger(message.winBet))
                    return "winBet: integer expected";
            return null;
        };

        /**
         * Creates a RBBetReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.RBBetReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.RBBetReply} RBBetReply
         */
        RBBetReply.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.RBBetReply)
                return object;
            let message = new $root.mini.RBBetReply();
            if (object.result != null)
                message.result = object.result | 0;
            if (object.winBet != null)
                message.winBet = object.winBet | 0;
            return message;
        };

        /**
         * Creates a plain object from a RBBetReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.RBBetReply
         * @static
         * @param {mini.RBBetReply} message RBBetReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RBBetReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.result = 0;
                object.winBet = 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            if (message.winBet != null && message.hasOwnProperty("winBet"))
                object.winBet = message.winBet;
            return object;
        };

        /**
         * Converts this RBBetReply to JSON.
         * @function toJSON
         * @memberof mini.RBBetReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RBBetReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RBBetReply;
    })();

    mini.RBRankListReply = (function() {

        /**
         * Properties of a RBRankListReply.
         * @memberof mini
         * @interface IRBRankListReply
         * @property {Array.<mini.IRBRankItem>|null} [list] RBRankListReply list
         */

        /**
         * Constructs a new RBRankListReply.
         * @memberof mini
         * @classdesc Represents a RBRankListReply.
         * @implements IRBRankListReply
         * @constructor
         * @param {mini.IRBRankListReply=} [properties] Properties to set
         */
        function RBRankListReply(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RBRankListReply list.
         * @member {Array.<mini.IRBRankItem>} list
         * @memberof mini.RBRankListReply
         * @instance
         */
        RBRankListReply.prototype.list = $util.emptyArray;

        /**
         * Creates a new RBRankListReply instance using the specified properties.
         * @function create
         * @memberof mini.RBRankListReply
         * @static
         * @param {mini.IRBRankListReply=} [properties] Properties to set
         * @returns {mini.RBRankListReply} RBRankListReply instance
         */
        RBRankListReply.create = function create(properties) {
            return new RBRankListReply(properties);
        };

        /**
         * Encodes the specified RBRankListReply message. Does not implicitly {@link mini.RBRankListReply.verify|verify} messages.
         * @function encode
         * @memberof mini.RBRankListReply
         * @static
         * @param {mini.IRBRankListReply} message RBRankListReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RBRankListReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.list != null && message.list.length)
                for (let i = 0; i < message.list.length; ++i)
                    $root.mini.RBRankItem.encode(message.list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RBRankListReply message, length delimited. Does not implicitly {@link mini.RBRankListReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.RBRankListReply
         * @static
         * @param {mini.IRBRankListReply} message RBRankListReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RBRankListReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RBRankListReply message from the specified reader or buffer.
         * @function decode
         * @memberof mini.RBRankListReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.RBRankListReply} RBRankListReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RBRankListReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.RBRankListReply();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.mini.RBRankItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RBRankListReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.RBRankListReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.RBRankListReply} RBRankListReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RBRankListReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RBRankListReply message.
         * @function verify
         * @memberof mini.RBRankListReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RBRankListReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list))
                    return "list: array expected";
                for (let i = 0; i < message.list.length; ++i) {
                    let error = $root.mini.RBRankItem.verify(message.list[i]);
                    if (error)
                        return "list." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RBRankListReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.RBRankListReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.RBRankListReply} RBRankListReply
         */
        RBRankListReply.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.RBRankListReply)
                return object;
            let message = new $root.mini.RBRankListReply();
            if (object.list) {
                if (!Array.isArray(object.list))
                    throw TypeError(".mini.RBRankListReply.list: array expected");
                message.list = [];
                for (let i = 0; i < object.list.length; ++i) {
                    if (typeof object.list[i] !== "object")
                        throw TypeError(".mini.RBRankListReply.list: object expected");
                    message.list[i] = $root.mini.RBRankItem.fromObject(object.list[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RBRankListReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.RBRankListReply
         * @static
         * @param {mini.RBRankListReply} message RBRankListReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RBRankListReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.list = [];
            if (message.list && message.list.length) {
                object.list = [];
                for (let j = 0; j < message.list.length; ++j)
                    object.list[j] = $root.mini.RBRankItem.toObject(message.list[j], options);
            }
            return object;
        };

        /**
         * Converts this RBRankListReply to JSON.
         * @function toJSON
         * @memberof mini.RBRankListReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RBRankListReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RBRankListReply;
    })();

    mini.RBRankItem = (function() {

        /**
         * Properties of a RBRankItem.
         * @memberof mini
         * @interface IRBRankItem
         * @property {number|Long|null} [playerId] RBRankItem playerId
         * @property {string|null} [nickname] RBRankItem nickname
         * @property {string|null} [headId] RBRankItem headId
         * @property {string|null} [headUrl] RBRankItem headUrl
         * @property {number|null} [tag] RBRankItem tag
         * @property {number|null} [avatarFrame] RBRankItem avatarFrame
         * @property {number|null} [cardBack] RBRankItem cardBack
         * @property {number|null} [vipLevel] RBRankItem vipLevel
         * @property {number|null} [totalGames] RBRankItem totalGames
         * @property {number|null} [winAmount] RBRankItem winAmount
         */

        /**
         * Constructs a new RBRankItem.
         * @memberof mini
         * @classdesc Represents a RBRankItem.
         * @implements IRBRankItem
         * @constructor
         * @param {mini.IRBRankItem=} [properties] Properties to set
         */
        function RBRankItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RBRankItem playerId.
         * @member {number|Long} playerId
         * @memberof mini.RBRankItem
         * @instance
         */
        RBRankItem.prototype.playerId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RBRankItem nickname.
         * @member {string} nickname
         * @memberof mini.RBRankItem
         * @instance
         */
        RBRankItem.prototype.nickname = "";

        /**
         * RBRankItem headId.
         * @member {string} headId
         * @memberof mini.RBRankItem
         * @instance
         */
        RBRankItem.prototype.headId = "";

        /**
         * RBRankItem headUrl.
         * @member {string} headUrl
         * @memberof mini.RBRankItem
         * @instance
         */
        RBRankItem.prototype.headUrl = "";

        /**
         * RBRankItem tag.
         * @member {number} tag
         * @memberof mini.RBRankItem
         * @instance
         */
        RBRankItem.prototype.tag = 0;

        /**
         * RBRankItem avatarFrame.
         * @member {number} avatarFrame
         * @memberof mini.RBRankItem
         * @instance
         */
        RBRankItem.prototype.avatarFrame = 0;

        /**
         * RBRankItem cardBack.
         * @member {number} cardBack
         * @memberof mini.RBRankItem
         * @instance
         */
        RBRankItem.prototype.cardBack = 0;

        /**
         * RBRankItem vipLevel.
         * @member {number} vipLevel
         * @memberof mini.RBRankItem
         * @instance
         */
        RBRankItem.prototype.vipLevel = 0;

        /**
         * RBRankItem totalGames.
         * @member {number} totalGames
         * @memberof mini.RBRankItem
         * @instance
         */
        RBRankItem.prototype.totalGames = 0;

        /**
         * RBRankItem winAmount.
         * @member {number} winAmount
         * @memberof mini.RBRankItem
         * @instance
         */
        RBRankItem.prototype.winAmount = 0;

        /**
         * Creates a new RBRankItem instance using the specified properties.
         * @function create
         * @memberof mini.RBRankItem
         * @static
         * @param {mini.IRBRankItem=} [properties] Properties to set
         * @returns {mini.RBRankItem} RBRankItem instance
         */
        RBRankItem.create = function create(properties) {
            return new RBRankItem(properties);
        };

        /**
         * Encodes the specified RBRankItem message. Does not implicitly {@link mini.RBRankItem.verify|verify} messages.
         * @function encode
         * @memberof mini.RBRankItem
         * @static
         * @param {mini.IRBRankItem} message RBRankItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RBRankItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerId != null && Object.hasOwnProperty.call(message, "playerId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.playerId);
            if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);
            if (message.headId != null && Object.hasOwnProperty.call(message, "headId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.headId);
            if (message.headUrl != null && Object.hasOwnProperty.call(message, "headUrl"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.headUrl);
            if (message.tag != null && Object.hasOwnProperty.call(message, "tag"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.tag);
            if (message.avatarFrame != null && Object.hasOwnProperty.call(message, "avatarFrame"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.avatarFrame);
            if (message.cardBack != null && Object.hasOwnProperty.call(message, "cardBack"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.cardBack);
            if (message.vipLevel != null && Object.hasOwnProperty.call(message, "vipLevel"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.vipLevel);
            if (message.totalGames != null && Object.hasOwnProperty.call(message, "totalGames"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.totalGames);
            if (message.winAmount != null && Object.hasOwnProperty.call(message, "winAmount"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.winAmount);
            return writer;
        };

        /**
         * Encodes the specified RBRankItem message, length delimited. Does not implicitly {@link mini.RBRankItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.RBRankItem
         * @static
         * @param {mini.IRBRankItem} message RBRankItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RBRankItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RBRankItem message from the specified reader or buffer.
         * @function decode
         * @memberof mini.RBRankItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.RBRankItem} RBRankItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RBRankItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.RBRankItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerId = reader.uint64();
                    break;
                case 2:
                    message.nickname = reader.string();
                    break;
                case 3:
                    message.headId = reader.string();
                    break;
                case 4:
                    message.headUrl = reader.string();
                    break;
                case 5:
                    message.tag = reader.int32();
                    break;
                case 6:
                    message.avatarFrame = reader.int32();
                    break;
                case 7:
                    message.cardBack = reader.int32();
                    break;
                case 8:
                    message.vipLevel = reader.int32();
                    break;
                case 9:
                    message.totalGames = reader.int32();
                    break;
                case 10:
                    message.winAmount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RBRankItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.RBRankItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.RBRankItem} RBRankItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RBRankItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RBRankItem message.
         * @function verify
         * @memberof mini.RBRankItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RBRankItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                if (!$util.isInteger(message.playerId) && !(message.playerId && $util.isInteger(message.playerId.low) && $util.isInteger(message.playerId.high)))
                    return "playerId: integer|Long expected";
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                if (!$util.isString(message.nickname))
                    return "nickname: string expected";
            if (message.headId != null && message.hasOwnProperty("headId"))
                if (!$util.isString(message.headId))
                    return "headId: string expected";
            if (message.headUrl != null && message.hasOwnProperty("headUrl"))
                if (!$util.isString(message.headUrl))
                    return "headUrl: string expected";
            if (message.tag != null && message.hasOwnProperty("tag"))
                if (!$util.isInteger(message.tag))
                    return "tag: integer expected";
            if (message.avatarFrame != null && message.hasOwnProperty("avatarFrame"))
                if (!$util.isInteger(message.avatarFrame))
                    return "avatarFrame: integer expected";
            if (message.cardBack != null && message.hasOwnProperty("cardBack"))
                if (!$util.isInteger(message.cardBack))
                    return "cardBack: integer expected";
            if (message.vipLevel != null && message.hasOwnProperty("vipLevel"))
                if (!$util.isInteger(message.vipLevel))
                    return "vipLevel: integer expected";
            if (message.totalGames != null && message.hasOwnProperty("totalGames"))
                if (!$util.isInteger(message.totalGames))
                    return "totalGames: integer expected";
            if (message.winAmount != null && message.hasOwnProperty("winAmount"))
                if (!$util.isInteger(message.winAmount))
                    return "winAmount: integer expected";
            return null;
        };

        /**
         * Creates a RBRankItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.RBRankItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.RBRankItem} RBRankItem
         */
        RBRankItem.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.RBRankItem)
                return object;
            let message = new $root.mini.RBRankItem();
            if (object.playerId != null)
                if ($util.Long)
                    (message.playerId = $util.Long.fromValue(object.playerId)).unsigned = true;
                else if (typeof object.playerId === "string")
                    message.playerId = parseInt(object.playerId, 10);
                else if (typeof object.playerId === "number")
                    message.playerId = object.playerId;
                else if (typeof object.playerId === "object")
                    message.playerId = new $util.LongBits(object.playerId.low >>> 0, object.playerId.high >>> 0).toNumber(true);
            if (object.nickname != null)
                message.nickname = String(object.nickname);
            if (object.headId != null)
                message.headId = String(object.headId);
            if (object.headUrl != null)
                message.headUrl = String(object.headUrl);
            if (object.tag != null)
                message.tag = object.tag | 0;
            if (object.avatarFrame != null)
                message.avatarFrame = object.avatarFrame | 0;
            if (object.cardBack != null)
                message.cardBack = object.cardBack | 0;
            if (object.vipLevel != null)
                message.vipLevel = object.vipLevel | 0;
            if (object.totalGames != null)
                message.totalGames = object.totalGames | 0;
            if (object.winAmount != null)
                message.winAmount = object.winAmount | 0;
            return message;
        };

        /**
         * Creates a plain object from a RBRankItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.RBRankItem
         * @static
         * @param {mini.RBRankItem} message RBRankItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RBRankItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.playerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.playerId = options.longs === String ? "0" : 0;
                object.nickname = "";
                object.headId = "";
                object.headUrl = "";
                object.tag = 0;
                object.avatarFrame = 0;
                object.cardBack = 0;
                object.vipLevel = 0;
                object.totalGames = 0;
                object.winAmount = 0;
            }
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                if (typeof message.playerId === "number")
                    object.playerId = options.longs === String ? String(message.playerId) : message.playerId;
                else
                    object.playerId = options.longs === String ? $util.Long.prototype.toString.call(message.playerId) : options.longs === Number ? new $util.LongBits(message.playerId.low >>> 0, message.playerId.high >>> 0).toNumber(true) : message.playerId;
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                object.nickname = message.nickname;
            if (message.headId != null && message.hasOwnProperty("headId"))
                object.headId = message.headId;
            if (message.headUrl != null && message.hasOwnProperty("headUrl"))
                object.headUrl = message.headUrl;
            if (message.tag != null && message.hasOwnProperty("tag"))
                object.tag = message.tag;
            if (message.avatarFrame != null && message.hasOwnProperty("avatarFrame"))
                object.avatarFrame = message.avatarFrame;
            if (message.cardBack != null && message.hasOwnProperty("cardBack"))
                object.cardBack = message.cardBack;
            if (message.vipLevel != null && message.hasOwnProperty("vipLevel"))
                object.vipLevel = message.vipLevel;
            if (message.totalGames != null && message.hasOwnProperty("totalGames"))
                object.totalGames = message.totalGames;
            if (message.winAmount != null && message.hasOwnProperty("winAmount"))
                object.winAmount = message.winAmount;
            return object;
        };

        /**
         * Converts this RBRankItem to JSON.
         * @function toJSON
         * @memberof mini.RBRankItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RBRankItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RBRankItem;
    })();

    mini.Slots1StateReply = (function() {

        /**
         * Properties of a Slots1StateReply.
         * @memberof mini
         * @interface ISlots1StateReply
         * @property {Array.<number>|null} [initMap] Slots1StateReply initMap
         * @property {number|null} [availableBalance] Slots1StateReply availableBalance
         * @property {string|null} [params] Slots1StateReply params
         * @property {number|null} [totalBet] Slots1StateReply totalBet
         * @property {number|null} [totalWin] Slots1StateReply totalWin
         */

        /**
         * Constructs a new Slots1StateReply.
         * @memberof mini
         * @classdesc Represents a Slots1StateReply.
         * @implements ISlots1StateReply
         * @constructor
         * @param {mini.ISlots1StateReply=} [properties] Properties to set
         */
        function Slots1StateReply(properties) {
            this.initMap = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Slots1StateReply initMap.
         * @member {Array.<number>} initMap
         * @memberof mini.Slots1StateReply
         * @instance
         */
        Slots1StateReply.prototype.initMap = $util.emptyArray;

        /**
         * Slots1StateReply availableBalance.
         * @member {number} availableBalance
         * @memberof mini.Slots1StateReply
         * @instance
         */
        Slots1StateReply.prototype.availableBalance = 0;

        /**
         * Slots1StateReply params.
         * @member {string} params
         * @memberof mini.Slots1StateReply
         * @instance
         */
        Slots1StateReply.prototype.params = "";

        /**
         * Slots1StateReply totalBet.
         * @member {number} totalBet
         * @memberof mini.Slots1StateReply
         * @instance
         */
        Slots1StateReply.prototype.totalBet = 0;

        /**
         * Slots1StateReply totalWin.
         * @member {number} totalWin
         * @memberof mini.Slots1StateReply
         * @instance
         */
        Slots1StateReply.prototype.totalWin = 0;

        /**
         * Creates a new Slots1StateReply instance using the specified properties.
         * @function create
         * @memberof mini.Slots1StateReply
         * @static
         * @param {mini.ISlots1StateReply=} [properties] Properties to set
         * @returns {mini.Slots1StateReply} Slots1StateReply instance
         */
        Slots1StateReply.create = function create(properties) {
            return new Slots1StateReply(properties);
        };

        /**
         * Encodes the specified Slots1StateReply message. Does not implicitly {@link mini.Slots1StateReply.verify|verify} messages.
         * @function encode
         * @memberof mini.Slots1StateReply
         * @static
         * @param {mini.ISlots1StateReply} message Slots1StateReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots1StateReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.initMap != null && message.initMap.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.initMap.length; ++i)
                    writer.int32(message.initMap[i]);
                writer.ldelim();
            }
            if (message.availableBalance != null && Object.hasOwnProperty.call(message, "availableBalance"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.availableBalance);
            if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.params);
            if (message.totalBet != null && Object.hasOwnProperty.call(message, "totalBet"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.totalBet);
            if (message.totalWin != null && Object.hasOwnProperty.call(message, "totalWin"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.totalWin);
            return writer;
        };

        /**
         * Encodes the specified Slots1StateReply message, length delimited. Does not implicitly {@link mini.Slots1StateReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.Slots1StateReply
         * @static
         * @param {mini.ISlots1StateReply} message Slots1StateReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots1StateReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Slots1StateReply message from the specified reader or buffer.
         * @function decode
         * @memberof mini.Slots1StateReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.Slots1StateReply} Slots1StateReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots1StateReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.Slots1StateReply();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.initMap && message.initMap.length))
                        message.initMap = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.initMap.push(reader.int32());
                    } else
                        message.initMap.push(reader.int32());
                    break;
                case 2:
                    message.availableBalance = reader.int32();
                    break;
                case 3:
                    message.params = reader.string();
                    break;
                case 4:
                    message.totalBet = reader.int32();
                    break;
                case 5:
                    message.totalWin = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Slots1StateReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.Slots1StateReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.Slots1StateReply} Slots1StateReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots1StateReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Slots1StateReply message.
         * @function verify
         * @memberof mini.Slots1StateReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Slots1StateReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.initMap != null && message.hasOwnProperty("initMap")) {
                if (!Array.isArray(message.initMap))
                    return "initMap: array expected";
                for (let i = 0; i < message.initMap.length; ++i)
                    if (!$util.isInteger(message.initMap[i]))
                        return "initMap: integer[] expected";
            }
            if (message.availableBalance != null && message.hasOwnProperty("availableBalance"))
                if (!$util.isInteger(message.availableBalance))
                    return "availableBalance: integer expected";
            if (message.params != null && message.hasOwnProperty("params"))
                if (!$util.isString(message.params))
                    return "params: string expected";
            if (message.totalBet != null && message.hasOwnProperty("totalBet"))
                if (!$util.isInteger(message.totalBet))
                    return "totalBet: integer expected";
            if (message.totalWin != null && message.hasOwnProperty("totalWin"))
                if (!$util.isInteger(message.totalWin))
                    return "totalWin: integer expected";
            return null;
        };

        /**
         * Creates a Slots1StateReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.Slots1StateReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.Slots1StateReply} Slots1StateReply
         */
        Slots1StateReply.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.Slots1StateReply)
                return object;
            let message = new $root.mini.Slots1StateReply();
            if (object.initMap) {
                if (!Array.isArray(object.initMap))
                    throw TypeError(".mini.Slots1StateReply.initMap: array expected");
                message.initMap = [];
                for (let i = 0; i < object.initMap.length; ++i)
                    message.initMap[i] = object.initMap[i] | 0;
            }
            if (object.availableBalance != null)
                message.availableBalance = object.availableBalance | 0;
            if (object.params != null)
                message.params = String(object.params);
            if (object.totalBet != null)
                message.totalBet = object.totalBet | 0;
            if (object.totalWin != null)
                message.totalWin = object.totalWin | 0;
            return message;
        };

        /**
         * Creates a plain object from a Slots1StateReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.Slots1StateReply
         * @static
         * @param {mini.Slots1StateReply} message Slots1StateReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Slots1StateReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.initMap = [];
            if (options.defaults) {
                object.availableBalance = 0;
                object.params = "";
                object.totalBet = 0;
                object.totalWin = 0;
            }
            if (message.initMap && message.initMap.length) {
                object.initMap = [];
                for (let j = 0; j < message.initMap.length; ++j)
                    object.initMap[j] = message.initMap[j];
            }
            if (message.availableBalance != null && message.hasOwnProperty("availableBalance"))
                object.availableBalance = message.availableBalance;
            if (message.params != null && message.hasOwnProperty("params"))
                object.params = message.params;
            if (message.totalBet != null && message.hasOwnProperty("totalBet"))
                object.totalBet = message.totalBet;
            if (message.totalWin != null && message.hasOwnProperty("totalWin"))
                object.totalWin = message.totalWin;
            return object;
        };

        /**
         * Converts this Slots1StateReply to JSON.
         * @function toJSON
         * @memberof mini.Slots1StateReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Slots1StateReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Slots1StateReply;
    })();

    mini.Slots1BetReq = (function() {

        /**
         * Properties of a Slots1BetReq.
         * @memberof mini
         * @interface ISlots1BetReq
         * @property {number|null} [betAmount] Slots1BetReq betAmount
         */

        /**
         * Constructs a new Slots1BetReq.
         * @memberof mini
         * @classdesc Represents a Slots1BetReq.
         * @implements ISlots1BetReq
         * @constructor
         * @param {mini.ISlots1BetReq=} [properties] Properties to set
         */
        function Slots1BetReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Slots1BetReq betAmount.
         * @member {number} betAmount
         * @memberof mini.Slots1BetReq
         * @instance
         */
        Slots1BetReq.prototype.betAmount = 0;

        /**
         * Creates a new Slots1BetReq instance using the specified properties.
         * @function create
         * @memberof mini.Slots1BetReq
         * @static
         * @param {mini.ISlots1BetReq=} [properties] Properties to set
         * @returns {mini.Slots1BetReq} Slots1BetReq instance
         */
        Slots1BetReq.create = function create(properties) {
            return new Slots1BetReq(properties);
        };

        /**
         * Encodes the specified Slots1BetReq message. Does not implicitly {@link mini.Slots1BetReq.verify|verify} messages.
         * @function encode
         * @memberof mini.Slots1BetReq
         * @static
         * @param {mini.ISlots1BetReq} message Slots1BetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots1BetReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.betAmount != null && Object.hasOwnProperty.call(message, "betAmount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.betAmount);
            return writer;
        };

        /**
         * Encodes the specified Slots1BetReq message, length delimited. Does not implicitly {@link mini.Slots1BetReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.Slots1BetReq
         * @static
         * @param {mini.ISlots1BetReq} message Slots1BetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots1BetReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Slots1BetReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.Slots1BetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.Slots1BetReq} Slots1BetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots1BetReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.Slots1BetReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    message.betAmount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Slots1BetReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.Slots1BetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.Slots1BetReq} Slots1BetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots1BetReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Slots1BetReq message.
         * @function verify
         * @memberof mini.Slots1BetReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Slots1BetReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.betAmount != null && message.hasOwnProperty("betAmount"))
                if (!$util.isInteger(message.betAmount))
                    return "betAmount: integer expected";
            return null;
        };

        /**
         * Creates a Slots1BetReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.Slots1BetReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.Slots1BetReq} Slots1BetReq
         */
        Slots1BetReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.Slots1BetReq)
                return object;
            let message = new $root.mini.Slots1BetReq();
            if (object.betAmount != null)
                message.betAmount = object.betAmount | 0;
            return message;
        };

        /**
         * Creates a plain object from a Slots1BetReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.Slots1BetReq
         * @static
         * @param {mini.Slots1BetReq} message Slots1BetReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Slots1BetReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.betAmount = 0;
            if (message.betAmount != null && message.hasOwnProperty("betAmount"))
                object.betAmount = message.betAmount;
            return object;
        };

        /**
         * Converts this Slots1BetReq to JSON.
         * @function toJSON
         * @memberof mini.Slots1BetReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Slots1BetReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Slots1BetReq;
    })();

    mini.Slots1BetReply = (function() {

        /**
         * Properties of a Slots1BetReply.
         * @memberof mini
         * @interface ISlots1BetReply
         * @property {Array.<number>|null} [resultMap] Slots1BetReply resultMap
         * @property {number|null} [winAmount] Slots1BetReply winAmount
         */

        /**
         * Constructs a new Slots1BetReply.
         * @memberof mini
         * @classdesc Represents a Slots1BetReply.
         * @implements ISlots1BetReply
         * @constructor
         * @param {mini.ISlots1BetReply=} [properties] Properties to set
         */
        function Slots1BetReply(properties) {
            this.resultMap = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Slots1BetReply resultMap.
         * @member {Array.<number>} resultMap
         * @memberof mini.Slots1BetReply
         * @instance
         */
        Slots1BetReply.prototype.resultMap = $util.emptyArray;

        /**
         * Slots1BetReply winAmount.
         * @member {number} winAmount
         * @memberof mini.Slots1BetReply
         * @instance
         */
        Slots1BetReply.prototype.winAmount = 0;

        /**
         * Creates a new Slots1BetReply instance using the specified properties.
         * @function create
         * @memberof mini.Slots1BetReply
         * @static
         * @param {mini.ISlots1BetReply=} [properties] Properties to set
         * @returns {mini.Slots1BetReply} Slots1BetReply instance
         */
        Slots1BetReply.create = function create(properties) {
            return new Slots1BetReply(properties);
        };

        /**
         * Encodes the specified Slots1BetReply message. Does not implicitly {@link mini.Slots1BetReply.verify|verify} messages.
         * @function encode
         * @memberof mini.Slots1BetReply
         * @static
         * @param {mini.ISlots1BetReply} message Slots1BetReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots1BetReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resultMap != null && message.resultMap.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.resultMap.length; ++i)
                    writer.int32(message.resultMap[i]);
                writer.ldelim();
            }
            if (message.winAmount != null && Object.hasOwnProperty.call(message, "winAmount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.winAmount);
            return writer;
        };

        /**
         * Encodes the specified Slots1BetReply message, length delimited. Does not implicitly {@link mini.Slots1BetReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.Slots1BetReply
         * @static
         * @param {mini.ISlots1BetReply} message Slots1BetReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots1BetReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Slots1BetReply message from the specified reader or buffer.
         * @function decode
         * @memberof mini.Slots1BetReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.Slots1BetReply} Slots1BetReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots1BetReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.Slots1BetReply();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.resultMap && message.resultMap.length))
                        message.resultMap = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.resultMap.push(reader.int32());
                    } else
                        message.resultMap.push(reader.int32());
                    break;
                case 3:
                    message.winAmount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Slots1BetReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.Slots1BetReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.Slots1BetReply} Slots1BetReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots1BetReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Slots1BetReply message.
         * @function verify
         * @memberof mini.Slots1BetReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Slots1BetReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resultMap != null && message.hasOwnProperty("resultMap")) {
                if (!Array.isArray(message.resultMap))
                    return "resultMap: array expected";
                for (let i = 0; i < message.resultMap.length; ++i)
                    if (!$util.isInteger(message.resultMap[i]))
                        return "resultMap: integer[] expected";
            }
            if (message.winAmount != null && message.hasOwnProperty("winAmount"))
                if (!$util.isInteger(message.winAmount))
                    return "winAmount: integer expected";
            return null;
        };

        /**
         * Creates a Slots1BetReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.Slots1BetReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.Slots1BetReply} Slots1BetReply
         */
        Slots1BetReply.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.Slots1BetReply)
                return object;
            let message = new $root.mini.Slots1BetReply();
            if (object.resultMap) {
                if (!Array.isArray(object.resultMap))
                    throw TypeError(".mini.Slots1BetReply.resultMap: array expected");
                message.resultMap = [];
                for (let i = 0; i < object.resultMap.length; ++i)
                    message.resultMap[i] = object.resultMap[i] | 0;
            }
            if (object.winAmount != null)
                message.winAmount = object.winAmount | 0;
            return message;
        };

        /**
         * Creates a plain object from a Slots1BetReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.Slots1BetReply
         * @static
         * @param {mini.Slots1BetReply} message Slots1BetReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Slots1BetReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.resultMap = [];
            if (options.defaults)
                object.winAmount = 0;
            if (message.resultMap && message.resultMap.length) {
                object.resultMap = [];
                for (let j = 0; j < message.resultMap.length; ++j)
                    object.resultMap[j] = message.resultMap[j];
            }
            if (message.winAmount != null && message.hasOwnProperty("winAmount"))
                object.winAmount = message.winAmount;
            return object;
        };

        /**
         * Converts this Slots1BetReply to JSON.
         * @function toJSON
         * @memberof mini.Slots1BetReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Slots1BetReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Slots1BetReply;
    })();

    mini.Slots2StateReply = (function() {

        /**
         * Properties of a Slots2StateReply.
         * @memberof mini
         * @interface ISlots2StateReply
         * @property {Array.<number>|null} [initMap] Slots2StateReply initMap
         * @property {number|null} [availableBalance] Slots2StateReply availableBalance
         * @property {string|null} [params] Slots2StateReply params
         * @property {number|null} [win] Slots2StateReply win
         */

        /**
         * Constructs a new Slots2StateReply.
         * @memberof mini
         * @classdesc Represents a Slots2StateReply.
         * @implements ISlots2StateReply
         * @constructor
         * @param {mini.ISlots2StateReply=} [properties] Properties to set
         */
        function Slots2StateReply(properties) {
            this.initMap = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Slots2StateReply initMap.
         * @member {Array.<number>} initMap
         * @memberof mini.Slots2StateReply
         * @instance
         */
        Slots2StateReply.prototype.initMap = $util.emptyArray;

        /**
         * Slots2StateReply availableBalance.
         * @member {number} availableBalance
         * @memberof mini.Slots2StateReply
         * @instance
         */
        Slots2StateReply.prototype.availableBalance = 0;

        /**
         * Slots2StateReply params.
         * @member {string} params
         * @memberof mini.Slots2StateReply
         * @instance
         */
        Slots2StateReply.prototype.params = "";

        /**
         * Slots2StateReply win.
         * @member {number} win
         * @memberof mini.Slots2StateReply
         * @instance
         */
        Slots2StateReply.prototype.win = 0;

        /**
         * Creates a new Slots2StateReply instance using the specified properties.
         * @function create
         * @memberof mini.Slots2StateReply
         * @static
         * @param {mini.ISlots2StateReply=} [properties] Properties to set
         * @returns {mini.Slots2StateReply} Slots2StateReply instance
         */
        Slots2StateReply.create = function create(properties) {
            return new Slots2StateReply(properties);
        };

        /**
         * Encodes the specified Slots2StateReply message. Does not implicitly {@link mini.Slots2StateReply.verify|verify} messages.
         * @function encode
         * @memberof mini.Slots2StateReply
         * @static
         * @param {mini.ISlots2StateReply} message Slots2StateReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots2StateReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.initMap != null && message.initMap.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.initMap.length; ++i)
                    writer.int32(message.initMap[i]);
                writer.ldelim();
            }
            if (message.availableBalance != null && Object.hasOwnProperty.call(message, "availableBalance"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.availableBalance);
            if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.params);
            if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.win);
            return writer;
        };

        /**
         * Encodes the specified Slots2StateReply message, length delimited. Does not implicitly {@link mini.Slots2StateReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.Slots2StateReply
         * @static
         * @param {mini.ISlots2StateReply} message Slots2StateReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots2StateReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Slots2StateReply message from the specified reader or buffer.
         * @function decode
         * @memberof mini.Slots2StateReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.Slots2StateReply} Slots2StateReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots2StateReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.Slots2StateReply();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.initMap && message.initMap.length))
                        message.initMap = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.initMap.push(reader.int32());
                    } else
                        message.initMap.push(reader.int32());
                    break;
                case 2:
                    message.availableBalance = reader.int32();
                    break;
                case 3:
                    message.params = reader.string();
                    break;
                case 4:
                    message.win = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Slots2StateReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.Slots2StateReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.Slots2StateReply} Slots2StateReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots2StateReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Slots2StateReply message.
         * @function verify
         * @memberof mini.Slots2StateReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Slots2StateReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.initMap != null && message.hasOwnProperty("initMap")) {
                if (!Array.isArray(message.initMap))
                    return "initMap: array expected";
                for (let i = 0; i < message.initMap.length; ++i)
                    if (!$util.isInteger(message.initMap[i]))
                        return "initMap: integer[] expected";
            }
            if (message.availableBalance != null && message.hasOwnProperty("availableBalance"))
                if (!$util.isInteger(message.availableBalance))
                    return "availableBalance: integer expected";
            if (message.params != null && message.hasOwnProperty("params"))
                if (!$util.isString(message.params))
                    return "params: string expected";
            if (message.win != null && message.hasOwnProperty("win"))
                if (!$util.isInteger(message.win))
                    return "win: integer expected";
            return null;
        };

        /**
         * Creates a Slots2StateReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.Slots2StateReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.Slots2StateReply} Slots2StateReply
         */
        Slots2StateReply.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.Slots2StateReply)
                return object;
            let message = new $root.mini.Slots2StateReply();
            if (object.initMap) {
                if (!Array.isArray(object.initMap))
                    throw TypeError(".mini.Slots2StateReply.initMap: array expected");
                message.initMap = [];
                for (let i = 0; i < object.initMap.length; ++i)
                    message.initMap[i] = object.initMap[i] | 0;
            }
            if (object.availableBalance != null)
                message.availableBalance = object.availableBalance | 0;
            if (object.params != null)
                message.params = String(object.params);
            if (object.win != null)
                message.win = object.win | 0;
            return message;
        };

        /**
         * Creates a plain object from a Slots2StateReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.Slots2StateReply
         * @static
         * @param {mini.Slots2StateReply} message Slots2StateReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Slots2StateReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.initMap = [];
            if (options.defaults) {
                object.availableBalance = 0;
                object.params = "";
                object.win = 0;
            }
            if (message.initMap && message.initMap.length) {
                object.initMap = [];
                for (let j = 0; j < message.initMap.length; ++j)
                    object.initMap[j] = message.initMap[j];
            }
            if (message.availableBalance != null && message.hasOwnProperty("availableBalance"))
                object.availableBalance = message.availableBalance;
            if (message.params != null && message.hasOwnProperty("params"))
                object.params = message.params;
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            return object;
        };

        /**
         * Converts this Slots2StateReply to JSON.
         * @function toJSON
         * @memberof mini.Slots2StateReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Slots2StateReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Slots2StateReply;
    })();

    mini.Slots2BetReq = (function() {

        /**
         * Properties of a Slots2BetReq.
         * @memberof mini
         * @interface ISlots2BetReq
         * @property {number|null} [betAmount] Slots2BetReq betAmount
         */

        /**
         * Constructs a new Slots2BetReq.
         * @memberof mini
         * @classdesc Represents a Slots2BetReq.
         * @implements ISlots2BetReq
         * @constructor
         * @param {mini.ISlots2BetReq=} [properties] Properties to set
         */
        function Slots2BetReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Slots2BetReq betAmount.
         * @member {number} betAmount
         * @memberof mini.Slots2BetReq
         * @instance
         */
        Slots2BetReq.prototype.betAmount = 0;

        /**
         * Creates a new Slots2BetReq instance using the specified properties.
         * @function create
         * @memberof mini.Slots2BetReq
         * @static
         * @param {mini.ISlots2BetReq=} [properties] Properties to set
         * @returns {mini.Slots2BetReq} Slots2BetReq instance
         */
        Slots2BetReq.create = function create(properties) {
            return new Slots2BetReq(properties);
        };

        /**
         * Encodes the specified Slots2BetReq message. Does not implicitly {@link mini.Slots2BetReq.verify|verify} messages.
         * @function encode
         * @memberof mini.Slots2BetReq
         * @static
         * @param {mini.ISlots2BetReq} message Slots2BetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots2BetReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.betAmount != null && Object.hasOwnProperty.call(message, "betAmount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.betAmount);
            return writer;
        };

        /**
         * Encodes the specified Slots2BetReq message, length delimited. Does not implicitly {@link mini.Slots2BetReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.Slots2BetReq
         * @static
         * @param {mini.ISlots2BetReq} message Slots2BetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots2BetReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Slots2BetReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.Slots2BetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.Slots2BetReq} Slots2BetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots2BetReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.Slots2BetReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    message.betAmount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Slots2BetReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.Slots2BetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.Slots2BetReq} Slots2BetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots2BetReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Slots2BetReq message.
         * @function verify
         * @memberof mini.Slots2BetReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Slots2BetReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.betAmount != null && message.hasOwnProperty("betAmount"))
                if (!$util.isInteger(message.betAmount))
                    return "betAmount: integer expected";
            return null;
        };

        /**
         * Creates a Slots2BetReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.Slots2BetReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.Slots2BetReq} Slots2BetReq
         */
        Slots2BetReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.Slots2BetReq)
                return object;
            let message = new $root.mini.Slots2BetReq();
            if (object.betAmount != null)
                message.betAmount = object.betAmount | 0;
            return message;
        };

        /**
         * Creates a plain object from a Slots2BetReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.Slots2BetReq
         * @static
         * @param {mini.Slots2BetReq} message Slots2BetReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Slots2BetReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.betAmount = 0;
            if (message.betAmount != null && message.hasOwnProperty("betAmount"))
                object.betAmount = message.betAmount;
            return object;
        };

        /**
         * Converts this Slots2BetReq to JSON.
         * @function toJSON
         * @memberof mini.Slots2BetReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Slots2BetReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Slots2BetReq;
    })();

    mini.Line = (function() {

        /**
         * Properties of a Line.
         * @memberof mini
         * @interface ILine
         * @property {Array.<number>|null} [idx] Line idx
         */

        /**
         * Constructs a new Line.
         * @memberof mini
         * @classdesc Represents a Line.
         * @implements ILine
         * @constructor
         * @param {mini.ILine=} [properties] Properties to set
         */
        function Line(properties) {
            this.idx = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Line idx.
         * @member {Array.<number>} idx
         * @memberof mini.Line
         * @instance
         */
        Line.prototype.idx = $util.emptyArray;

        /**
         * Creates a new Line instance using the specified properties.
         * @function create
         * @memberof mini.Line
         * @static
         * @param {mini.ILine=} [properties] Properties to set
         * @returns {mini.Line} Line instance
         */
        Line.create = function create(properties) {
            return new Line(properties);
        };

        /**
         * Encodes the specified Line message. Does not implicitly {@link mini.Line.verify|verify} messages.
         * @function encode
         * @memberof mini.Line
         * @static
         * @param {mini.ILine} message Line message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Line.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.idx != null && message.idx.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (let i = 0; i < message.idx.length; ++i)
                    writer.int32(message.idx[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified Line message, length delimited. Does not implicitly {@link mini.Line.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.Line
         * @static
         * @param {mini.ILine} message Line message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Line.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Line message from the specified reader or buffer.
         * @function decode
         * @memberof mini.Line
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.Line} Line
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Line.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.Line();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    if (!(message.idx && message.idx.length))
                        message.idx = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.idx.push(reader.int32());
                    } else
                        message.idx.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Line message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.Line
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.Line} Line
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Line.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Line message.
         * @function verify
         * @memberof mini.Line
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Line.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.idx != null && message.hasOwnProperty("idx")) {
                if (!Array.isArray(message.idx))
                    return "idx: array expected";
                for (let i = 0; i < message.idx.length; ++i)
                    if (!$util.isInteger(message.idx[i]))
                        return "idx: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a Line message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.Line
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.Line} Line
         */
        Line.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.Line)
                return object;
            let message = new $root.mini.Line();
            if (object.idx) {
                if (!Array.isArray(object.idx))
                    throw TypeError(".mini.Line.idx: array expected");
                message.idx = [];
                for (let i = 0; i < object.idx.length; ++i)
                    message.idx[i] = object.idx[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a Line message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.Line
         * @static
         * @param {mini.Line} message Line
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Line.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.idx = [];
            if (message.idx && message.idx.length) {
                object.idx = [];
                for (let j = 0; j < message.idx.length; ++j)
                    object.idx[j] = message.idx[j];
            }
            return object;
        };

        /**
         * Converts this Line to JSON.
         * @function toJSON
         * @memberof mini.Line
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Line.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Line;
    })();

    mini.Slots2Result = (function() {

        /**
         * Properties of a Slots2Result.
         * @memberof mini
         * @interface ISlots2Result
         * @property {Array.<number>|null} [resultMap] Slots2Result resultMap
         * @property {number|null} [winAmount] Slots2Result winAmount
         * @property {Array.<mini.ILine>|null} [lines] Slots2Result lines
         * @property {Array.<number>|null} [coins] Slots2Result coins
         * @property {boolean|null} [hasBigWin] Slots2Result hasBigWin
         */

        /**
         * Constructs a new Slots2Result.
         * @memberof mini
         * @classdesc Represents a Slots2Result.
         * @implements ISlots2Result
         * @constructor
         * @param {mini.ISlots2Result=} [properties] Properties to set
         */
        function Slots2Result(properties) {
            this.resultMap = [];
            this.lines = [];
            this.coins = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Slots2Result resultMap.
         * @member {Array.<number>} resultMap
         * @memberof mini.Slots2Result
         * @instance
         */
        Slots2Result.prototype.resultMap = $util.emptyArray;

        /**
         * Slots2Result winAmount.
         * @member {number} winAmount
         * @memberof mini.Slots2Result
         * @instance
         */
        Slots2Result.prototype.winAmount = 0;

        /**
         * Slots2Result lines.
         * @member {Array.<mini.ILine>} lines
         * @memberof mini.Slots2Result
         * @instance
         */
        Slots2Result.prototype.lines = $util.emptyArray;

        /**
         * Slots2Result coins.
         * @member {Array.<number>} coins
         * @memberof mini.Slots2Result
         * @instance
         */
        Slots2Result.prototype.coins = $util.emptyArray;

        /**
         * Slots2Result hasBigWin.
         * @member {boolean} hasBigWin
         * @memberof mini.Slots2Result
         * @instance
         */
        Slots2Result.prototype.hasBigWin = false;

        /**
         * Creates a new Slots2Result instance using the specified properties.
         * @function create
         * @memberof mini.Slots2Result
         * @static
         * @param {mini.ISlots2Result=} [properties] Properties to set
         * @returns {mini.Slots2Result} Slots2Result instance
         */
        Slots2Result.create = function create(properties) {
            return new Slots2Result(properties);
        };

        /**
         * Encodes the specified Slots2Result message. Does not implicitly {@link mini.Slots2Result.verify|verify} messages.
         * @function encode
         * @memberof mini.Slots2Result
         * @static
         * @param {mini.ISlots2Result} message Slots2Result message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots2Result.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resultMap != null && message.resultMap.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.resultMap.length; ++i)
                    writer.int32(message.resultMap[i]);
                writer.ldelim();
            }
            if (message.winAmount != null && Object.hasOwnProperty.call(message, "winAmount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.winAmount);
            if (message.lines != null && message.lines.length)
                for (let i = 0; i < message.lines.length; ++i)
                    $root.mini.Line.encode(message.lines[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.coins != null && message.coins.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.coins.length; ++i)
                    writer.int32(message.coins[i]);
                writer.ldelim();
            }
            if (message.hasBigWin != null && Object.hasOwnProperty.call(message, "hasBigWin"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.hasBigWin);
            return writer;
        };

        /**
         * Encodes the specified Slots2Result message, length delimited. Does not implicitly {@link mini.Slots2Result.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.Slots2Result
         * @static
         * @param {mini.ISlots2Result} message Slots2Result message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots2Result.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Slots2Result message from the specified reader or buffer.
         * @function decode
         * @memberof mini.Slots2Result
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.Slots2Result} Slots2Result
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots2Result.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.Slots2Result();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.resultMap && message.resultMap.length))
                        message.resultMap = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.resultMap.push(reader.int32());
                    } else
                        message.resultMap.push(reader.int32());
                    break;
                case 2:
                    message.winAmount = reader.int32();
                    break;
                case 3:
                    if (!(message.lines && message.lines.length))
                        message.lines = [];
                    message.lines.push($root.mini.Line.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.coins && message.coins.length))
                        message.coins = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.coins.push(reader.int32());
                    } else
                        message.coins.push(reader.int32());
                    break;
                case 5:
                    message.hasBigWin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Slots2Result message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.Slots2Result
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.Slots2Result} Slots2Result
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots2Result.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Slots2Result message.
         * @function verify
         * @memberof mini.Slots2Result
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Slots2Result.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resultMap != null && message.hasOwnProperty("resultMap")) {
                if (!Array.isArray(message.resultMap))
                    return "resultMap: array expected";
                for (let i = 0; i < message.resultMap.length; ++i)
                    if (!$util.isInteger(message.resultMap[i]))
                        return "resultMap: integer[] expected";
            }
            if (message.winAmount != null && message.hasOwnProperty("winAmount"))
                if (!$util.isInteger(message.winAmount))
                    return "winAmount: integer expected";
            if (message.lines != null && message.hasOwnProperty("lines")) {
                if (!Array.isArray(message.lines))
                    return "lines: array expected";
                for (let i = 0; i < message.lines.length; ++i) {
                    let error = $root.mini.Line.verify(message.lines[i]);
                    if (error)
                        return "lines." + error;
                }
            }
            if (message.coins != null && message.hasOwnProperty("coins")) {
                if (!Array.isArray(message.coins))
                    return "coins: array expected";
                for (let i = 0; i < message.coins.length; ++i)
                    if (!$util.isInteger(message.coins[i]))
                        return "coins: integer[] expected";
            }
            if (message.hasBigWin != null && message.hasOwnProperty("hasBigWin"))
                if (typeof message.hasBigWin !== "boolean")
                    return "hasBigWin: boolean expected";
            return null;
        };

        /**
         * Creates a Slots2Result message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.Slots2Result
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.Slots2Result} Slots2Result
         */
        Slots2Result.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.Slots2Result)
                return object;
            let message = new $root.mini.Slots2Result();
            if (object.resultMap) {
                if (!Array.isArray(object.resultMap))
                    throw TypeError(".mini.Slots2Result.resultMap: array expected");
                message.resultMap = [];
                for (let i = 0; i < object.resultMap.length; ++i)
                    message.resultMap[i] = object.resultMap[i] | 0;
            }
            if (object.winAmount != null)
                message.winAmount = object.winAmount | 0;
            if (object.lines) {
                if (!Array.isArray(object.lines))
                    throw TypeError(".mini.Slots2Result.lines: array expected");
                message.lines = [];
                for (let i = 0; i < object.lines.length; ++i) {
                    if (typeof object.lines[i] !== "object")
                        throw TypeError(".mini.Slots2Result.lines: object expected");
                    message.lines[i] = $root.mini.Line.fromObject(object.lines[i]);
                }
            }
            if (object.coins) {
                if (!Array.isArray(object.coins))
                    throw TypeError(".mini.Slots2Result.coins: array expected");
                message.coins = [];
                for (let i = 0; i < object.coins.length; ++i)
                    message.coins[i] = object.coins[i] | 0;
            }
            if (object.hasBigWin != null)
                message.hasBigWin = Boolean(object.hasBigWin);
            return message;
        };

        /**
         * Creates a plain object from a Slots2Result message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.Slots2Result
         * @static
         * @param {mini.Slots2Result} message Slots2Result
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Slots2Result.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.resultMap = [];
                object.lines = [];
                object.coins = [];
            }
            if (options.defaults) {
                object.winAmount = 0;
                object.hasBigWin = false;
            }
            if (message.resultMap && message.resultMap.length) {
                object.resultMap = [];
                for (let j = 0; j < message.resultMap.length; ++j)
                    object.resultMap[j] = message.resultMap[j];
            }
            if (message.winAmount != null && message.hasOwnProperty("winAmount"))
                object.winAmount = message.winAmount;
            if (message.lines && message.lines.length) {
                object.lines = [];
                for (let j = 0; j < message.lines.length; ++j)
                    object.lines[j] = $root.mini.Line.toObject(message.lines[j], options);
            }
            if (message.coins && message.coins.length) {
                object.coins = [];
                for (let j = 0; j < message.coins.length; ++j)
                    object.coins[j] = message.coins[j];
            }
            if (message.hasBigWin != null && message.hasOwnProperty("hasBigWin"))
                object.hasBigWin = message.hasBigWin;
            return object;
        };

        /**
         * Converts this Slots2Result to JSON.
         * @function toJSON
         * @memberof mini.Slots2Result
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Slots2Result.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Slots2Result;
    })();

    mini.Slots2BetReply = (function() {

        /**
         * Properties of a Slots2BetReply.
         * @memberof mini
         * @interface ISlots2BetReply
         * @property {Array.<mini.ISlots2Result>|null} [results] Slots2BetReply results
         * @property {boolean|null} [hasBigWin] Slots2BetReply hasBigWin
         */

        /**
         * Constructs a new Slots2BetReply.
         * @memberof mini
         * @classdesc Represents a Slots2BetReply.
         * @implements ISlots2BetReply
         * @constructor
         * @param {mini.ISlots2BetReply=} [properties] Properties to set
         */
        function Slots2BetReply(properties) {
            this.results = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Slots2BetReply results.
         * @member {Array.<mini.ISlots2Result>} results
         * @memberof mini.Slots2BetReply
         * @instance
         */
        Slots2BetReply.prototype.results = $util.emptyArray;

        /**
         * Slots2BetReply hasBigWin.
         * @member {boolean} hasBigWin
         * @memberof mini.Slots2BetReply
         * @instance
         */
        Slots2BetReply.prototype.hasBigWin = false;

        /**
         * Creates a new Slots2BetReply instance using the specified properties.
         * @function create
         * @memberof mini.Slots2BetReply
         * @static
         * @param {mini.ISlots2BetReply=} [properties] Properties to set
         * @returns {mini.Slots2BetReply} Slots2BetReply instance
         */
        Slots2BetReply.create = function create(properties) {
            return new Slots2BetReply(properties);
        };

        /**
         * Encodes the specified Slots2BetReply message. Does not implicitly {@link mini.Slots2BetReply.verify|verify} messages.
         * @function encode
         * @memberof mini.Slots2BetReply
         * @static
         * @param {mini.ISlots2BetReply} message Slots2BetReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots2BetReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.results != null && message.results.length)
                for (let i = 0; i < message.results.length; ++i)
                    $root.mini.Slots2Result.encode(message.results[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.hasBigWin != null && Object.hasOwnProperty.call(message, "hasBigWin"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hasBigWin);
            return writer;
        };

        /**
         * Encodes the specified Slots2BetReply message, length delimited. Does not implicitly {@link mini.Slots2BetReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.Slots2BetReply
         * @static
         * @param {mini.ISlots2BetReply} message Slots2BetReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots2BetReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Slots2BetReply message from the specified reader or buffer.
         * @function decode
         * @memberof mini.Slots2BetReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.Slots2BetReply} Slots2BetReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots2BetReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.Slots2BetReply();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.results && message.results.length))
                        message.results = [];
                    message.results.push($root.mini.Slots2Result.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.hasBigWin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Slots2BetReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.Slots2BetReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.Slots2BetReply} Slots2BetReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots2BetReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Slots2BetReply message.
         * @function verify
         * @memberof mini.Slots2BetReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Slots2BetReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.results != null && message.hasOwnProperty("results")) {
                if (!Array.isArray(message.results))
                    return "results: array expected";
                for (let i = 0; i < message.results.length; ++i) {
                    let error = $root.mini.Slots2Result.verify(message.results[i]);
                    if (error)
                        return "results." + error;
                }
            }
            if (message.hasBigWin != null && message.hasOwnProperty("hasBigWin"))
                if (typeof message.hasBigWin !== "boolean")
                    return "hasBigWin: boolean expected";
            return null;
        };

        /**
         * Creates a Slots2BetReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.Slots2BetReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.Slots2BetReply} Slots2BetReply
         */
        Slots2BetReply.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.Slots2BetReply)
                return object;
            let message = new $root.mini.Slots2BetReply();
            if (object.results) {
                if (!Array.isArray(object.results))
                    throw TypeError(".mini.Slots2BetReply.results: array expected");
                message.results = [];
                for (let i = 0; i < object.results.length; ++i) {
                    if (typeof object.results[i] !== "object")
                        throw TypeError(".mini.Slots2BetReply.results: object expected");
                    message.results[i] = $root.mini.Slots2Result.fromObject(object.results[i]);
                }
            }
            if (object.hasBigWin != null)
                message.hasBigWin = Boolean(object.hasBigWin);
            return message;
        };

        /**
         * Creates a plain object from a Slots2BetReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.Slots2BetReply
         * @static
         * @param {mini.Slots2BetReply} message Slots2BetReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Slots2BetReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.results = [];
            if (options.defaults)
                object.hasBigWin = false;
            if (message.results && message.results.length) {
                object.results = [];
                for (let j = 0; j < message.results.length; ++j)
                    object.results[j] = $root.mini.Slots2Result.toObject(message.results[j], options);
            }
            if (message.hasBigWin != null && message.hasOwnProperty("hasBigWin"))
                object.hasBigWin = message.hasBigWin;
            return object;
        };

        /**
         * Converts this Slots2BetReply to JSON.
         * @function toJSON
         * @memberof mini.Slots2BetReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Slots2BetReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Slots2BetReply;
    })();

    mini.Slots3StateReply = (function() {

        /**
         * Properties of a Slots3StateReply.
         * @memberof mini
         * @interface ISlots3StateReply
         * @property {Array.<number>|null} [initMap] Slots3StateReply initMap
         * @property {string|null} [params] Slots3StateReply params
         * @property {string|null} [awardLines] Slots3StateReply awardLines
         * @property {number|null} [availableBalance] Slots3StateReply availableBalance
         */

        /**
         * Constructs a new Slots3StateReply.
         * @memberof mini
         * @classdesc Represents a Slots3StateReply.
         * @implements ISlots3StateReply
         * @constructor
         * @param {mini.ISlots3StateReply=} [properties] Properties to set
         */
        function Slots3StateReply(properties) {
            this.initMap = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Slots3StateReply initMap.
         * @member {Array.<number>} initMap
         * @memberof mini.Slots3StateReply
         * @instance
         */
        Slots3StateReply.prototype.initMap = $util.emptyArray;

        /**
         * Slots3StateReply params.
         * @member {string} params
         * @memberof mini.Slots3StateReply
         * @instance
         */
        Slots3StateReply.prototype.params = "";

        /**
         * Slots3StateReply awardLines.
         * @member {string} awardLines
         * @memberof mini.Slots3StateReply
         * @instance
         */
        Slots3StateReply.prototype.awardLines = "";

        /**
         * Slots3StateReply availableBalance.
         * @member {number} availableBalance
         * @memberof mini.Slots3StateReply
         * @instance
         */
        Slots3StateReply.prototype.availableBalance = 0;

        /**
         * Creates a new Slots3StateReply instance using the specified properties.
         * @function create
         * @memberof mini.Slots3StateReply
         * @static
         * @param {mini.ISlots3StateReply=} [properties] Properties to set
         * @returns {mini.Slots3StateReply} Slots3StateReply instance
         */
        Slots3StateReply.create = function create(properties) {
            return new Slots3StateReply(properties);
        };

        /**
         * Encodes the specified Slots3StateReply message. Does not implicitly {@link mini.Slots3StateReply.verify|verify} messages.
         * @function encode
         * @memberof mini.Slots3StateReply
         * @static
         * @param {mini.ISlots3StateReply} message Slots3StateReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots3StateReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.initMap != null && message.initMap.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.initMap.length; ++i)
                    writer.int32(message.initMap[i]);
                writer.ldelim();
            }
            if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.params);
            if (message.awardLines != null && Object.hasOwnProperty.call(message, "awardLines"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.awardLines);
            if (message.availableBalance != null && Object.hasOwnProperty.call(message, "availableBalance"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.availableBalance);
            return writer;
        };

        /**
         * Encodes the specified Slots3StateReply message, length delimited. Does not implicitly {@link mini.Slots3StateReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.Slots3StateReply
         * @static
         * @param {mini.ISlots3StateReply} message Slots3StateReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots3StateReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Slots3StateReply message from the specified reader or buffer.
         * @function decode
         * @memberof mini.Slots3StateReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.Slots3StateReply} Slots3StateReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots3StateReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.Slots3StateReply();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.initMap && message.initMap.length))
                        message.initMap = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.initMap.push(reader.int32());
                    } else
                        message.initMap.push(reader.int32());
                    break;
                case 2:
                    message.params = reader.string();
                    break;
                case 3:
                    message.awardLines = reader.string();
                    break;
                case 4:
                    message.availableBalance = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Slots3StateReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.Slots3StateReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.Slots3StateReply} Slots3StateReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots3StateReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Slots3StateReply message.
         * @function verify
         * @memberof mini.Slots3StateReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Slots3StateReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.initMap != null && message.hasOwnProperty("initMap")) {
                if (!Array.isArray(message.initMap))
                    return "initMap: array expected";
                for (let i = 0; i < message.initMap.length; ++i)
                    if (!$util.isInteger(message.initMap[i]))
                        return "initMap: integer[] expected";
            }
            if (message.params != null && message.hasOwnProperty("params"))
                if (!$util.isString(message.params))
                    return "params: string expected";
            if (message.awardLines != null && message.hasOwnProperty("awardLines"))
                if (!$util.isString(message.awardLines))
                    return "awardLines: string expected";
            if (message.availableBalance != null && message.hasOwnProperty("availableBalance"))
                if (!$util.isInteger(message.availableBalance))
                    return "availableBalance: integer expected";
            return null;
        };

        /**
         * Creates a Slots3StateReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.Slots3StateReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.Slots3StateReply} Slots3StateReply
         */
        Slots3StateReply.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.Slots3StateReply)
                return object;
            let message = new $root.mini.Slots3StateReply();
            if (object.initMap) {
                if (!Array.isArray(object.initMap))
                    throw TypeError(".mini.Slots3StateReply.initMap: array expected");
                message.initMap = [];
                for (let i = 0; i < object.initMap.length; ++i)
                    message.initMap[i] = object.initMap[i] | 0;
            }
            if (object.params != null)
                message.params = String(object.params);
            if (object.awardLines != null)
                message.awardLines = String(object.awardLines);
            if (object.availableBalance != null)
                message.availableBalance = object.availableBalance | 0;
            return message;
        };

        /**
         * Creates a plain object from a Slots3StateReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.Slots3StateReply
         * @static
         * @param {mini.Slots3StateReply} message Slots3StateReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Slots3StateReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.initMap = [];
            if (options.defaults) {
                object.params = "";
                object.awardLines = "";
                object.availableBalance = 0;
            }
            if (message.initMap && message.initMap.length) {
                object.initMap = [];
                for (let j = 0; j < message.initMap.length; ++j)
                    object.initMap[j] = message.initMap[j];
            }
            if (message.params != null && message.hasOwnProperty("params"))
                object.params = message.params;
            if (message.awardLines != null && message.hasOwnProperty("awardLines"))
                object.awardLines = message.awardLines;
            if (message.availableBalance != null && message.hasOwnProperty("availableBalance"))
                object.availableBalance = message.availableBalance;
            return object;
        };

        /**
         * Converts this Slots3StateReply to JSON.
         * @function toJSON
         * @memberof mini.Slots3StateReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Slots3StateReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Slots3StateReply;
    })();

    mini.Slots3BetReq = (function() {

        /**
         * Properties of a Slots3BetReq.
         * @memberof mini
         * @interface ISlots3BetReq
         * @property {number|Long|null} [betAmount] Slots3BetReq betAmount
         */

        /**
         * Constructs a new Slots3BetReq.
         * @memberof mini
         * @classdesc Represents a Slots3BetReq.
         * @implements ISlots3BetReq
         * @constructor
         * @param {mini.ISlots3BetReq=} [properties] Properties to set
         */
        function Slots3BetReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Slots3BetReq betAmount.
         * @member {number|Long} betAmount
         * @memberof mini.Slots3BetReq
         * @instance
         */
        Slots3BetReq.prototype.betAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Slots3BetReq instance using the specified properties.
         * @function create
         * @memberof mini.Slots3BetReq
         * @static
         * @param {mini.ISlots3BetReq=} [properties] Properties to set
         * @returns {mini.Slots3BetReq} Slots3BetReq instance
         */
        Slots3BetReq.create = function create(properties) {
            return new Slots3BetReq(properties);
        };

        /**
         * Encodes the specified Slots3BetReq message. Does not implicitly {@link mini.Slots3BetReq.verify|verify} messages.
         * @function encode
         * @memberof mini.Slots3BetReq
         * @static
         * @param {mini.ISlots3BetReq} message Slots3BetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots3BetReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.betAmount != null && Object.hasOwnProperty.call(message, "betAmount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.betAmount);
            return writer;
        };

        /**
         * Encodes the specified Slots3BetReq message, length delimited. Does not implicitly {@link mini.Slots3BetReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.Slots3BetReq
         * @static
         * @param {mini.ISlots3BetReq} message Slots3BetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots3BetReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Slots3BetReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.Slots3BetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.Slots3BetReq} Slots3BetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots3BetReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.Slots3BetReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.betAmount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Slots3BetReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.Slots3BetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.Slots3BetReq} Slots3BetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots3BetReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Slots3BetReq message.
         * @function verify
         * @memberof mini.Slots3BetReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Slots3BetReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.betAmount != null && message.hasOwnProperty("betAmount"))
                if (!$util.isInteger(message.betAmount) && !(message.betAmount && $util.isInteger(message.betAmount.low) && $util.isInteger(message.betAmount.high)))
                    return "betAmount: integer|Long expected";
            return null;
        };

        /**
         * Creates a Slots3BetReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.Slots3BetReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.Slots3BetReq} Slots3BetReq
         */
        Slots3BetReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.Slots3BetReq)
                return object;
            let message = new $root.mini.Slots3BetReq();
            if (object.betAmount != null)
                if ($util.Long)
                    (message.betAmount = $util.Long.fromValue(object.betAmount)).unsigned = false;
                else if (typeof object.betAmount === "string")
                    message.betAmount = parseInt(object.betAmount, 10);
                else if (typeof object.betAmount === "number")
                    message.betAmount = object.betAmount;
                else if (typeof object.betAmount === "object")
                    message.betAmount = new $util.LongBits(object.betAmount.low >>> 0, object.betAmount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Slots3BetReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.Slots3BetReq
         * @static
         * @param {mini.Slots3BetReq} message Slots3BetReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Slots3BetReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.betAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.betAmount = options.longs === String ? "0" : 0;
            if (message.betAmount != null && message.hasOwnProperty("betAmount"))
                if (typeof message.betAmount === "number")
                    object.betAmount = options.longs === String ? String(message.betAmount) : message.betAmount;
                else
                    object.betAmount = options.longs === String ? $util.Long.prototype.toString.call(message.betAmount) : options.longs === Number ? new $util.LongBits(message.betAmount.low >>> 0, message.betAmount.high >>> 0).toNumber() : message.betAmount;
            return object;
        };

        /**
         * Converts this Slots3BetReq to JSON.
         * @function toJSON
         * @memberof mini.Slots3BetReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Slots3BetReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Slots3BetReq;
    })();

    mini.Line3 = (function() {

        /**
         * Properties of a Line3.
         * @memberof mini
         * @interface ILine3
         * @property {number|null} [awardIdx] Line3 awardIdx
         * @property {number|null} [awardCount] Line3 awardCount
         */

        /**
         * Constructs a new Line3.
         * @memberof mini
         * @classdesc Represents a Line3.
         * @implements ILine3
         * @constructor
         * @param {mini.ILine3=} [properties] Properties to set
         */
        function Line3(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Line3 awardIdx.
         * @member {number} awardIdx
         * @memberof mini.Line3
         * @instance
         */
        Line3.prototype.awardIdx = 0;

        /**
         * Line3 awardCount.
         * @member {number} awardCount
         * @memberof mini.Line3
         * @instance
         */
        Line3.prototype.awardCount = 0;

        /**
         * Creates a new Line3 instance using the specified properties.
         * @function create
         * @memberof mini.Line3
         * @static
         * @param {mini.ILine3=} [properties] Properties to set
         * @returns {mini.Line3} Line3 instance
         */
        Line3.create = function create(properties) {
            return new Line3(properties);
        };

        /**
         * Encodes the specified Line3 message. Does not implicitly {@link mini.Line3.verify|verify} messages.
         * @function encode
         * @memberof mini.Line3
         * @static
         * @param {mini.ILine3} message Line3 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Line3.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.awardIdx != null && Object.hasOwnProperty.call(message, "awardIdx"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.awardIdx);
            if (message.awardCount != null && Object.hasOwnProperty.call(message, "awardCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.awardCount);
            return writer;
        };

        /**
         * Encodes the specified Line3 message, length delimited. Does not implicitly {@link mini.Line3.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.Line3
         * @static
         * @param {mini.ILine3} message Line3 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Line3.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Line3 message from the specified reader or buffer.
         * @function decode
         * @memberof mini.Line3
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.Line3} Line3
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Line3.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.Line3();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.awardIdx = reader.int32();
                    break;
                case 2:
                    message.awardCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Line3 message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.Line3
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.Line3} Line3
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Line3.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Line3 message.
         * @function verify
         * @memberof mini.Line3
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Line3.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.awardIdx != null && message.hasOwnProperty("awardIdx"))
                if (!$util.isInteger(message.awardIdx))
                    return "awardIdx: integer expected";
            if (message.awardCount != null && message.hasOwnProperty("awardCount"))
                if (!$util.isInteger(message.awardCount))
                    return "awardCount: integer expected";
            return null;
        };

        /**
         * Creates a Line3 message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.Line3
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.Line3} Line3
         */
        Line3.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.Line3)
                return object;
            let message = new $root.mini.Line3();
            if (object.awardIdx != null)
                message.awardIdx = object.awardIdx | 0;
            if (object.awardCount != null)
                message.awardCount = object.awardCount | 0;
            return message;
        };

        /**
         * Creates a plain object from a Line3 message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.Line3
         * @static
         * @param {mini.Line3} message Line3
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Line3.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.awardIdx = 0;
                object.awardCount = 0;
            }
            if (message.awardIdx != null && message.hasOwnProperty("awardIdx"))
                object.awardIdx = message.awardIdx;
            if (message.awardCount != null && message.hasOwnProperty("awardCount"))
                object.awardCount = message.awardCount;
            return object;
        };

        /**
         * Converts this Line3 to JSON.
         * @function toJSON
         * @memberof mini.Line3
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Line3.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Line3;
    })();

    mini.Slots3Result = (function() {

        /**
         * Properties of a Slots3Result.
         * @memberof mini
         * @interface ISlots3Result
         * @property {Array.<number>|null} [resultMap] Slots3Result resultMap
         * @property {Array.<mini.ILine3>|null} [lines] Slots3Result lines
         * @property {number|null} [payout] Slots3Result payout
         * @property {boolean|null} [hasBigWin] Slots3Result hasBigWin
         */

        /**
         * Constructs a new Slots3Result.
         * @memberof mini
         * @classdesc Represents a Slots3Result.
         * @implements ISlots3Result
         * @constructor
         * @param {mini.ISlots3Result=} [properties] Properties to set
         */
        function Slots3Result(properties) {
            this.resultMap = [];
            this.lines = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Slots3Result resultMap.
         * @member {Array.<number>} resultMap
         * @memberof mini.Slots3Result
         * @instance
         */
        Slots3Result.prototype.resultMap = $util.emptyArray;

        /**
         * Slots3Result lines.
         * @member {Array.<mini.ILine3>} lines
         * @memberof mini.Slots3Result
         * @instance
         */
        Slots3Result.prototype.lines = $util.emptyArray;

        /**
         * Slots3Result payout.
         * @member {number} payout
         * @memberof mini.Slots3Result
         * @instance
         */
        Slots3Result.prototype.payout = 0;

        /**
         * Slots3Result hasBigWin.
         * @member {boolean} hasBigWin
         * @memberof mini.Slots3Result
         * @instance
         */
        Slots3Result.prototype.hasBigWin = false;

        /**
         * Creates a new Slots3Result instance using the specified properties.
         * @function create
         * @memberof mini.Slots3Result
         * @static
         * @param {mini.ISlots3Result=} [properties] Properties to set
         * @returns {mini.Slots3Result} Slots3Result instance
         */
        Slots3Result.create = function create(properties) {
            return new Slots3Result(properties);
        };

        /**
         * Encodes the specified Slots3Result message. Does not implicitly {@link mini.Slots3Result.verify|verify} messages.
         * @function encode
         * @memberof mini.Slots3Result
         * @static
         * @param {mini.ISlots3Result} message Slots3Result message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots3Result.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resultMap != null && message.resultMap.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.resultMap.length; ++i)
                    writer.int32(message.resultMap[i]);
                writer.ldelim();
            }
            if (message.lines != null && message.lines.length)
                for (let i = 0; i < message.lines.length; ++i)
                    $root.mini.Line3.encode(message.lines[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.payout != null && Object.hasOwnProperty.call(message, "payout"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.payout);
            if (message.hasBigWin != null && Object.hasOwnProperty.call(message, "hasBigWin"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.hasBigWin);
            return writer;
        };

        /**
         * Encodes the specified Slots3Result message, length delimited. Does not implicitly {@link mini.Slots3Result.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.Slots3Result
         * @static
         * @param {mini.ISlots3Result} message Slots3Result message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots3Result.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Slots3Result message from the specified reader or buffer.
         * @function decode
         * @memberof mini.Slots3Result
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.Slots3Result} Slots3Result
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots3Result.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.Slots3Result();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.resultMap && message.resultMap.length))
                        message.resultMap = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.resultMap.push(reader.int32());
                    } else
                        message.resultMap.push(reader.int32());
                    break;
                case 2:
                    if (!(message.lines && message.lines.length))
                        message.lines = [];
                    message.lines.push($root.mini.Line3.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.payout = reader.int32();
                    break;
                case 4:
                    message.hasBigWin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Slots3Result message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.Slots3Result
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.Slots3Result} Slots3Result
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots3Result.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Slots3Result message.
         * @function verify
         * @memberof mini.Slots3Result
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Slots3Result.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resultMap != null && message.hasOwnProperty("resultMap")) {
                if (!Array.isArray(message.resultMap))
                    return "resultMap: array expected";
                for (let i = 0; i < message.resultMap.length; ++i)
                    if (!$util.isInteger(message.resultMap[i]))
                        return "resultMap: integer[] expected";
            }
            if (message.lines != null && message.hasOwnProperty("lines")) {
                if (!Array.isArray(message.lines))
                    return "lines: array expected";
                for (let i = 0; i < message.lines.length; ++i) {
                    let error = $root.mini.Line3.verify(message.lines[i]);
                    if (error)
                        return "lines." + error;
                }
            }
            if (message.payout != null && message.hasOwnProperty("payout"))
                if (!$util.isInteger(message.payout))
                    return "payout: integer expected";
            if (message.hasBigWin != null && message.hasOwnProperty("hasBigWin"))
                if (typeof message.hasBigWin !== "boolean")
                    return "hasBigWin: boolean expected";
            return null;
        };

        /**
         * Creates a Slots3Result message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.Slots3Result
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.Slots3Result} Slots3Result
         */
        Slots3Result.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.Slots3Result)
                return object;
            let message = new $root.mini.Slots3Result();
            if (object.resultMap) {
                if (!Array.isArray(object.resultMap))
                    throw TypeError(".mini.Slots3Result.resultMap: array expected");
                message.resultMap = [];
                for (let i = 0; i < object.resultMap.length; ++i)
                    message.resultMap[i] = object.resultMap[i] | 0;
            }
            if (object.lines) {
                if (!Array.isArray(object.lines))
                    throw TypeError(".mini.Slots3Result.lines: array expected");
                message.lines = [];
                for (let i = 0; i < object.lines.length; ++i) {
                    if (typeof object.lines[i] !== "object")
                        throw TypeError(".mini.Slots3Result.lines: object expected");
                    message.lines[i] = $root.mini.Line3.fromObject(object.lines[i]);
                }
            }
            if (object.payout != null)
                message.payout = object.payout | 0;
            if (object.hasBigWin != null)
                message.hasBigWin = Boolean(object.hasBigWin);
            return message;
        };

        /**
         * Creates a plain object from a Slots3Result message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.Slots3Result
         * @static
         * @param {mini.Slots3Result} message Slots3Result
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Slots3Result.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.resultMap = [];
                object.lines = [];
            }
            if (options.defaults) {
                object.payout = 0;
                object.hasBigWin = false;
            }
            if (message.resultMap && message.resultMap.length) {
                object.resultMap = [];
                for (let j = 0; j < message.resultMap.length; ++j)
                    object.resultMap[j] = message.resultMap[j];
            }
            if (message.lines && message.lines.length) {
                object.lines = [];
                for (let j = 0; j < message.lines.length; ++j)
                    object.lines[j] = $root.mini.Line3.toObject(message.lines[j], options);
            }
            if (message.payout != null && message.hasOwnProperty("payout"))
                object.payout = message.payout;
            if (message.hasBigWin != null && message.hasOwnProperty("hasBigWin"))
                object.hasBigWin = message.hasBigWin;
            return object;
        };

        /**
         * Converts this Slots3Result to JSON.
         * @function toJSON
         * @memberof mini.Slots3Result
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Slots3Result.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Slots3Result;
    })();

    mini.Slots3BetReply = (function() {

        /**
         * Properties of a Slots3BetReply.
         * @memberof mini
         * @interface ISlots3BetReply
         * @property {Array.<mini.ISlots3Result>|null} [results] Slots3BetReply results
         * @property {boolean|null} [hasBigWin] Slots3BetReply hasBigWin
         */

        /**
         * Constructs a new Slots3BetReply.
         * @memberof mini
         * @classdesc Represents a Slots3BetReply.
         * @implements ISlots3BetReply
         * @constructor
         * @param {mini.ISlots3BetReply=} [properties] Properties to set
         */
        function Slots3BetReply(properties) {
            this.results = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Slots3BetReply results.
         * @member {Array.<mini.ISlots3Result>} results
         * @memberof mini.Slots3BetReply
         * @instance
         */
        Slots3BetReply.prototype.results = $util.emptyArray;

        /**
         * Slots3BetReply hasBigWin.
         * @member {boolean} hasBigWin
         * @memberof mini.Slots3BetReply
         * @instance
         */
        Slots3BetReply.prototype.hasBigWin = false;

        /**
         * Creates a new Slots3BetReply instance using the specified properties.
         * @function create
         * @memberof mini.Slots3BetReply
         * @static
         * @param {mini.ISlots3BetReply=} [properties] Properties to set
         * @returns {mini.Slots3BetReply} Slots3BetReply instance
         */
        Slots3BetReply.create = function create(properties) {
            return new Slots3BetReply(properties);
        };

        /**
         * Encodes the specified Slots3BetReply message. Does not implicitly {@link mini.Slots3BetReply.verify|verify} messages.
         * @function encode
         * @memberof mini.Slots3BetReply
         * @static
         * @param {mini.ISlots3BetReply} message Slots3BetReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots3BetReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.results != null && message.results.length)
                for (let i = 0; i < message.results.length; ++i)
                    $root.mini.Slots3Result.encode(message.results[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.hasBigWin != null && Object.hasOwnProperty.call(message, "hasBigWin"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hasBigWin);
            return writer;
        };

        /**
         * Encodes the specified Slots3BetReply message, length delimited. Does not implicitly {@link mini.Slots3BetReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.Slots3BetReply
         * @static
         * @param {mini.ISlots3BetReply} message Slots3BetReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slots3BetReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Slots3BetReply message from the specified reader or buffer.
         * @function decode
         * @memberof mini.Slots3BetReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.Slots3BetReply} Slots3BetReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots3BetReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.Slots3BetReply();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.results && message.results.length))
                        message.results = [];
                    message.results.push($root.mini.Slots3Result.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.hasBigWin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Slots3BetReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.Slots3BetReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.Slots3BetReply} Slots3BetReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slots3BetReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Slots3BetReply message.
         * @function verify
         * @memberof mini.Slots3BetReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Slots3BetReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.results != null && message.hasOwnProperty("results")) {
                if (!Array.isArray(message.results))
                    return "results: array expected";
                for (let i = 0; i < message.results.length; ++i) {
                    let error = $root.mini.Slots3Result.verify(message.results[i]);
                    if (error)
                        return "results." + error;
                }
            }
            if (message.hasBigWin != null && message.hasOwnProperty("hasBigWin"))
                if (typeof message.hasBigWin !== "boolean")
                    return "hasBigWin: boolean expected";
            return null;
        };

        /**
         * Creates a Slots3BetReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.Slots3BetReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.Slots3BetReply} Slots3BetReply
         */
        Slots3BetReply.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.Slots3BetReply)
                return object;
            let message = new $root.mini.Slots3BetReply();
            if (object.results) {
                if (!Array.isArray(object.results))
                    throw TypeError(".mini.Slots3BetReply.results: array expected");
                message.results = [];
                for (let i = 0; i < object.results.length; ++i) {
                    if (typeof object.results[i] !== "object")
                        throw TypeError(".mini.Slots3BetReply.results: object expected");
                    message.results[i] = $root.mini.Slots3Result.fromObject(object.results[i]);
                }
            }
            if (object.hasBigWin != null)
                message.hasBigWin = Boolean(object.hasBigWin);
            return message;
        };

        /**
         * Creates a plain object from a Slots3BetReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.Slots3BetReply
         * @static
         * @param {mini.Slots3BetReply} message Slots3BetReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Slots3BetReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.results = [];
            if (options.defaults)
                object.hasBigWin = false;
            if (message.results && message.results.length) {
                object.results = [];
                for (let j = 0; j < message.results.length; ++j)
                    object.results[j] = $root.mini.Slots3Result.toObject(message.results[j], options);
            }
            if (message.hasBigWin != null && message.hasOwnProperty("hasBigWin"))
                object.hasBigWin = message.hasBigWin;
            return object;
        };

        /**
         * Converts this Slots3BetReply to JSON.
         * @function toJSON
         * @memberof mini.Slots3BetReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Slots3BetReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Slots3BetReply;
    })();

    mini.GameTestReq = (function() {

        /**
         * Properties of a GameTestReq.
         * @memberof mini
         * @interface IGameTestReq
         * @property {string|null} [name] GameTestReq name
         */

        /**
         * Constructs a new GameTestReq.
         * @memberof mini
         * @classdesc Represents a GameTestReq.
         * @implements IGameTestReq
         * @constructor
         * @param {mini.IGameTestReq=} [properties] Properties to set
         */
        function GameTestReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GameTestReq name.
         * @member {string} name
         * @memberof mini.GameTestReq
         * @instance
         */
        GameTestReq.prototype.name = "";

        /**
         * Creates a new GameTestReq instance using the specified properties.
         * @function create
         * @memberof mini.GameTestReq
         * @static
         * @param {mini.IGameTestReq=} [properties] Properties to set
         * @returns {mini.GameTestReq} GameTestReq instance
         */
        GameTestReq.create = function create(properties) {
            return new GameTestReq(properties);
        };

        /**
         * Encodes the specified GameTestReq message. Does not implicitly {@link mini.GameTestReq.verify|verify} messages.
         * @function encode
         * @memberof mini.GameTestReq
         * @static
         * @param {mini.IGameTestReq} message GameTestReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameTestReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified GameTestReq message, length delimited. Does not implicitly {@link mini.GameTestReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.GameTestReq
         * @static
         * @param {mini.IGameTestReq} message GameTestReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameTestReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GameTestReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.GameTestReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.GameTestReq} GameTestReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameTestReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.GameTestReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GameTestReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.GameTestReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.GameTestReq} GameTestReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameTestReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GameTestReq message.
         * @function verify
         * @memberof mini.GameTestReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GameTestReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a GameTestReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.GameTestReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.GameTestReq} GameTestReq
         */
        GameTestReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.GameTestReq)
                return object;
            let message = new $root.mini.GameTestReq();
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a GameTestReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.GameTestReq
         * @static
         * @param {mini.GameTestReq} message GameTestReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GameTestReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.name = "";
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this GameTestReq to JSON.
         * @function toJSON
         * @memberof mini.GameTestReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GameTestReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GameTestReq;
    })();

    mini.GameTestResp = (function() {

        /**
         * Properties of a GameTestResp.
         * @memberof mini
         * @interface IGameTestResp
         * @property {number|null} [state] GameTestResp state
         */

        /**
         * Constructs a new GameTestResp.
         * @memberof mini
         * @classdesc Represents a GameTestResp.
         * @implements IGameTestResp
         * @constructor
         * @param {mini.IGameTestResp=} [properties] Properties to set
         */
        function GameTestResp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GameTestResp state.
         * @member {number} state
         * @memberof mini.GameTestResp
         * @instance
         */
        GameTestResp.prototype.state = 0;

        /**
         * Creates a new GameTestResp instance using the specified properties.
         * @function create
         * @memberof mini.GameTestResp
         * @static
         * @param {mini.IGameTestResp=} [properties] Properties to set
         * @returns {mini.GameTestResp} GameTestResp instance
         */
        GameTestResp.create = function create(properties) {
            return new GameTestResp(properties);
        };

        /**
         * Encodes the specified GameTestResp message. Does not implicitly {@link mini.GameTestResp.verify|verify} messages.
         * @function encode
         * @memberof mini.GameTestResp
         * @static
         * @param {mini.IGameTestResp} message GameTestResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameTestResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
            return writer;
        };

        /**
         * Encodes the specified GameTestResp message, length delimited. Does not implicitly {@link mini.GameTestResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.GameTestResp
         * @static
         * @param {mini.IGameTestResp} message GameTestResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameTestResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GameTestResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.GameTestResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.GameTestResp} GameTestResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameTestResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.GameTestResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.state = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GameTestResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.GameTestResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.GameTestResp} GameTestResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameTestResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GameTestResp message.
         * @function verify
         * @memberof mini.GameTestResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GameTestResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            return null;
        };

        /**
         * Creates a GameTestResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.GameTestResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.GameTestResp} GameTestResp
         */
        GameTestResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.GameTestResp)
                return object;
            let message = new $root.mini.GameTestResp();
            if (object.state != null)
                message.state = object.state | 0;
            return message;
        };

        /**
         * Creates a plain object from a GameTestResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.GameTestResp
         * @static
         * @param {mini.GameTestResp} message GameTestResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GameTestResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.state = 0;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            return object;
        };

        /**
         * Converts this GameTestResp to JSON.
         * @function toJSON
         * @memberof mini.GameTestResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GameTestResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GameTestResp;
    })();

    /**
     * DEADLINE_TYPE_SJB enum.
     * @name mini.DEADLINE_TYPE_SJB
     * @enum {number}
     * @property {number} DT_NONE=0 DT_NONE value
     * @property {number} REF_BUF=1 REF_BUF value
     */
    mini.DEADLINE_TYPE_SJB = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DT_NONE"] = 0;
        values[valuesById[1] = "REF_BUF"] = 1;
        return values;
    })();

    mini.ProtoSJBGameStartReq = (function() {

        /**
         * Properties of a ProtoSJBGameStartReq.
         * @memberof mini
         * @interface IProtoSJBGameStartReq
         * @property {number|null} [score] ProtoSJBGameStartReq score
         * @property {number|null} [type] ProtoSJBGameStartReq type
         * @property {number|null} [area] ProtoSJBGameStartReq area
         * @property {number|null} [buff] ProtoSJBGameStartReq buff
         */

        /**
         * Constructs a new ProtoSJBGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoSJBGameStartReq.
         * @implements IProtoSJBGameStartReq
         * @constructor
         * @param {mini.IProtoSJBGameStartReq=} [properties] Properties to set
         */
        function ProtoSJBGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoSJBGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoSJBGameStartReq
         * @instance
         */
        ProtoSJBGameStartReq.prototype.score = 0;

        /**
         * ProtoSJBGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoSJBGameStartReq
         * @instance
         */
        ProtoSJBGameStartReq.prototype.type = 0;

        /**
         * ProtoSJBGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoSJBGameStartReq
         * @instance
         */
        ProtoSJBGameStartReq.prototype.area = 0;

        /**
         * ProtoSJBGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoSJBGameStartReq
         * @instance
         */
        ProtoSJBGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoSJBGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoSJBGameStartReq
         * @static
         * @param {mini.IProtoSJBGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoSJBGameStartReq} ProtoSJBGameStartReq instance
         */
        ProtoSJBGameStartReq.create = function create(properties) {
            return new ProtoSJBGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoSJBGameStartReq message. Does not implicitly {@link mini.ProtoSJBGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoSJBGameStartReq
         * @static
         * @param {mini.IProtoSJBGameStartReq} message ProtoSJBGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJBGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoSJBGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoSJBGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoSJBGameStartReq
         * @static
         * @param {mini.IProtoSJBGameStartReq} message ProtoSJBGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJBGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoSJBGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoSJBGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoSJBGameStartReq} ProtoSJBGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJBGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoSJBGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoSJBGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoSJBGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoSJBGameStartReq} ProtoSJBGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJBGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoSJBGameStartReq message.
         * @function verify
         * @memberof mini.ProtoSJBGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoSJBGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoSJBGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoSJBGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoSJBGameStartReq} ProtoSJBGameStartReq
         */
        ProtoSJBGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoSJBGameStartReq)
                return object;
            let message = new $root.mini.ProtoSJBGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoSJBGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoSJBGameStartReq
         * @static
         * @param {mini.ProtoSJBGameStartReq} message ProtoSJBGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoSJBGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoSJBGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoSJBGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoSJBGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoSJBGameStartReq;
    })();

    mini.ProtoSJBGameStartResp = (function() {

        /**
         * Properties of a ProtoSJBGameStartResp.
         * @memberof mini
         * @interface IProtoSJBGameStartResp
         * @property {number|null} [stage2Count] ProtoSJBGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoSJBGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoSJBGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoSJBGameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoSJBGameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoSJBGameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [freeResult] ProtoSJBGameStartResp freeResult
         * @property {mini.ILGFootBall|null} [footballResult] ProtoSJBGameStartResp footballResult
         * @property {string|null} [gameID] ProtoSJBGameStartResp gameID
         * @property {string|null} [buff] ProtoSJBGameStartResp buff
         * @property {string|null} [area] ProtoSJBGameStartResp area
         * @property {number|null} [per] ProtoSJBGameStartResp per
         * @property {number|null} [errorCode] ProtoSJBGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoSJBGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoSJBGameStartResp.
         * @implements IProtoSJBGameStartResp
         * @constructor
         * @param {mini.IProtoSJBGameStartResp=} [properties] Properties to set
         */
        function ProtoSJBGameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.freeResult = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoSJBGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoSJBGameStartResp
         * @instance
         */
        ProtoSJBGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoSJBGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoSJBGameStartResp
         * @instance
         */
        ProtoSJBGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoSJBGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoSJBGameStartResp
         * @instance
         */
        ProtoSJBGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoSJBGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoSJBGameStartResp
         * @instance
         */
        ProtoSJBGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoSJBGameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoSJBGameStartResp
         * @instance
         */
        ProtoSJBGameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoSJBGameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoSJBGameStartResp
         * @instance
         */
        ProtoSJBGameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoSJBGameStartResp freeResult.
         * @member {Array.<mini.IFreeSpin>} freeResult
         * @memberof mini.ProtoSJBGameStartResp
         * @instance
         */
        ProtoSJBGameStartResp.prototype.freeResult = $util.emptyArray;

        /**
         * ProtoSJBGameStartResp footballResult.
         * @member {mini.ILGFootBall|null|undefined} footballResult
         * @memberof mini.ProtoSJBGameStartResp
         * @instance
         */
        ProtoSJBGameStartResp.prototype.footballResult = null;

        /**
         * ProtoSJBGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoSJBGameStartResp
         * @instance
         */
        ProtoSJBGameStartResp.prototype.gameID = "";

        /**
         * ProtoSJBGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoSJBGameStartResp
         * @instance
         */
        ProtoSJBGameStartResp.prototype.buff = "";

        /**
         * ProtoSJBGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoSJBGameStartResp
         * @instance
         */
        ProtoSJBGameStartResp.prototype.area = "";

        /**
         * ProtoSJBGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoSJBGameStartResp
         * @instance
         */
        ProtoSJBGameStartResp.prototype.per = 0;

        /**
         * ProtoSJBGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoSJBGameStartResp
         * @instance
         */
        ProtoSJBGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoSJBGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoSJBGameStartResp
         * @static
         * @param {mini.IProtoSJBGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoSJBGameStartResp} ProtoSJBGameStartResp instance
         */
        ProtoSJBGameStartResp.create = function create(properties) {
            return new ProtoSJBGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoSJBGameStartResp message. Does not implicitly {@link mini.ProtoSJBGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoSJBGameStartResp
         * @static
         * @param {mini.IProtoSJBGameStartResp} message ProtoSJBGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJBGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.freeResult != null && message.freeResult.length)
                for (let i = 0; i < message.freeResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.freeResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.footballResult != null && Object.hasOwnProperty.call(message, "footballResult"))
                $root.mini.LGFootBall.encode(message.footballResult, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.per);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoSJBGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoSJBGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoSJBGameStartResp
         * @static
         * @param {mini.IProtoSJBGameStartResp} message ProtoSJBGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJBGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoSJBGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoSJBGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoSJBGameStartResp} ProtoSJBGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJBGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoSJBGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.freeResult && message.freeResult.length))
                        message.freeResult = [];
                    message.freeResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.footballResult = $root.mini.LGFootBall.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.gameID = reader.string();
                    break;
                case 10:
                    message.buff = reader.string();
                    break;
                case 11:
                    message.area = reader.string();
                    break;
                case 12:
                    message.per = reader.uint32();
                    break;
                case 13:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoSJBGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoSJBGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoSJBGameStartResp} ProtoSJBGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJBGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoSJBGameStartResp message.
         * @function verify
         * @memberof mini.ProtoSJBGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoSJBGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.freeResult != null && message.hasOwnProperty("freeResult")) {
                if (!Array.isArray(message.freeResult))
                    return "freeResult: array expected";
                for (let i = 0; i < message.freeResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.freeResult[i]);
                    if (error)
                        return "freeResult." + error;
                }
            }
            if (message.footballResult != null && message.hasOwnProperty("footballResult")) {
                let error = $root.mini.LGFootBall.verify(message.footballResult);
                if (error)
                    return "footballResult." + error;
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoSJBGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoSJBGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoSJBGameStartResp} ProtoSJBGameStartResp
         */
        ProtoSJBGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoSJBGameStartResp)
                return object;
            let message = new $root.mini.ProtoSJBGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoSJBGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoSJBGameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoSJBGameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoSJBGameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.freeResult) {
                if (!Array.isArray(object.freeResult))
                    throw TypeError(".mini.ProtoSJBGameStartResp.freeResult: array expected");
                message.freeResult = [];
                for (let i = 0; i < object.freeResult.length; ++i) {
                    if (typeof object.freeResult[i] !== "object")
                        throw TypeError(".mini.ProtoSJBGameStartResp.freeResult: object expected");
                    message.freeResult[i] = $root.mini.FreeSpin.fromObject(object.freeResult[i]);
                }
            }
            if (object.footballResult != null) {
                if (typeof object.footballResult !== "object")
                    throw TypeError(".mini.ProtoSJBGameStartResp.footballResult: object expected");
                message.footballResult = $root.mini.LGFootBall.fromObject(object.footballResult);
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoSJBGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoSJBGameStartResp
         * @static
         * @param {mini.ProtoSJBGameStartResp} message ProtoSJBGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoSJBGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.freeResult = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.footballResult = null;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.freeResult && message.freeResult.length) {
                object.freeResult = [];
                for (let j = 0; j < message.freeResult.length; ++j)
                    object.freeResult[j] = $root.mini.FreeSpin.toObject(message.freeResult[j], options);
            }
            if (message.footballResult != null && message.hasOwnProperty("footballResult"))
                object.footballResult = $root.mini.LGFootBall.toObject(message.footballResult, options);
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoSJBGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoSJBGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoSJBGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoSJBGameStartResp;
    })();

    mini.LineItem = (function() {

        /**
         * Properties of a LineItem.
         * @memberof mini
         * @interface ILineItem
         * @property {Array.<number>|null} [okPath] LineItem okPath
         * @property {number|null} [cardValue] LineItem cardValue
         * @property {number|null} [awTimes] LineItem awTimes
         * @property {number|null} [lineIndex] LineItem lineIndex
         */

        /**
         * Constructs a new LineItem.
         * @memberof mini
         * @classdesc Represents a LineItem.
         * @implements ILineItem
         * @constructor
         * @param {mini.ILineItem=} [properties] Properties to set
         */
        function LineItem(properties) {
            this.okPath = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LineItem okPath.
         * @member {Array.<number>} okPath
         * @memberof mini.LineItem
         * @instance
         */
        LineItem.prototype.okPath = $util.emptyArray;

        /**
         * LineItem cardValue.
         * @member {number} cardValue
         * @memberof mini.LineItem
         * @instance
         */
        LineItem.prototype.cardValue = 0;

        /**
         * LineItem awTimes.
         * @member {number} awTimes
         * @memberof mini.LineItem
         * @instance
         */
        LineItem.prototype.awTimes = 0;

        /**
         * LineItem lineIndex.
         * @member {number} lineIndex
         * @memberof mini.LineItem
         * @instance
         */
        LineItem.prototype.lineIndex = 0;

        /**
         * Creates a new LineItem instance using the specified properties.
         * @function create
         * @memberof mini.LineItem
         * @static
         * @param {mini.ILineItem=} [properties] Properties to set
         * @returns {mini.LineItem} LineItem instance
         */
        LineItem.create = function create(properties) {
            return new LineItem(properties);
        };

        /**
         * Encodes the specified LineItem message. Does not implicitly {@link mini.LineItem.verify|verify} messages.
         * @function encode
         * @memberof mini.LineItem
         * @static
         * @param {mini.ILineItem} message LineItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LineItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.okPath != null && message.okPath.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.okPath.length; ++i)
                    writer.uint32(message.okPath[i]);
                writer.ldelim();
            }
            if (message.cardValue != null && Object.hasOwnProperty.call(message, "cardValue"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cardValue);
            if (message.awTimes != null && Object.hasOwnProperty.call(message, "awTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awTimes);
            if (message.lineIndex != null && Object.hasOwnProperty.call(message, "lineIndex"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.lineIndex);
            return writer;
        };

        /**
         * Encodes the specified LineItem message, length delimited. Does not implicitly {@link mini.LineItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.LineItem
         * @static
         * @param {mini.ILineItem} message LineItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LineItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LineItem message from the specified reader or buffer.
         * @function decode
         * @memberof mini.LineItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.LineItem} LineItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LineItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.LineItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.okPath && message.okPath.length))
                        message.okPath = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.okPath.push(reader.uint32());
                    } else
                        message.okPath.push(reader.uint32());
                    break;
                case 2:
                    message.cardValue = reader.uint32();
                    break;
                case 3:
                    message.awTimes = reader.uint32();
                    break;
                case 4:
                    message.lineIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LineItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.LineItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.LineItem} LineItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LineItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LineItem message.
         * @function verify
         * @memberof mini.LineItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LineItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.okPath != null && message.hasOwnProperty("okPath")) {
                if (!Array.isArray(message.okPath))
                    return "okPath: array expected";
                for (let i = 0; i < message.okPath.length; ++i)
                    if (!$util.isInteger(message.okPath[i]))
                        return "okPath: integer[] expected";
            }
            if (message.cardValue != null && message.hasOwnProperty("cardValue"))
                if (!$util.isInteger(message.cardValue))
                    return "cardValue: integer expected";
            if (message.awTimes != null && message.hasOwnProperty("awTimes"))
                if (!$util.isInteger(message.awTimes))
                    return "awTimes: integer expected";
            if (message.lineIndex != null && message.hasOwnProperty("lineIndex"))
                if (!$util.isInteger(message.lineIndex))
                    return "lineIndex: integer expected";
            return null;
        };

        /**
         * Creates a LineItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.LineItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.LineItem} LineItem
         */
        LineItem.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.LineItem)
                return object;
            let message = new $root.mini.LineItem();
            if (object.okPath) {
                if (!Array.isArray(object.okPath))
                    throw TypeError(".mini.LineItem.okPath: array expected");
                message.okPath = [];
                for (let i = 0; i < object.okPath.length; ++i)
                    message.okPath[i] = object.okPath[i] >>> 0;
            }
            if (object.cardValue != null)
                message.cardValue = object.cardValue >>> 0;
            if (object.awTimes != null)
                message.awTimes = object.awTimes >>> 0;
            if (object.lineIndex != null)
                message.lineIndex = object.lineIndex >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a LineItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.LineItem
         * @static
         * @param {mini.LineItem} message LineItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LineItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.okPath = [];
            if (options.defaults) {
                object.cardValue = 0;
                object.awTimes = 0;
                object.lineIndex = 0;
            }
            if (message.okPath && message.okPath.length) {
                object.okPath = [];
                for (let j = 0; j < message.okPath.length; ++j)
                    object.okPath[j] = message.okPath[j];
            }
            if (message.cardValue != null && message.hasOwnProperty("cardValue"))
                object.cardValue = message.cardValue;
            if (message.awTimes != null && message.hasOwnProperty("awTimes"))
                object.awTimes = message.awTimes;
            if (message.lineIndex != null && message.hasOwnProperty("lineIndex"))
                object.lineIndex = message.lineIndex;
            return object;
        };

        /**
         * Converts this LineItem to JSON.
         * @function toJSON
         * @memberof mini.LineItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LineItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LineItem;
    })();

    mini.FreeSpin = (function() {

        /**
         * Properties of a FreeSpin.
         * @memberof mini
         * @interface IFreeSpin
         * @property {number|null} [awardTotalTimes] FreeSpin awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] FreeSpin itemInfo
         * @property {Array.<boolean>|null} [shineArea] FreeSpin shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] FreeSpin lineItem
         * @property {Array.<number>|null} [param] FreeSpin param
         * @property {string|null} [area] FreeSpin area
         * @property {number|null} [per] FreeSpin per
         * @property {Array.<mini.IFreeSpin>|null} [freeResult] FreeSpin freeResult
         */

        /**
         * Constructs a new FreeSpin.
         * @memberof mini
         * @classdesc Represents a FreeSpin.
         * @implements IFreeSpin
         * @constructor
         * @param {mini.IFreeSpin=} [properties] Properties to set
         */
        function FreeSpin(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.param = [];
            this.freeResult = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FreeSpin awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.FreeSpin
         * @instance
         */
        FreeSpin.prototype.awardTotalTimes = 0;

        /**
         * FreeSpin itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.FreeSpin
         * @instance
         */
        FreeSpin.prototype.itemInfo = $util.emptyArray;

        /**
         * FreeSpin shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.FreeSpin
         * @instance
         */
        FreeSpin.prototype.shineArea = $util.emptyArray;

        /**
         * FreeSpin lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.FreeSpin
         * @instance
         */
        FreeSpin.prototype.lineItem = $util.emptyArray;

        /**
         * FreeSpin param.
         * @member {Array.<number>} param
         * @memberof mini.FreeSpin
         * @instance
         */
        FreeSpin.prototype.param = $util.emptyArray;

        /**
         * FreeSpin area.
         * @member {string} area
         * @memberof mini.FreeSpin
         * @instance
         */
        FreeSpin.prototype.area = "";

        /**
         * FreeSpin per.
         * @member {number} per
         * @memberof mini.FreeSpin
         * @instance
         */
        FreeSpin.prototype.per = 0;

        /**
         * FreeSpin freeResult.
         * @member {Array.<mini.IFreeSpin>} freeResult
         * @memberof mini.FreeSpin
         * @instance
         */
        FreeSpin.prototype.freeResult = $util.emptyArray;

        /**
         * Creates a new FreeSpin instance using the specified properties.
         * @function create
         * @memberof mini.FreeSpin
         * @static
         * @param {mini.IFreeSpin=} [properties] Properties to set
         * @returns {mini.FreeSpin} FreeSpin instance
         */
        FreeSpin.create = function create(properties) {
            return new FreeSpin(properties);
        };

        /**
         * Encodes the specified FreeSpin message. Does not implicitly {@link mini.FreeSpin.verify|verify} messages.
         * @function encode
         * @memberof mini.FreeSpin
         * @static
         * @param {mini.IFreeSpin} message FreeSpin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreeSpin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.param != null && message.param.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.param.length; ++i)
                    writer.int32(message.param[i]);
                writer.ldelim();
            }
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.per);
            if (message.freeResult != null && message.freeResult.length)
                for (let i = 0; i < message.freeResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.freeResult[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FreeSpin message, length delimited. Does not implicitly {@link mini.FreeSpin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.FreeSpin
         * @static
         * @param {mini.IFreeSpin} message FreeSpin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreeSpin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FreeSpin message from the specified reader or buffer.
         * @function decode
         * @memberof mini.FreeSpin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.FreeSpin} FreeSpin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreeSpin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.FreeSpin();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 2:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 3:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 4:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                case 6:
                    message.area = reader.string();
                    break;
                case 7:
                    message.per = reader.uint32();
                    break;
                case 8:
                    if (!(message.freeResult && message.freeResult.length))
                        message.freeResult = [];
                    message.freeResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FreeSpin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.FreeSpin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.FreeSpin} FreeSpin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreeSpin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FreeSpin message.
         * @function verify
         * @memberof mini.FreeSpin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FreeSpin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (let i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.freeResult != null && message.hasOwnProperty("freeResult")) {
                if (!Array.isArray(message.freeResult))
                    return "freeResult: array expected";
                for (let i = 0; i < message.freeResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.freeResult[i]);
                    if (error)
                        return "freeResult." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FreeSpin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.FreeSpin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.FreeSpin} FreeSpin
         */
        FreeSpin.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.FreeSpin)
                return object;
            let message = new $root.mini.FreeSpin();
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.FreeSpin.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.FreeSpin.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.FreeSpin.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.FreeSpin.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".mini.FreeSpin.param: array expected");
                message.param = [];
                for (let i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.freeResult) {
                if (!Array.isArray(object.freeResult))
                    throw TypeError(".mini.FreeSpin.freeResult: array expected");
                message.freeResult = [];
                for (let i = 0; i < object.freeResult.length; ++i) {
                    if (typeof object.freeResult[i] !== "object")
                        throw TypeError(".mini.FreeSpin.freeResult: object expected");
                    message.freeResult[i] = $root.mini.FreeSpin.fromObject(object.freeResult[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a FreeSpin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.FreeSpin
         * @static
         * @param {mini.FreeSpin} message FreeSpin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FreeSpin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.param = [];
                object.freeResult = [];
            }
            if (options.defaults) {
                object.awardTotalTimes = 0;
                object.area = "";
                object.per = 0;
            }
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.param && message.param.length) {
                object.param = [];
                for (let j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.freeResult && message.freeResult.length) {
                object.freeResult = [];
                for (let j = 0; j < message.freeResult.length; ++j)
                    object.freeResult[j] = $root.mini.FreeSpin.toObject(message.freeResult[j], options);
            }
            return object;
        };

        /**
         * Converts this FreeSpin to JSON.
         * @function toJSON
         * @memberof mini.FreeSpin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FreeSpin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FreeSpin;
    })();

    mini.LGFootBall = (function() {

        /**
         * Properties of a LGFootBall.
         * @memberof mini
         * @interface ILGFootBall
         * @property {number|null} [awardTotalTimes] LGFootBall awardTotalTimes
         * @property {Array.<number>|null} [firstRsult] LGFootBall firstRsult
         * @property {number|null} [secondTimes] LGFootBall secondTimes
         * @property {string|null} [area] LGFootBall area
         * @property {number|null} [per] LGFootBall per
         */

        /**
         * Constructs a new LGFootBall.
         * @memberof mini
         * @classdesc Represents a LGFootBall.
         * @implements ILGFootBall
         * @constructor
         * @param {mini.ILGFootBall=} [properties] Properties to set
         */
        function LGFootBall(properties) {
            this.firstRsult = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LGFootBall awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.LGFootBall
         * @instance
         */
        LGFootBall.prototype.awardTotalTimes = 0;

        /**
         * LGFootBall firstRsult.
         * @member {Array.<number>} firstRsult
         * @memberof mini.LGFootBall
         * @instance
         */
        LGFootBall.prototype.firstRsult = $util.emptyArray;

        /**
         * LGFootBall secondTimes.
         * @member {number} secondTimes
         * @memberof mini.LGFootBall
         * @instance
         */
        LGFootBall.prototype.secondTimes = 0;

        /**
         * LGFootBall area.
         * @member {string} area
         * @memberof mini.LGFootBall
         * @instance
         */
        LGFootBall.prototype.area = "";

        /**
         * LGFootBall per.
         * @member {number} per
         * @memberof mini.LGFootBall
         * @instance
         */
        LGFootBall.prototype.per = 0;

        /**
         * Creates a new LGFootBall instance using the specified properties.
         * @function create
         * @memberof mini.LGFootBall
         * @static
         * @param {mini.ILGFootBall=} [properties] Properties to set
         * @returns {mini.LGFootBall} LGFootBall instance
         */
        LGFootBall.create = function create(properties) {
            return new LGFootBall(properties);
        };

        /**
         * Encodes the specified LGFootBall message. Does not implicitly {@link mini.LGFootBall.verify|verify} messages.
         * @function encode
         * @memberof mini.LGFootBall
         * @static
         * @param {mini.ILGFootBall} message LGFootBall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LGFootBall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.awardTotalTimes);
            if (message.firstRsult != null && message.firstRsult.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (let i = 0; i < message.firstRsult.length; ++i)
                    writer.uint32(message.firstRsult[i]);
                writer.ldelim();
            }
            if (message.secondTimes != null && Object.hasOwnProperty.call(message, "secondTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.secondTimes);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.per);
            return writer;
        };

        /**
         * Encodes the specified LGFootBall message, length delimited. Does not implicitly {@link mini.LGFootBall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.LGFootBall
         * @static
         * @param {mini.ILGFootBall} message LGFootBall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LGFootBall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LGFootBall message from the specified reader or buffer.
         * @function decode
         * @memberof mini.LGFootBall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.LGFootBall} LGFootBall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LGFootBall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.LGFootBall();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 2:
                    if (!(message.firstRsult && message.firstRsult.length))
                        message.firstRsult = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.firstRsult.push(reader.uint32());
                    } else
                        message.firstRsult.push(reader.uint32());
                    break;
                case 3:
                    message.secondTimes = reader.uint32();
                    break;
                case 4:
                    message.area = reader.string();
                    break;
                case 5:
                    message.per = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LGFootBall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.LGFootBall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.LGFootBall} LGFootBall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LGFootBall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LGFootBall message.
         * @function verify
         * @memberof mini.LGFootBall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LGFootBall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.firstRsult != null && message.hasOwnProperty("firstRsult")) {
                if (!Array.isArray(message.firstRsult))
                    return "firstRsult: array expected";
                for (let i = 0; i < message.firstRsult.length; ++i)
                    if (!$util.isInteger(message.firstRsult[i]))
                        return "firstRsult: integer[] expected";
            }
            if (message.secondTimes != null && message.hasOwnProperty("secondTimes"))
                if (!$util.isInteger(message.secondTimes))
                    return "secondTimes: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            return null;
        };

        /**
         * Creates a LGFootBall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.LGFootBall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.LGFootBall} LGFootBall
         */
        LGFootBall.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.LGFootBall)
                return object;
            let message = new $root.mini.LGFootBall();
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.firstRsult) {
                if (!Array.isArray(object.firstRsult))
                    throw TypeError(".mini.LGFootBall.firstRsult: array expected");
                message.firstRsult = [];
                for (let i = 0; i < object.firstRsult.length; ++i)
                    message.firstRsult[i] = object.firstRsult[i] >>> 0;
            }
            if (object.secondTimes != null)
                message.secondTimes = object.secondTimes >>> 0;
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a LGFootBall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.LGFootBall
         * @static
         * @param {mini.LGFootBall} message LGFootBall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LGFootBall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.firstRsult = [];
            if (options.defaults) {
                object.awardTotalTimes = 0;
                object.secondTimes = 0;
                object.area = "";
                object.per = 0;
            }
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.firstRsult && message.firstRsult.length) {
                object.firstRsult = [];
                for (let j = 0; j < message.firstRsult.length; ++j)
                    object.firstRsult[j] = message.firstRsult[j];
            }
            if (message.secondTimes != null && message.hasOwnProperty("secondTimes"))
                object.secondTimes = message.secondTimes;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            return object;
        };

        /**
         * Converts this LGFootBall to JSON.
         * @function toJSON
         * @memberof mini.LGFootBall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LGFootBall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LGFootBall;
    })();

    mini.ProtoSJBBlockReq = (function() {

        /**
         * Properties of a ProtoSJBBlockReq.
         * @memberof mini
         * @interface IProtoSJBBlockReq
         * @property {number|null} [gameType] ProtoSJBBlockReq gameType
         */

        /**
         * Constructs a new ProtoSJBBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoSJBBlockReq.
         * @implements IProtoSJBBlockReq
         * @constructor
         * @param {mini.IProtoSJBBlockReq=} [properties] Properties to set
         */
        function ProtoSJBBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoSJBBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoSJBBlockReq
         * @instance
         */
        ProtoSJBBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoSJBBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoSJBBlockReq
         * @static
         * @param {mini.IProtoSJBBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoSJBBlockReq} ProtoSJBBlockReq instance
         */
        ProtoSJBBlockReq.create = function create(properties) {
            return new ProtoSJBBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoSJBBlockReq message. Does not implicitly {@link mini.ProtoSJBBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoSJBBlockReq
         * @static
         * @param {mini.IProtoSJBBlockReq} message ProtoSJBBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJBBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoSJBBlockReq message, length delimited. Does not implicitly {@link mini.ProtoSJBBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoSJBBlockReq
         * @static
         * @param {mini.IProtoSJBBlockReq} message ProtoSJBBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJBBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoSJBBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoSJBBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoSJBBlockReq} ProtoSJBBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJBBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoSJBBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoSJBBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoSJBBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoSJBBlockReq} ProtoSJBBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJBBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoSJBBlockReq message.
         * @function verify
         * @memberof mini.ProtoSJBBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoSJBBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoSJBBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoSJBBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoSJBBlockReq} ProtoSJBBlockReq
         */
        ProtoSJBBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoSJBBlockReq)
                return object;
            let message = new $root.mini.ProtoSJBBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoSJBBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoSJBBlockReq
         * @static
         * @param {mini.ProtoSJBBlockReq} message ProtoSJBBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoSJBBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoSJBBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoSJBBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoSJBBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoSJBBlockReq;
    })();

    mini.ProtoSJBBlockResp = (function() {

        /**
         * Properties of a ProtoSJBBlockResp.
         * @memberof mini
         * @interface IProtoSJBBlockResp
         * @property {Array.<number>|null} [block] ProtoSJBBlockResp block
         */

        /**
         * Constructs a new ProtoSJBBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoSJBBlockResp.
         * @implements IProtoSJBBlockResp
         * @constructor
         * @param {mini.IProtoSJBBlockResp=} [properties] Properties to set
         */
        function ProtoSJBBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoSJBBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoSJBBlockResp
         * @instance
         */
        ProtoSJBBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoSJBBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoSJBBlockResp
         * @static
         * @param {mini.IProtoSJBBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoSJBBlockResp} ProtoSJBBlockResp instance
         */
        ProtoSJBBlockResp.create = function create(properties) {
            return new ProtoSJBBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoSJBBlockResp message. Does not implicitly {@link mini.ProtoSJBBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoSJBBlockResp
         * @static
         * @param {mini.IProtoSJBBlockResp} message ProtoSJBBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJBBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoSJBBlockResp message, length delimited. Does not implicitly {@link mini.ProtoSJBBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoSJBBlockResp
         * @static
         * @param {mini.IProtoSJBBlockResp} message ProtoSJBBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJBBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoSJBBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoSJBBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoSJBBlockResp} ProtoSJBBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJBBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoSJBBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoSJBBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoSJBBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoSJBBlockResp} ProtoSJBBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJBBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoSJBBlockResp message.
         * @function verify
         * @memberof mini.ProtoSJBBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoSJBBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoSJBBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoSJBBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoSJBBlockResp} ProtoSJBBlockResp
         */
        ProtoSJBBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoSJBBlockResp)
                return object;
            let message = new $root.mini.ProtoSJBBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoSJBBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoSJBBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoSJBBlockResp
         * @static
         * @param {mini.ProtoSJBBlockResp} message ProtoSJBBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoSJBBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoSJBBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoSJBBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoSJBBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoSJBBlockResp;
    })();

    mini.ProtoSJBReconnectionResp = (function() {

        /**
         * Properties of a ProtoSJBReconnectionResp.
         * @memberof mini
         * @interface IProtoSJBReconnectionResp
         * @property {Array.<number>|null} [block] ProtoSJBReconnectionResp block
         */

        /**
         * Constructs a new ProtoSJBReconnectionResp.
         * @memberof mini
         * @classdesc Represents a ProtoSJBReconnectionResp.
         * @implements IProtoSJBReconnectionResp
         * @constructor
         * @param {mini.IProtoSJBReconnectionResp=} [properties] Properties to set
         */
        function ProtoSJBReconnectionResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoSJBReconnectionResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoSJBReconnectionResp
         * @instance
         */
        ProtoSJBReconnectionResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoSJBReconnectionResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoSJBReconnectionResp
         * @static
         * @param {mini.IProtoSJBReconnectionResp=} [properties] Properties to set
         * @returns {mini.ProtoSJBReconnectionResp} ProtoSJBReconnectionResp instance
         */
        ProtoSJBReconnectionResp.create = function create(properties) {
            return new ProtoSJBReconnectionResp(properties);
        };

        /**
         * Encodes the specified ProtoSJBReconnectionResp message. Does not implicitly {@link mini.ProtoSJBReconnectionResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoSJBReconnectionResp
         * @static
         * @param {mini.IProtoSJBReconnectionResp} message ProtoSJBReconnectionResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJBReconnectionResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoSJBReconnectionResp message, length delimited. Does not implicitly {@link mini.ProtoSJBReconnectionResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoSJBReconnectionResp
         * @static
         * @param {mini.IProtoSJBReconnectionResp} message ProtoSJBReconnectionResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJBReconnectionResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoSJBReconnectionResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoSJBReconnectionResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoSJBReconnectionResp} ProtoSJBReconnectionResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJBReconnectionResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoSJBReconnectionResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoSJBReconnectionResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoSJBReconnectionResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoSJBReconnectionResp} ProtoSJBReconnectionResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJBReconnectionResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoSJBReconnectionResp message.
         * @function verify
         * @memberof mini.ProtoSJBReconnectionResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoSJBReconnectionResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoSJBReconnectionResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoSJBReconnectionResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoSJBReconnectionResp} ProtoSJBReconnectionResp
         */
        ProtoSJBReconnectionResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoSJBReconnectionResp)
                return object;
            let message = new $root.mini.ProtoSJBReconnectionResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoSJBReconnectionResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoSJBReconnectionResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoSJBReconnectionResp
         * @static
         * @param {mini.ProtoSJBReconnectionResp} message ProtoSJBReconnectionResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoSJBReconnectionResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoSJBReconnectionResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoSJBReconnectionResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoSJBReconnectionResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoSJBReconnectionResp;
    })();

    mini.ProtoEgyptGameStartReq = (function() {

        /**
         * Properties of a ProtoEgyptGameStartReq.
         * @memberof mini
         * @interface IProtoEgyptGameStartReq
         * @property {number|null} [score] ProtoEgyptGameStartReq score
         * @property {number|null} [type] ProtoEgyptGameStartReq type
         * @property {number|null} [area] ProtoEgyptGameStartReq area
         * @property {number|null} [buff] ProtoEgyptGameStartReq buff
         */

        /**
         * Constructs a new ProtoEgyptGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoEgyptGameStartReq.
         * @implements IProtoEgyptGameStartReq
         * @constructor
         * @param {mini.IProtoEgyptGameStartReq=} [properties] Properties to set
         */
        function ProtoEgyptGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoEgyptGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoEgyptGameStartReq
         * @instance
         */
        ProtoEgyptGameStartReq.prototype.score = 0;

        /**
         * ProtoEgyptGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoEgyptGameStartReq
         * @instance
         */
        ProtoEgyptGameStartReq.prototype.type = 0;

        /**
         * ProtoEgyptGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoEgyptGameStartReq
         * @instance
         */
        ProtoEgyptGameStartReq.prototype.area = 0;

        /**
         * ProtoEgyptGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoEgyptGameStartReq
         * @instance
         */
        ProtoEgyptGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoEgyptGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoEgyptGameStartReq
         * @static
         * @param {mini.IProtoEgyptGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoEgyptGameStartReq} ProtoEgyptGameStartReq instance
         */
        ProtoEgyptGameStartReq.create = function create(properties) {
            return new ProtoEgyptGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoEgyptGameStartReq message. Does not implicitly {@link mini.ProtoEgyptGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoEgyptGameStartReq
         * @static
         * @param {mini.IProtoEgyptGameStartReq} message ProtoEgyptGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoEgyptGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoEgyptGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoEgyptGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoEgyptGameStartReq
         * @static
         * @param {mini.IProtoEgyptGameStartReq} message ProtoEgyptGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoEgyptGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoEgyptGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoEgyptGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoEgyptGameStartReq} ProtoEgyptGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoEgyptGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoEgyptGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoEgyptGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoEgyptGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoEgyptGameStartReq} ProtoEgyptGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoEgyptGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoEgyptGameStartReq message.
         * @function verify
         * @memberof mini.ProtoEgyptGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoEgyptGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoEgyptGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoEgyptGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoEgyptGameStartReq} ProtoEgyptGameStartReq
         */
        ProtoEgyptGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoEgyptGameStartReq)
                return object;
            let message = new $root.mini.ProtoEgyptGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoEgyptGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoEgyptGameStartReq
         * @static
         * @param {mini.ProtoEgyptGameStartReq} message ProtoEgyptGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoEgyptGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoEgyptGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoEgyptGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoEgyptGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoEgyptGameStartReq;
    })();

    mini.ProtoEgyptGameStartResp = (function() {

        /**
         * Properties of a ProtoEgyptGameStartResp.
         * @memberof mini
         * @interface IProtoEgyptGameStartResp
         * @property {number|null} [stage2Count] ProtoEgyptGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoEgyptGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoEgyptGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoEgyptGameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoEgyptGameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoEgyptGameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [freeResult] ProtoEgyptGameStartResp freeResult
         * @property {Array.<mini.IFreeSpin>|null} [superResult] ProtoEgyptGameStartResp superResult
         * @property {string|null} [gameID] ProtoEgyptGameStartResp gameID
         * @property {string|null} [buff] ProtoEgyptGameStartResp buff
         * @property {string|null} [area] ProtoEgyptGameStartResp area
         * @property {number|null} [per] ProtoEgyptGameStartResp per
         * @property {number|null} [errorCode] ProtoEgyptGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoEgyptGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoEgyptGameStartResp.
         * @implements IProtoEgyptGameStartResp
         * @constructor
         * @param {mini.IProtoEgyptGameStartResp=} [properties] Properties to set
         */
        function ProtoEgyptGameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.freeResult = [];
            this.superResult = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoEgyptGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoEgyptGameStartResp
         * @instance
         */
        ProtoEgyptGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoEgyptGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoEgyptGameStartResp
         * @instance
         */
        ProtoEgyptGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoEgyptGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoEgyptGameStartResp
         * @instance
         */
        ProtoEgyptGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoEgyptGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoEgyptGameStartResp
         * @instance
         */
        ProtoEgyptGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoEgyptGameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoEgyptGameStartResp
         * @instance
         */
        ProtoEgyptGameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoEgyptGameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoEgyptGameStartResp
         * @instance
         */
        ProtoEgyptGameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoEgyptGameStartResp freeResult.
         * @member {Array.<mini.IFreeSpin>} freeResult
         * @memberof mini.ProtoEgyptGameStartResp
         * @instance
         */
        ProtoEgyptGameStartResp.prototype.freeResult = $util.emptyArray;

        /**
         * ProtoEgyptGameStartResp superResult.
         * @member {Array.<mini.IFreeSpin>} superResult
         * @memberof mini.ProtoEgyptGameStartResp
         * @instance
         */
        ProtoEgyptGameStartResp.prototype.superResult = $util.emptyArray;

        /**
         * ProtoEgyptGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoEgyptGameStartResp
         * @instance
         */
        ProtoEgyptGameStartResp.prototype.gameID = "";

        /**
         * ProtoEgyptGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoEgyptGameStartResp
         * @instance
         */
        ProtoEgyptGameStartResp.prototype.buff = "";

        /**
         * ProtoEgyptGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoEgyptGameStartResp
         * @instance
         */
        ProtoEgyptGameStartResp.prototype.area = "";

        /**
         * ProtoEgyptGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoEgyptGameStartResp
         * @instance
         */
        ProtoEgyptGameStartResp.prototype.per = 0;

        /**
         * ProtoEgyptGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoEgyptGameStartResp
         * @instance
         */
        ProtoEgyptGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoEgyptGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoEgyptGameStartResp
         * @static
         * @param {mini.IProtoEgyptGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoEgyptGameStartResp} ProtoEgyptGameStartResp instance
         */
        ProtoEgyptGameStartResp.create = function create(properties) {
            return new ProtoEgyptGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoEgyptGameStartResp message. Does not implicitly {@link mini.ProtoEgyptGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoEgyptGameStartResp
         * @static
         * @param {mini.IProtoEgyptGameStartResp} message ProtoEgyptGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoEgyptGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.freeResult != null && message.freeResult.length)
                for (let i = 0; i < message.freeResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.freeResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.superResult != null && message.superResult.length)
                for (let i = 0; i < message.superResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.superResult[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.per);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoEgyptGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoEgyptGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoEgyptGameStartResp
         * @static
         * @param {mini.IProtoEgyptGameStartResp} message ProtoEgyptGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoEgyptGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoEgyptGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoEgyptGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoEgyptGameStartResp} ProtoEgyptGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoEgyptGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoEgyptGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.freeResult && message.freeResult.length))
                        message.freeResult = [];
                    message.freeResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.superResult && message.superResult.length))
                        message.superResult = [];
                    message.superResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.gameID = reader.string();
                    break;
                case 10:
                    message.buff = reader.string();
                    break;
                case 11:
                    message.area = reader.string();
                    break;
                case 12:
                    message.per = reader.uint32();
                    break;
                case 13:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoEgyptGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoEgyptGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoEgyptGameStartResp} ProtoEgyptGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoEgyptGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoEgyptGameStartResp message.
         * @function verify
         * @memberof mini.ProtoEgyptGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoEgyptGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.freeResult != null && message.hasOwnProperty("freeResult")) {
                if (!Array.isArray(message.freeResult))
                    return "freeResult: array expected";
                for (let i = 0; i < message.freeResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.freeResult[i]);
                    if (error)
                        return "freeResult." + error;
                }
            }
            if (message.superResult != null && message.hasOwnProperty("superResult")) {
                if (!Array.isArray(message.superResult))
                    return "superResult: array expected";
                for (let i = 0; i < message.superResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.superResult[i]);
                    if (error)
                        return "superResult." + error;
                }
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoEgyptGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoEgyptGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoEgyptGameStartResp} ProtoEgyptGameStartResp
         */
        ProtoEgyptGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoEgyptGameStartResp)
                return object;
            let message = new $root.mini.ProtoEgyptGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoEgyptGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoEgyptGameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoEgyptGameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoEgyptGameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.freeResult) {
                if (!Array.isArray(object.freeResult))
                    throw TypeError(".mini.ProtoEgyptGameStartResp.freeResult: array expected");
                message.freeResult = [];
                for (let i = 0; i < object.freeResult.length; ++i) {
                    if (typeof object.freeResult[i] !== "object")
                        throw TypeError(".mini.ProtoEgyptGameStartResp.freeResult: object expected");
                    message.freeResult[i] = $root.mini.FreeSpin.fromObject(object.freeResult[i]);
                }
            }
            if (object.superResult) {
                if (!Array.isArray(object.superResult))
                    throw TypeError(".mini.ProtoEgyptGameStartResp.superResult: array expected");
                message.superResult = [];
                for (let i = 0; i < object.superResult.length; ++i) {
                    if (typeof object.superResult[i] !== "object")
                        throw TypeError(".mini.ProtoEgyptGameStartResp.superResult: object expected");
                    message.superResult[i] = $root.mini.FreeSpin.fromObject(object.superResult[i]);
                }
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoEgyptGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoEgyptGameStartResp
         * @static
         * @param {mini.ProtoEgyptGameStartResp} message ProtoEgyptGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoEgyptGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.freeResult = [];
                object.superResult = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.freeResult && message.freeResult.length) {
                object.freeResult = [];
                for (let j = 0; j < message.freeResult.length; ++j)
                    object.freeResult[j] = $root.mini.FreeSpin.toObject(message.freeResult[j], options);
            }
            if (message.superResult && message.superResult.length) {
                object.superResult = [];
                for (let j = 0; j < message.superResult.length; ++j)
                    object.superResult[j] = $root.mini.FreeSpin.toObject(message.superResult[j], options);
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoEgyptGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoEgyptGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoEgyptGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoEgyptGameStartResp;
    })();

    mini.ProtoEgyptBlockReq = (function() {

        /**
         * Properties of a ProtoEgyptBlockReq.
         * @memberof mini
         * @interface IProtoEgyptBlockReq
         */

        /**
         * Constructs a new ProtoEgyptBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoEgyptBlockReq.
         * @implements IProtoEgyptBlockReq
         * @constructor
         * @param {mini.IProtoEgyptBlockReq=} [properties] Properties to set
         */
        function ProtoEgyptBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ProtoEgyptBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoEgyptBlockReq
         * @static
         * @param {mini.IProtoEgyptBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoEgyptBlockReq} ProtoEgyptBlockReq instance
         */
        ProtoEgyptBlockReq.create = function create(properties) {
            return new ProtoEgyptBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoEgyptBlockReq message. Does not implicitly {@link mini.ProtoEgyptBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoEgyptBlockReq
         * @static
         * @param {mini.IProtoEgyptBlockReq} message ProtoEgyptBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoEgyptBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ProtoEgyptBlockReq message, length delimited. Does not implicitly {@link mini.ProtoEgyptBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoEgyptBlockReq
         * @static
         * @param {mini.IProtoEgyptBlockReq} message ProtoEgyptBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoEgyptBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoEgyptBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoEgyptBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoEgyptBlockReq} ProtoEgyptBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoEgyptBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoEgyptBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoEgyptBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoEgyptBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoEgyptBlockReq} ProtoEgyptBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoEgyptBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoEgyptBlockReq message.
         * @function verify
         * @memberof mini.ProtoEgyptBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoEgyptBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ProtoEgyptBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoEgyptBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoEgyptBlockReq} ProtoEgyptBlockReq
         */
        ProtoEgyptBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoEgyptBlockReq)
                return object;
            return new $root.mini.ProtoEgyptBlockReq();
        };

        /**
         * Creates a plain object from a ProtoEgyptBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoEgyptBlockReq
         * @static
         * @param {mini.ProtoEgyptBlockReq} message ProtoEgyptBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoEgyptBlockReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ProtoEgyptBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoEgyptBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoEgyptBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoEgyptBlockReq;
    })();

    mini.ProtoEgyptBlockResp = (function() {

        /**
         * Properties of a ProtoEgyptBlockResp.
         * @memberof mini
         * @interface IProtoEgyptBlockResp
         * @property {Array.<number>|null} [block] ProtoEgyptBlockResp block
         */

        /**
         * Constructs a new ProtoEgyptBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoEgyptBlockResp.
         * @implements IProtoEgyptBlockResp
         * @constructor
         * @param {mini.IProtoEgyptBlockResp=} [properties] Properties to set
         */
        function ProtoEgyptBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoEgyptBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoEgyptBlockResp
         * @instance
         */
        ProtoEgyptBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoEgyptBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoEgyptBlockResp
         * @static
         * @param {mini.IProtoEgyptBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoEgyptBlockResp} ProtoEgyptBlockResp instance
         */
        ProtoEgyptBlockResp.create = function create(properties) {
            return new ProtoEgyptBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoEgyptBlockResp message. Does not implicitly {@link mini.ProtoEgyptBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoEgyptBlockResp
         * @static
         * @param {mini.IProtoEgyptBlockResp} message ProtoEgyptBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoEgyptBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoEgyptBlockResp message, length delimited. Does not implicitly {@link mini.ProtoEgyptBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoEgyptBlockResp
         * @static
         * @param {mini.IProtoEgyptBlockResp} message ProtoEgyptBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoEgyptBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoEgyptBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoEgyptBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoEgyptBlockResp} ProtoEgyptBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoEgyptBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoEgyptBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoEgyptBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoEgyptBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoEgyptBlockResp} ProtoEgyptBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoEgyptBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoEgyptBlockResp message.
         * @function verify
         * @memberof mini.ProtoEgyptBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoEgyptBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoEgyptBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoEgyptBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoEgyptBlockResp} ProtoEgyptBlockResp
         */
        ProtoEgyptBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoEgyptBlockResp)
                return object;
            let message = new $root.mini.ProtoEgyptBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoEgyptBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoEgyptBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoEgyptBlockResp
         * @static
         * @param {mini.ProtoEgyptBlockResp} message ProtoEgyptBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoEgyptBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoEgyptBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoEgyptBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoEgyptBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoEgyptBlockResp;
    })();

    mini.ProtoEgyptReconnectionResp = (function() {

        /**
         * Properties of a ProtoEgyptReconnectionResp.
         * @memberof mini
         * @interface IProtoEgyptReconnectionResp
         * @property {Array.<number>|null} [block] ProtoEgyptReconnectionResp block
         */

        /**
         * Constructs a new ProtoEgyptReconnectionResp.
         * @memberof mini
         * @classdesc Represents a ProtoEgyptReconnectionResp.
         * @implements IProtoEgyptReconnectionResp
         * @constructor
         * @param {mini.IProtoEgyptReconnectionResp=} [properties] Properties to set
         */
        function ProtoEgyptReconnectionResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoEgyptReconnectionResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoEgyptReconnectionResp
         * @instance
         */
        ProtoEgyptReconnectionResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoEgyptReconnectionResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoEgyptReconnectionResp
         * @static
         * @param {mini.IProtoEgyptReconnectionResp=} [properties] Properties to set
         * @returns {mini.ProtoEgyptReconnectionResp} ProtoEgyptReconnectionResp instance
         */
        ProtoEgyptReconnectionResp.create = function create(properties) {
            return new ProtoEgyptReconnectionResp(properties);
        };

        /**
         * Encodes the specified ProtoEgyptReconnectionResp message. Does not implicitly {@link mini.ProtoEgyptReconnectionResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoEgyptReconnectionResp
         * @static
         * @param {mini.IProtoEgyptReconnectionResp} message ProtoEgyptReconnectionResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoEgyptReconnectionResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoEgyptReconnectionResp message, length delimited. Does not implicitly {@link mini.ProtoEgyptReconnectionResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoEgyptReconnectionResp
         * @static
         * @param {mini.IProtoEgyptReconnectionResp} message ProtoEgyptReconnectionResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoEgyptReconnectionResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoEgyptReconnectionResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoEgyptReconnectionResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoEgyptReconnectionResp} ProtoEgyptReconnectionResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoEgyptReconnectionResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoEgyptReconnectionResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoEgyptReconnectionResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoEgyptReconnectionResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoEgyptReconnectionResp} ProtoEgyptReconnectionResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoEgyptReconnectionResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoEgyptReconnectionResp message.
         * @function verify
         * @memberof mini.ProtoEgyptReconnectionResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoEgyptReconnectionResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoEgyptReconnectionResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoEgyptReconnectionResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoEgyptReconnectionResp} ProtoEgyptReconnectionResp
         */
        ProtoEgyptReconnectionResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoEgyptReconnectionResp)
                return object;
            let message = new $root.mini.ProtoEgyptReconnectionResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoEgyptReconnectionResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoEgyptReconnectionResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoEgyptReconnectionResp
         * @static
         * @param {mini.ProtoEgyptReconnectionResp} message ProtoEgyptReconnectionResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoEgyptReconnectionResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoEgyptReconnectionResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoEgyptReconnectionResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoEgyptReconnectionResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoEgyptReconnectionResp;
    })();

    mini.ProtoAztecBlockReq = (function() {

        /**
         * Properties of a ProtoAztecBlockReq.
         * @memberof mini
         * @interface IProtoAztecBlockReq
         * @property {number|null} [gameType] ProtoAztecBlockReq gameType
         */

        /**
         * Constructs a new ProtoAztecBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoAztecBlockReq.
         * @implements IProtoAztecBlockReq
         * @constructor
         * @param {mini.IProtoAztecBlockReq=} [properties] Properties to set
         */
        function ProtoAztecBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoAztecBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoAztecBlockReq
         * @instance
         */
        ProtoAztecBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoAztecBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoAztecBlockReq
         * @static
         * @param {mini.IProtoAztecBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoAztecBlockReq} ProtoAztecBlockReq instance
         */
        ProtoAztecBlockReq.create = function create(properties) {
            return new ProtoAztecBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoAztecBlockReq message. Does not implicitly {@link mini.ProtoAztecBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoAztecBlockReq
         * @static
         * @param {mini.IProtoAztecBlockReq} message ProtoAztecBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoAztecBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoAztecBlockReq message, length delimited. Does not implicitly {@link mini.ProtoAztecBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoAztecBlockReq
         * @static
         * @param {mini.IProtoAztecBlockReq} message ProtoAztecBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoAztecBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoAztecBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoAztecBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoAztecBlockReq} ProtoAztecBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoAztecBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoAztecBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoAztecBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoAztecBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoAztecBlockReq} ProtoAztecBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoAztecBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoAztecBlockReq message.
         * @function verify
         * @memberof mini.ProtoAztecBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoAztecBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoAztecBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoAztecBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoAztecBlockReq} ProtoAztecBlockReq
         */
        ProtoAztecBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoAztecBlockReq)
                return object;
            let message = new $root.mini.ProtoAztecBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoAztecBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoAztecBlockReq
         * @static
         * @param {mini.ProtoAztecBlockReq} message ProtoAztecBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoAztecBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoAztecBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoAztecBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoAztecBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoAztecBlockReq;
    })();

    mini.ProtoAztecBlockResp = (function() {

        /**
         * Properties of a ProtoAztecBlockResp.
         * @memberof mini
         * @interface IProtoAztecBlockResp
         * @property {Array.<number>|null} [block] ProtoAztecBlockResp block
         */

        /**
         * Constructs a new ProtoAztecBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoAztecBlockResp.
         * @implements IProtoAztecBlockResp
         * @constructor
         * @param {mini.IProtoAztecBlockResp=} [properties] Properties to set
         */
        function ProtoAztecBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoAztecBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoAztecBlockResp
         * @instance
         */
        ProtoAztecBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoAztecBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoAztecBlockResp
         * @static
         * @param {mini.IProtoAztecBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoAztecBlockResp} ProtoAztecBlockResp instance
         */
        ProtoAztecBlockResp.create = function create(properties) {
            return new ProtoAztecBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoAztecBlockResp message. Does not implicitly {@link mini.ProtoAztecBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoAztecBlockResp
         * @static
         * @param {mini.IProtoAztecBlockResp} message ProtoAztecBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoAztecBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoAztecBlockResp message, length delimited. Does not implicitly {@link mini.ProtoAztecBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoAztecBlockResp
         * @static
         * @param {mini.IProtoAztecBlockResp} message ProtoAztecBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoAztecBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoAztecBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoAztecBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoAztecBlockResp} ProtoAztecBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoAztecBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoAztecBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoAztecBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoAztecBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoAztecBlockResp} ProtoAztecBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoAztecBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoAztecBlockResp message.
         * @function verify
         * @memberof mini.ProtoAztecBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoAztecBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoAztecBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoAztecBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoAztecBlockResp} ProtoAztecBlockResp
         */
        ProtoAztecBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoAztecBlockResp)
                return object;
            let message = new $root.mini.ProtoAztecBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoAztecBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoAztecBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoAztecBlockResp
         * @static
         * @param {mini.ProtoAztecBlockResp} message ProtoAztecBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoAztecBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoAztecBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoAztecBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoAztecBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoAztecBlockResp;
    })();

    mini.ProtoAztecGameStartReq = (function() {

        /**
         * Properties of a ProtoAztecGameStartReq.
         * @memberof mini
         * @interface IProtoAztecGameStartReq
         * @property {number|null} [score] ProtoAztecGameStartReq score
         * @property {number|null} [type] ProtoAztecGameStartReq type
         * @property {number|null} [area] ProtoAztecGameStartReq area
         * @property {number|null} [buff] ProtoAztecGameStartReq buff
         */

        /**
         * Constructs a new ProtoAztecGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoAztecGameStartReq.
         * @implements IProtoAztecGameStartReq
         * @constructor
         * @param {mini.IProtoAztecGameStartReq=} [properties] Properties to set
         */
        function ProtoAztecGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoAztecGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoAztecGameStartReq
         * @instance
         */
        ProtoAztecGameStartReq.prototype.score = 0;

        /**
         * ProtoAztecGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoAztecGameStartReq
         * @instance
         */
        ProtoAztecGameStartReq.prototype.type = 0;

        /**
         * ProtoAztecGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoAztecGameStartReq
         * @instance
         */
        ProtoAztecGameStartReq.prototype.area = 0;

        /**
         * ProtoAztecGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoAztecGameStartReq
         * @instance
         */
        ProtoAztecGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoAztecGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoAztecGameStartReq
         * @static
         * @param {mini.IProtoAztecGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoAztecGameStartReq} ProtoAztecGameStartReq instance
         */
        ProtoAztecGameStartReq.create = function create(properties) {
            return new ProtoAztecGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoAztecGameStartReq message. Does not implicitly {@link mini.ProtoAztecGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoAztecGameStartReq
         * @static
         * @param {mini.IProtoAztecGameStartReq} message ProtoAztecGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoAztecGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoAztecGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoAztecGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoAztecGameStartReq
         * @static
         * @param {mini.IProtoAztecGameStartReq} message ProtoAztecGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoAztecGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoAztecGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoAztecGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoAztecGameStartReq} ProtoAztecGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoAztecGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoAztecGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoAztecGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoAztecGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoAztecGameStartReq} ProtoAztecGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoAztecGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoAztecGameStartReq message.
         * @function verify
         * @memberof mini.ProtoAztecGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoAztecGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoAztecGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoAztecGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoAztecGameStartReq} ProtoAztecGameStartReq
         */
        ProtoAztecGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoAztecGameStartReq)
                return object;
            let message = new $root.mini.ProtoAztecGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoAztecGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoAztecGameStartReq
         * @static
         * @param {mini.ProtoAztecGameStartReq} message ProtoAztecGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoAztecGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoAztecGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoAztecGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoAztecGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoAztecGameStartReq;
    })();

    mini.ProtoAztecGameStartResp = (function() {

        /**
         * Properties of a ProtoAztecGameStartResp.
         * @memberof mini
         * @interface IProtoAztecGameStartResp
         * @property {number|null} [stage2Count] ProtoAztecGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoAztecGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoAztecGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoAztecGameStartResp itemInfo
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoAztecGameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [freeResult] ProtoAztecGameStartResp freeResult
         * @property {string|null} [gameID] ProtoAztecGameStartResp gameID
         * @property {string|null} [buff] ProtoAztecGameStartResp buff
         * @property {string|null} [area] ProtoAztecGameStartResp area
         * @property {number|null} [per] ProtoAztecGameStartResp per
         * @property {number|null} [errorCode] ProtoAztecGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoAztecGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoAztecGameStartResp.
         * @implements IProtoAztecGameStartResp
         * @constructor
         * @param {mini.IProtoAztecGameStartResp=} [properties] Properties to set
         */
        function ProtoAztecGameStartResp(properties) {
            this.itemInfo = [];
            this.lineItem = [];
            this.freeResult = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoAztecGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoAztecGameStartResp
         * @instance
         */
        ProtoAztecGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoAztecGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoAztecGameStartResp
         * @instance
         */
        ProtoAztecGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoAztecGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoAztecGameStartResp
         * @instance
         */
        ProtoAztecGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoAztecGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoAztecGameStartResp
         * @instance
         */
        ProtoAztecGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoAztecGameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoAztecGameStartResp
         * @instance
         */
        ProtoAztecGameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoAztecGameStartResp freeResult.
         * @member {Array.<mini.IFreeSpin>} freeResult
         * @memberof mini.ProtoAztecGameStartResp
         * @instance
         */
        ProtoAztecGameStartResp.prototype.freeResult = $util.emptyArray;

        /**
         * ProtoAztecGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoAztecGameStartResp
         * @instance
         */
        ProtoAztecGameStartResp.prototype.gameID = "";

        /**
         * ProtoAztecGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoAztecGameStartResp
         * @instance
         */
        ProtoAztecGameStartResp.prototype.buff = "";

        /**
         * ProtoAztecGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoAztecGameStartResp
         * @instance
         */
        ProtoAztecGameStartResp.prototype.area = "";

        /**
         * ProtoAztecGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoAztecGameStartResp
         * @instance
         */
        ProtoAztecGameStartResp.prototype.per = 0;

        /**
         * ProtoAztecGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoAztecGameStartResp
         * @instance
         */
        ProtoAztecGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoAztecGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoAztecGameStartResp
         * @static
         * @param {mini.IProtoAztecGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoAztecGameStartResp} ProtoAztecGameStartResp instance
         */
        ProtoAztecGameStartResp.create = function create(properties) {
            return new ProtoAztecGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoAztecGameStartResp message. Does not implicitly {@link mini.ProtoAztecGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoAztecGameStartResp
         * @static
         * @param {mini.IProtoAztecGameStartResp} message ProtoAztecGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoAztecGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.freeResult != null && message.freeResult.length)
                for (let i = 0; i < message.freeResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.freeResult[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.per);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoAztecGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoAztecGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoAztecGameStartResp
         * @static
         * @param {mini.IProtoAztecGameStartResp} message ProtoAztecGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoAztecGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoAztecGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoAztecGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoAztecGameStartResp} ProtoAztecGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoAztecGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoAztecGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.freeResult && message.freeResult.length))
                        message.freeResult = [];
                    message.freeResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.gameID = reader.string();
                    break;
                case 8:
                    message.buff = reader.string();
                    break;
                case 9:
                    message.area = reader.string();
                    break;
                case 10:
                    message.per = reader.uint32();
                    break;
                case 11:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoAztecGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoAztecGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoAztecGameStartResp} ProtoAztecGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoAztecGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoAztecGameStartResp message.
         * @function verify
         * @memberof mini.ProtoAztecGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoAztecGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.freeResult != null && message.hasOwnProperty("freeResult")) {
                if (!Array.isArray(message.freeResult))
                    return "freeResult: array expected";
                for (let i = 0; i < message.freeResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.freeResult[i]);
                    if (error)
                        return "freeResult." + error;
                }
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoAztecGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoAztecGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoAztecGameStartResp} ProtoAztecGameStartResp
         */
        ProtoAztecGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoAztecGameStartResp)
                return object;
            let message = new $root.mini.ProtoAztecGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoAztecGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoAztecGameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoAztecGameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.freeResult) {
                if (!Array.isArray(object.freeResult))
                    throw TypeError(".mini.ProtoAztecGameStartResp.freeResult: array expected");
                message.freeResult = [];
                for (let i = 0; i < object.freeResult.length; ++i) {
                    if (typeof object.freeResult[i] !== "object")
                        throw TypeError(".mini.ProtoAztecGameStartResp.freeResult: object expected");
                    message.freeResult[i] = $root.mini.FreeSpin.fromObject(object.freeResult[i]);
                }
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoAztecGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoAztecGameStartResp
         * @static
         * @param {mini.ProtoAztecGameStartResp} message ProtoAztecGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoAztecGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.lineItem = [];
                object.freeResult = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.freeResult && message.freeResult.length) {
                object.freeResult = [];
                for (let j = 0; j < message.freeResult.length; ++j)
                    object.freeResult[j] = $root.mini.FreeSpin.toObject(message.freeResult[j], options);
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoAztecGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoAztecGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoAztecGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoAztecGameStartResp;
    })();

    mini.ProtoJlbBlockReq = (function() {

        /**
         * Properties of a ProtoJlbBlockReq.
         * @memberof mini
         * @interface IProtoJlbBlockReq
         * @property {number|null} [gameType] ProtoJlbBlockReq gameType
         */

        /**
         * Constructs a new ProtoJlbBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoJlbBlockReq.
         * @implements IProtoJlbBlockReq
         * @constructor
         * @param {mini.IProtoJlbBlockReq=} [properties] Properties to set
         */
        function ProtoJlbBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoJlbBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoJlbBlockReq
         * @instance
         */
        ProtoJlbBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoJlbBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoJlbBlockReq
         * @static
         * @param {mini.IProtoJlbBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoJlbBlockReq} ProtoJlbBlockReq instance
         */
        ProtoJlbBlockReq.create = function create(properties) {
            return new ProtoJlbBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoJlbBlockReq message. Does not implicitly {@link mini.ProtoJlbBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoJlbBlockReq
         * @static
         * @param {mini.IProtoJlbBlockReq} message ProtoJlbBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoJlbBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoJlbBlockReq message, length delimited. Does not implicitly {@link mini.ProtoJlbBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoJlbBlockReq
         * @static
         * @param {mini.IProtoJlbBlockReq} message ProtoJlbBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoJlbBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoJlbBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoJlbBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoJlbBlockReq} ProtoJlbBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoJlbBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoJlbBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoJlbBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoJlbBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoJlbBlockReq} ProtoJlbBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoJlbBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoJlbBlockReq message.
         * @function verify
         * @memberof mini.ProtoJlbBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoJlbBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoJlbBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoJlbBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoJlbBlockReq} ProtoJlbBlockReq
         */
        ProtoJlbBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoJlbBlockReq)
                return object;
            let message = new $root.mini.ProtoJlbBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoJlbBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoJlbBlockReq
         * @static
         * @param {mini.ProtoJlbBlockReq} message ProtoJlbBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoJlbBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoJlbBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoJlbBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoJlbBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoJlbBlockReq;
    })();

    mini.ProtoJlbBlockResp = (function() {

        /**
         * Properties of a ProtoJlbBlockResp.
         * @memberof mini
         * @interface IProtoJlbBlockResp
         * @property {Array.<number>|null} [block] ProtoJlbBlockResp block
         */

        /**
         * Constructs a new ProtoJlbBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoJlbBlockResp.
         * @implements IProtoJlbBlockResp
         * @constructor
         * @param {mini.IProtoJlbBlockResp=} [properties] Properties to set
         */
        function ProtoJlbBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoJlbBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoJlbBlockResp
         * @instance
         */
        ProtoJlbBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoJlbBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoJlbBlockResp
         * @static
         * @param {mini.IProtoJlbBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoJlbBlockResp} ProtoJlbBlockResp instance
         */
        ProtoJlbBlockResp.create = function create(properties) {
            return new ProtoJlbBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoJlbBlockResp message. Does not implicitly {@link mini.ProtoJlbBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoJlbBlockResp
         * @static
         * @param {mini.IProtoJlbBlockResp} message ProtoJlbBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoJlbBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoJlbBlockResp message, length delimited. Does not implicitly {@link mini.ProtoJlbBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoJlbBlockResp
         * @static
         * @param {mini.IProtoJlbBlockResp} message ProtoJlbBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoJlbBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoJlbBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoJlbBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoJlbBlockResp} ProtoJlbBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoJlbBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoJlbBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoJlbBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoJlbBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoJlbBlockResp} ProtoJlbBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoJlbBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoJlbBlockResp message.
         * @function verify
         * @memberof mini.ProtoJlbBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoJlbBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoJlbBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoJlbBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoJlbBlockResp} ProtoJlbBlockResp
         */
        ProtoJlbBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoJlbBlockResp)
                return object;
            let message = new $root.mini.ProtoJlbBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoJlbBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoJlbBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoJlbBlockResp
         * @static
         * @param {mini.ProtoJlbBlockResp} message ProtoJlbBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoJlbBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoJlbBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoJlbBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoJlbBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoJlbBlockResp;
    })();

    mini.ProtoJlbGameStartReq = (function() {

        /**
         * Properties of a ProtoJlbGameStartReq.
         * @memberof mini
         * @interface IProtoJlbGameStartReq
         * @property {number|null} [score] ProtoJlbGameStartReq score
         * @property {number|null} [type] ProtoJlbGameStartReq type
         * @property {number|null} [area] ProtoJlbGameStartReq area
         * @property {number|null} [buff] ProtoJlbGameStartReq buff
         */

        /**
         * Constructs a new ProtoJlbGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoJlbGameStartReq.
         * @implements IProtoJlbGameStartReq
         * @constructor
         * @param {mini.IProtoJlbGameStartReq=} [properties] Properties to set
         */
        function ProtoJlbGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoJlbGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoJlbGameStartReq
         * @instance
         */
        ProtoJlbGameStartReq.prototype.score = 0;

        /**
         * ProtoJlbGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoJlbGameStartReq
         * @instance
         */
        ProtoJlbGameStartReq.prototype.type = 0;

        /**
         * ProtoJlbGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoJlbGameStartReq
         * @instance
         */
        ProtoJlbGameStartReq.prototype.area = 0;

        /**
         * ProtoJlbGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoJlbGameStartReq
         * @instance
         */
        ProtoJlbGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoJlbGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoJlbGameStartReq
         * @static
         * @param {mini.IProtoJlbGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoJlbGameStartReq} ProtoJlbGameStartReq instance
         */
        ProtoJlbGameStartReq.create = function create(properties) {
            return new ProtoJlbGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoJlbGameStartReq message. Does not implicitly {@link mini.ProtoJlbGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoJlbGameStartReq
         * @static
         * @param {mini.IProtoJlbGameStartReq} message ProtoJlbGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoJlbGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoJlbGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoJlbGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoJlbGameStartReq
         * @static
         * @param {mini.IProtoJlbGameStartReq} message ProtoJlbGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoJlbGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoJlbGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoJlbGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoJlbGameStartReq} ProtoJlbGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoJlbGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoJlbGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoJlbGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoJlbGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoJlbGameStartReq} ProtoJlbGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoJlbGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoJlbGameStartReq message.
         * @function verify
         * @memberof mini.ProtoJlbGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoJlbGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoJlbGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoJlbGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoJlbGameStartReq} ProtoJlbGameStartReq
         */
        ProtoJlbGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoJlbGameStartReq)
                return object;
            let message = new $root.mini.ProtoJlbGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoJlbGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoJlbGameStartReq
         * @static
         * @param {mini.ProtoJlbGameStartReq} message ProtoJlbGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoJlbGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoJlbGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoJlbGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoJlbGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoJlbGameStartReq;
    })();

    mini.ProtoJlbGameStartResp = (function() {

        /**
         * Properties of a ProtoJlbGameStartResp.
         * @memberof mini
         * @interface IProtoJlbGameStartResp
         * @property {number|null} [stage2Count] ProtoJlbGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoJlbGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoJlbGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoJlbGameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoJlbGameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoJlbGameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [freeResult] ProtoJlbGameStartResp freeResult
         * @property {Array.<mini.IFreeSpin>|null} [superResult] ProtoJlbGameStartResp superResult
         * @property {string|null} [gameID] ProtoJlbGameStartResp gameID
         * @property {string|null} [buff] ProtoJlbGameStartResp buff
         * @property {string|null} [area] ProtoJlbGameStartResp area
         * @property {number|null} [per] ProtoJlbGameStartResp per
         * @property {number|null} [errorCode] ProtoJlbGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoJlbGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoJlbGameStartResp.
         * @implements IProtoJlbGameStartResp
         * @constructor
         * @param {mini.IProtoJlbGameStartResp=} [properties] Properties to set
         */
        function ProtoJlbGameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.freeResult = [];
            this.superResult = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoJlbGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoJlbGameStartResp
         * @instance
         */
        ProtoJlbGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoJlbGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoJlbGameStartResp
         * @instance
         */
        ProtoJlbGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoJlbGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoJlbGameStartResp
         * @instance
         */
        ProtoJlbGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoJlbGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoJlbGameStartResp
         * @instance
         */
        ProtoJlbGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoJlbGameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoJlbGameStartResp
         * @instance
         */
        ProtoJlbGameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoJlbGameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoJlbGameStartResp
         * @instance
         */
        ProtoJlbGameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoJlbGameStartResp freeResult.
         * @member {Array.<mini.IFreeSpin>} freeResult
         * @memberof mini.ProtoJlbGameStartResp
         * @instance
         */
        ProtoJlbGameStartResp.prototype.freeResult = $util.emptyArray;

        /**
         * ProtoJlbGameStartResp superResult.
         * @member {Array.<mini.IFreeSpin>} superResult
         * @memberof mini.ProtoJlbGameStartResp
         * @instance
         */
        ProtoJlbGameStartResp.prototype.superResult = $util.emptyArray;

        /**
         * ProtoJlbGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoJlbGameStartResp
         * @instance
         */
        ProtoJlbGameStartResp.prototype.gameID = "";

        /**
         * ProtoJlbGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoJlbGameStartResp
         * @instance
         */
        ProtoJlbGameStartResp.prototype.buff = "";

        /**
         * ProtoJlbGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoJlbGameStartResp
         * @instance
         */
        ProtoJlbGameStartResp.prototype.area = "";

        /**
         * ProtoJlbGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoJlbGameStartResp
         * @instance
         */
        ProtoJlbGameStartResp.prototype.per = 0;

        /**
         * ProtoJlbGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoJlbGameStartResp
         * @instance
         */
        ProtoJlbGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoJlbGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoJlbGameStartResp
         * @static
         * @param {mini.IProtoJlbGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoJlbGameStartResp} ProtoJlbGameStartResp instance
         */
        ProtoJlbGameStartResp.create = function create(properties) {
            return new ProtoJlbGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoJlbGameStartResp message. Does not implicitly {@link mini.ProtoJlbGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoJlbGameStartResp
         * @static
         * @param {mini.IProtoJlbGameStartResp} message ProtoJlbGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoJlbGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.freeResult != null && message.freeResult.length)
                for (let i = 0; i < message.freeResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.freeResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.superResult != null && message.superResult.length)
                for (let i = 0; i < message.superResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.superResult[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.per);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoJlbGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoJlbGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoJlbGameStartResp
         * @static
         * @param {mini.IProtoJlbGameStartResp} message ProtoJlbGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoJlbGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoJlbGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoJlbGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoJlbGameStartResp} ProtoJlbGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoJlbGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoJlbGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.freeResult && message.freeResult.length))
                        message.freeResult = [];
                    message.freeResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.superResult && message.superResult.length))
                        message.superResult = [];
                    message.superResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.gameID = reader.string();
                    break;
                case 10:
                    message.buff = reader.string();
                    break;
                case 11:
                    message.area = reader.string();
                    break;
                case 12:
                    message.per = reader.uint32();
                    break;
                case 13:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoJlbGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoJlbGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoJlbGameStartResp} ProtoJlbGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoJlbGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoJlbGameStartResp message.
         * @function verify
         * @memberof mini.ProtoJlbGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoJlbGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.freeResult != null && message.hasOwnProperty("freeResult")) {
                if (!Array.isArray(message.freeResult))
                    return "freeResult: array expected";
                for (let i = 0; i < message.freeResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.freeResult[i]);
                    if (error)
                        return "freeResult." + error;
                }
            }
            if (message.superResult != null && message.hasOwnProperty("superResult")) {
                if (!Array.isArray(message.superResult))
                    return "superResult: array expected";
                for (let i = 0; i < message.superResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.superResult[i]);
                    if (error)
                        return "superResult." + error;
                }
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoJlbGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoJlbGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoJlbGameStartResp} ProtoJlbGameStartResp
         */
        ProtoJlbGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoJlbGameStartResp)
                return object;
            let message = new $root.mini.ProtoJlbGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoJlbGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoJlbGameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoJlbGameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoJlbGameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.freeResult) {
                if (!Array.isArray(object.freeResult))
                    throw TypeError(".mini.ProtoJlbGameStartResp.freeResult: array expected");
                message.freeResult = [];
                for (let i = 0; i < object.freeResult.length; ++i) {
                    if (typeof object.freeResult[i] !== "object")
                        throw TypeError(".mini.ProtoJlbGameStartResp.freeResult: object expected");
                    message.freeResult[i] = $root.mini.FreeSpin.fromObject(object.freeResult[i]);
                }
            }
            if (object.superResult) {
                if (!Array.isArray(object.superResult))
                    throw TypeError(".mini.ProtoJlbGameStartResp.superResult: array expected");
                message.superResult = [];
                for (let i = 0; i < object.superResult.length; ++i) {
                    if (typeof object.superResult[i] !== "object")
                        throw TypeError(".mini.ProtoJlbGameStartResp.superResult: object expected");
                    message.superResult[i] = $root.mini.FreeSpin.fromObject(object.superResult[i]);
                }
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoJlbGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoJlbGameStartResp
         * @static
         * @param {mini.ProtoJlbGameStartResp} message ProtoJlbGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoJlbGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.freeResult = [];
                object.superResult = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.freeResult && message.freeResult.length) {
                object.freeResult = [];
                for (let j = 0; j < message.freeResult.length; ++j)
                    object.freeResult[j] = $root.mini.FreeSpin.toObject(message.freeResult[j], options);
            }
            if (message.superResult && message.superResult.length) {
                object.superResult = [];
                for (let j = 0; j < message.superResult.length; ++j)
                    object.superResult[j] = $root.mini.FreeSpin.toObject(message.superResult[j], options);
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoJlbGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoJlbGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoJlbGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoJlbGameStartResp;
    })();

    mini.ProtoDragonBlockReq = (function() {

        /**
         * Properties of a ProtoDragonBlockReq.
         * @memberof mini
         * @interface IProtoDragonBlockReq
         * @property {number|null} [gameType] ProtoDragonBlockReq gameType
         */

        /**
         * Constructs a new ProtoDragonBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoDragonBlockReq.
         * @implements IProtoDragonBlockReq
         * @constructor
         * @param {mini.IProtoDragonBlockReq=} [properties] Properties to set
         */
        function ProtoDragonBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoDragonBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoDragonBlockReq
         * @instance
         */
        ProtoDragonBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoDragonBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoDragonBlockReq
         * @static
         * @param {mini.IProtoDragonBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoDragonBlockReq} ProtoDragonBlockReq instance
         */
        ProtoDragonBlockReq.create = function create(properties) {
            return new ProtoDragonBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoDragonBlockReq message. Does not implicitly {@link mini.ProtoDragonBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoDragonBlockReq
         * @static
         * @param {mini.IProtoDragonBlockReq} message ProtoDragonBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoDragonBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoDragonBlockReq message, length delimited. Does not implicitly {@link mini.ProtoDragonBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoDragonBlockReq
         * @static
         * @param {mini.IProtoDragonBlockReq} message ProtoDragonBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoDragonBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoDragonBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoDragonBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoDragonBlockReq} ProtoDragonBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoDragonBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoDragonBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoDragonBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoDragonBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoDragonBlockReq} ProtoDragonBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoDragonBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoDragonBlockReq message.
         * @function verify
         * @memberof mini.ProtoDragonBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoDragonBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoDragonBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoDragonBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoDragonBlockReq} ProtoDragonBlockReq
         */
        ProtoDragonBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoDragonBlockReq)
                return object;
            let message = new $root.mini.ProtoDragonBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoDragonBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoDragonBlockReq
         * @static
         * @param {mini.ProtoDragonBlockReq} message ProtoDragonBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoDragonBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoDragonBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoDragonBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoDragonBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoDragonBlockReq;
    })();

    mini.ProtoDragonBlockResp = (function() {

        /**
         * Properties of a ProtoDragonBlockResp.
         * @memberof mini
         * @interface IProtoDragonBlockResp
         * @property {Array.<number>|null} [block] ProtoDragonBlockResp block
         */

        /**
         * Constructs a new ProtoDragonBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoDragonBlockResp.
         * @implements IProtoDragonBlockResp
         * @constructor
         * @param {mini.IProtoDragonBlockResp=} [properties] Properties to set
         */
        function ProtoDragonBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoDragonBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoDragonBlockResp
         * @instance
         */
        ProtoDragonBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoDragonBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoDragonBlockResp
         * @static
         * @param {mini.IProtoDragonBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoDragonBlockResp} ProtoDragonBlockResp instance
         */
        ProtoDragonBlockResp.create = function create(properties) {
            return new ProtoDragonBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoDragonBlockResp message. Does not implicitly {@link mini.ProtoDragonBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoDragonBlockResp
         * @static
         * @param {mini.IProtoDragonBlockResp} message ProtoDragonBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoDragonBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoDragonBlockResp message, length delimited. Does not implicitly {@link mini.ProtoDragonBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoDragonBlockResp
         * @static
         * @param {mini.IProtoDragonBlockResp} message ProtoDragonBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoDragonBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoDragonBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoDragonBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoDragonBlockResp} ProtoDragonBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoDragonBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoDragonBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoDragonBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoDragonBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoDragonBlockResp} ProtoDragonBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoDragonBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoDragonBlockResp message.
         * @function verify
         * @memberof mini.ProtoDragonBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoDragonBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoDragonBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoDragonBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoDragonBlockResp} ProtoDragonBlockResp
         */
        ProtoDragonBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoDragonBlockResp)
                return object;
            let message = new $root.mini.ProtoDragonBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoDragonBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoDragonBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoDragonBlockResp
         * @static
         * @param {mini.ProtoDragonBlockResp} message ProtoDragonBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoDragonBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoDragonBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoDragonBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoDragonBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoDragonBlockResp;
    })();

    mini.ProtoDragonGameStartReq = (function() {

        /**
         * Properties of a ProtoDragonGameStartReq.
         * @memberof mini
         * @interface IProtoDragonGameStartReq
         * @property {number|null} [score] ProtoDragonGameStartReq score
         * @property {number|null} [type] ProtoDragonGameStartReq type
         * @property {number|null} [area] ProtoDragonGameStartReq area
         * @property {number|null} [buff] ProtoDragonGameStartReq buff
         */

        /**
         * Constructs a new ProtoDragonGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoDragonGameStartReq.
         * @implements IProtoDragonGameStartReq
         * @constructor
         * @param {mini.IProtoDragonGameStartReq=} [properties] Properties to set
         */
        function ProtoDragonGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoDragonGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoDragonGameStartReq
         * @instance
         */
        ProtoDragonGameStartReq.prototype.score = 0;

        /**
         * ProtoDragonGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoDragonGameStartReq
         * @instance
         */
        ProtoDragonGameStartReq.prototype.type = 0;

        /**
         * ProtoDragonGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoDragonGameStartReq
         * @instance
         */
        ProtoDragonGameStartReq.prototype.area = 0;

        /**
         * ProtoDragonGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoDragonGameStartReq
         * @instance
         */
        ProtoDragonGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoDragonGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoDragonGameStartReq
         * @static
         * @param {mini.IProtoDragonGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoDragonGameStartReq} ProtoDragonGameStartReq instance
         */
        ProtoDragonGameStartReq.create = function create(properties) {
            return new ProtoDragonGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoDragonGameStartReq message. Does not implicitly {@link mini.ProtoDragonGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoDragonGameStartReq
         * @static
         * @param {mini.IProtoDragonGameStartReq} message ProtoDragonGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoDragonGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoDragonGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoDragonGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoDragonGameStartReq
         * @static
         * @param {mini.IProtoDragonGameStartReq} message ProtoDragonGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoDragonGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoDragonGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoDragonGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoDragonGameStartReq} ProtoDragonGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoDragonGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoDragonGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoDragonGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoDragonGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoDragonGameStartReq} ProtoDragonGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoDragonGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoDragonGameStartReq message.
         * @function verify
         * @memberof mini.ProtoDragonGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoDragonGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoDragonGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoDragonGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoDragonGameStartReq} ProtoDragonGameStartReq
         */
        ProtoDragonGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoDragonGameStartReq)
                return object;
            let message = new $root.mini.ProtoDragonGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoDragonGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoDragonGameStartReq
         * @static
         * @param {mini.ProtoDragonGameStartReq} message ProtoDragonGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoDragonGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoDragonGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoDragonGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoDragonGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoDragonGameStartReq;
    })();

    mini.ProtoDragonGameStartResp = (function() {

        /**
         * Properties of a ProtoDragonGameStartResp.
         * @memberof mini
         * @interface IProtoDragonGameStartResp
         * @property {number|null} [stage2Count] ProtoDragonGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoDragonGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoDragonGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoDragonGameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoDragonGameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoDragonGameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [freeResult] ProtoDragonGameStartResp freeResult
         * @property {Array.<mini.IFreeSpin>|null} [superResult] ProtoDragonGameStartResp superResult
         * @property {string|null} [gameID] ProtoDragonGameStartResp gameID
         * @property {string|null} [buff] ProtoDragonGameStartResp buff
         * @property {string|null} [area] ProtoDragonGameStartResp area
         * @property {number|null} [per] ProtoDragonGameStartResp per
         * @property {number|null} [errorCode] ProtoDragonGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoDragonGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoDragonGameStartResp.
         * @implements IProtoDragonGameStartResp
         * @constructor
         * @param {mini.IProtoDragonGameStartResp=} [properties] Properties to set
         */
        function ProtoDragonGameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.freeResult = [];
            this.superResult = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoDragonGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoDragonGameStartResp
         * @instance
         */
        ProtoDragonGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoDragonGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoDragonGameStartResp
         * @instance
         */
        ProtoDragonGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoDragonGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoDragonGameStartResp
         * @instance
         */
        ProtoDragonGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoDragonGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoDragonGameStartResp
         * @instance
         */
        ProtoDragonGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoDragonGameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoDragonGameStartResp
         * @instance
         */
        ProtoDragonGameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoDragonGameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoDragonGameStartResp
         * @instance
         */
        ProtoDragonGameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoDragonGameStartResp freeResult.
         * @member {Array.<mini.IFreeSpin>} freeResult
         * @memberof mini.ProtoDragonGameStartResp
         * @instance
         */
        ProtoDragonGameStartResp.prototype.freeResult = $util.emptyArray;

        /**
         * ProtoDragonGameStartResp superResult.
         * @member {Array.<mini.IFreeSpin>} superResult
         * @memberof mini.ProtoDragonGameStartResp
         * @instance
         */
        ProtoDragonGameStartResp.prototype.superResult = $util.emptyArray;

        /**
         * ProtoDragonGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoDragonGameStartResp
         * @instance
         */
        ProtoDragonGameStartResp.prototype.gameID = "";

        /**
         * ProtoDragonGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoDragonGameStartResp
         * @instance
         */
        ProtoDragonGameStartResp.prototype.buff = "";

        /**
         * ProtoDragonGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoDragonGameStartResp
         * @instance
         */
        ProtoDragonGameStartResp.prototype.area = "";

        /**
         * ProtoDragonGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoDragonGameStartResp
         * @instance
         */
        ProtoDragonGameStartResp.prototype.per = 0;

        /**
         * ProtoDragonGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoDragonGameStartResp
         * @instance
         */
        ProtoDragonGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoDragonGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoDragonGameStartResp
         * @static
         * @param {mini.IProtoDragonGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoDragonGameStartResp} ProtoDragonGameStartResp instance
         */
        ProtoDragonGameStartResp.create = function create(properties) {
            return new ProtoDragonGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoDragonGameStartResp message. Does not implicitly {@link mini.ProtoDragonGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoDragonGameStartResp
         * @static
         * @param {mini.IProtoDragonGameStartResp} message ProtoDragonGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoDragonGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.freeResult != null && message.freeResult.length)
                for (let i = 0; i < message.freeResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.freeResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.superResult != null && message.superResult.length)
                for (let i = 0; i < message.superResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.superResult[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.per);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoDragonGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoDragonGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoDragonGameStartResp
         * @static
         * @param {mini.IProtoDragonGameStartResp} message ProtoDragonGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoDragonGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoDragonGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoDragonGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoDragonGameStartResp} ProtoDragonGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoDragonGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoDragonGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.freeResult && message.freeResult.length))
                        message.freeResult = [];
                    message.freeResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.superResult && message.superResult.length))
                        message.superResult = [];
                    message.superResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.gameID = reader.string();
                    break;
                case 10:
                    message.buff = reader.string();
                    break;
                case 11:
                    message.area = reader.string();
                    break;
                case 12:
                    message.per = reader.uint32();
                    break;
                case 13:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoDragonGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoDragonGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoDragonGameStartResp} ProtoDragonGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoDragonGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoDragonGameStartResp message.
         * @function verify
         * @memberof mini.ProtoDragonGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoDragonGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.freeResult != null && message.hasOwnProperty("freeResult")) {
                if (!Array.isArray(message.freeResult))
                    return "freeResult: array expected";
                for (let i = 0; i < message.freeResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.freeResult[i]);
                    if (error)
                        return "freeResult." + error;
                }
            }
            if (message.superResult != null && message.hasOwnProperty("superResult")) {
                if (!Array.isArray(message.superResult))
                    return "superResult: array expected";
                for (let i = 0; i < message.superResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.superResult[i]);
                    if (error)
                        return "superResult." + error;
                }
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoDragonGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoDragonGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoDragonGameStartResp} ProtoDragonGameStartResp
         */
        ProtoDragonGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoDragonGameStartResp)
                return object;
            let message = new $root.mini.ProtoDragonGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoDragonGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoDragonGameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoDragonGameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoDragonGameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.freeResult) {
                if (!Array.isArray(object.freeResult))
                    throw TypeError(".mini.ProtoDragonGameStartResp.freeResult: array expected");
                message.freeResult = [];
                for (let i = 0; i < object.freeResult.length; ++i) {
                    if (typeof object.freeResult[i] !== "object")
                        throw TypeError(".mini.ProtoDragonGameStartResp.freeResult: object expected");
                    message.freeResult[i] = $root.mini.FreeSpin.fromObject(object.freeResult[i]);
                }
            }
            if (object.superResult) {
                if (!Array.isArray(object.superResult))
                    throw TypeError(".mini.ProtoDragonGameStartResp.superResult: array expected");
                message.superResult = [];
                for (let i = 0; i < object.superResult.length; ++i) {
                    if (typeof object.superResult[i] !== "object")
                        throw TypeError(".mini.ProtoDragonGameStartResp.superResult: object expected");
                    message.superResult[i] = $root.mini.FreeSpin.fromObject(object.superResult[i]);
                }
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoDragonGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoDragonGameStartResp
         * @static
         * @param {mini.ProtoDragonGameStartResp} message ProtoDragonGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoDragonGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.freeResult = [];
                object.superResult = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.freeResult && message.freeResult.length) {
                object.freeResult = [];
                for (let j = 0; j < message.freeResult.length; ++j)
                    object.freeResult[j] = $root.mini.FreeSpin.toObject(message.freeResult[j], options);
            }
            if (message.superResult && message.superResult.length) {
                object.superResult = [];
                for (let j = 0; j < message.superResult.length; ++j)
                    object.superResult[j] = $root.mini.FreeSpin.toObject(message.superResult[j], options);
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoDragonGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoDragonGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoDragonGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoDragonGameStartResp;
    })();

    mini.ProtoSlotStateResp = (function() {

        /**
         * Properties of a ProtoSlotStateResp.
         * @memberof mini
         * @interface IProtoSlotStateResp
         * @property {Array.<number>|null} [initMap] ProtoSlotStateResp initMap
         * @property {number|null} [availableBalance] ProtoSlotStateResp availableBalance
         * @property {string|null} [params] ProtoSlotStateResp params
         * @property {number|null} [win] ProtoSlotStateResp win
         * @property {Array.<number>|null} [jackpot] ProtoSlotStateResp jackpot
         */

        /**
         * Constructs a new ProtoSlotStateResp.
         * @memberof mini
         * @classdesc Represents a ProtoSlotStateResp.
         * @implements IProtoSlotStateResp
         * @constructor
         * @param {mini.IProtoSlotStateResp=} [properties] Properties to set
         */
        function ProtoSlotStateResp(properties) {
            this.initMap = [];
            this.jackpot = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoSlotStateResp initMap.
         * @member {Array.<number>} initMap
         * @memberof mini.ProtoSlotStateResp
         * @instance
         */
        ProtoSlotStateResp.prototype.initMap = $util.emptyArray;

        /**
         * ProtoSlotStateResp availableBalance.
         * @member {number} availableBalance
         * @memberof mini.ProtoSlotStateResp
         * @instance
         */
        ProtoSlotStateResp.prototype.availableBalance = 0;

        /**
         * ProtoSlotStateResp params.
         * @member {string} params
         * @memberof mini.ProtoSlotStateResp
         * @instance
         */
        ProtoSlotStateResp.prototype.params = "";

        /**
         * ProtoSlotStateResp win.
         * @member {number} win
         * @memberof mini.ProtoSlotStateResp
         * @instance
         */
        ProtoSlotStateResp.prototype.win = 0;

        /**
         * ProtoSlotStateResp jackpot.
         * @member {Array.<number>} jackpot
         * @memberof mini.ProtoSlotStateResp
         * @instance
         */
        ProtoSlotStateResp.prototype.jackpot = $util.emptyArray;

        /**
         * Creates a new ProtoSlotStateResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoSlotStateResp
         * @static
         * @param {mini.IProtoSlotStateResp=} [properties] Properties to set
         * @returns {mini.ProtoSlotStateResp} ProtoSlotStateResp instance
         */
        ProtoSlotStateResp.create = function create(properties) {
            return new ProtoSlotStateResp(properties);
        };

        /**
         * Encodes the specified ProtoSlotStateResp message. Does not implicitly {@link mini.ProtoSlotStateResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoSlotStateResp
         * @static
         * @param {mini.IProtoSlotStateResp} message ProtoSlotStateResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSlotStateResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.initMap != null && message.initMap.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.initMap.length; ++i)
                    writer.int32(message.initMap[i]);
                writer.ldelim();
            }
            if (message.availableBalance != null && Object.hasOwnProperty.call(message, "availableBalance"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.availableBalance);
            if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.params);
            if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.win);
            if (message.jackpot != null && message.jackpot.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.jackpot.length; ++i)
                    writer.uint32(message.jackpot[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoSlotStateResp message, length delimited. Does not implicitly {@link mini.ProtoSlotStateResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoSlotStateResp
         * @static
         * @param {mini.IProtoSlotStateResp} message ProtoSlotStateResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSlotStateResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoSlotStateResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoSlotStateResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoSlotStateResp} ProtoSlotStateResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSlotStateResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoSlotStateResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.initMap && message.initMap.length))
                        message.initMap = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.initMap.push(reader.int32());
                    } else
                        message.initMap.push(reader.int32());
                    break;
                case 2:
                    message.availableBalance = reader.int32();
                    break;
                case 3:
                    message.params = reader.string();
                    break;
                case 4:
                    message.win = reader.int32();
                    break;
                case 5:
                    if (!(message.jackpot && message.jackpot.length))
                        message.jackpot = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.jackpot.push(reader.uint32());
                    } else
                        message.jackpot.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoSlotStateResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoSlotStateResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoSlotStateResp} ProtoSlotStateResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSlotStateResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoSlotStateResp message.
         * @function verify
         * @memberof mini.ProtoSlotStateResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoSlotStateResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.initMap != null && message.hasOwnProperty("initMap")) {
                if (!Array.isArray(message.initMap))
                    return "initMap: array expected";
                for (let i = 0; i < message.initMap.length; ++i)
                    if (!$util.isInteger(message.initMap[i]))
                        return "initMap: integer[] expected";
            }
            if (message.availableBalance != null && message.hasOwnProperty("availableBalance"))
                if (!$util.isInteger(message.availableBalance))
                    return "availableBalance: integer expected";
            if (message.params != null && message.hasOwnProperty("params"))
                if (!$util.isString(message.params))
                    return "params: string expected";
            if (message.win != null && message.hasOwnProperty("win"))
                if (!$util.isInteger(message.win))
                    return "win: integer expected";
            if (message.jackpot != null && message.hasOwnProperty("jackpot")) {
                if (!Array.isArray(message.jackpot))
                    return "jackpot: array expected";
                for (let i = 0; i < message.jackpot.length; ++i)
                    if (!$util.isInteger(message.jackpot[i]))
                        return "jackpot: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoSlotStateResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoSlotStateResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoSlotStateResp} ProtoSlotStateResp
         */
        ProtoSlotStateResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoSlotStateResp)
                return object;
            let message = new $root.mini.ProtoSlotStateResp();
            if (object.initMap) {
                if (!Array.isArray(object.initMap))
                    throw TypeError(".mini.ProtoSlotStateResp.initMap: array expected");
                message.initMap = [];
                for (let i = 0; i < object.initMap.length; ++i)
                    message.initMap[i] = object.initMap[i] | 0;
            }
            if (object.availableBalance != null)
                message.availableBalance = object.availableBalance | 0;
            if (object.params != null)
                message.params = String(object.params);
            if (object.win != null)
                message.win = object.win | 0;
            if (object.jackpot) {
                if (!Array.isArray(object.jackpot))
                    throw TypeError(".mini.ProtoSlotStateResp.jackpot: array expected");
                message.jackpot = [];
                for (let i = 0; i < object.jackpot.length; ++i)
                    message.jackpot[i] = object.jackpot[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoSlotStateResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoSlotStateResp
         * @static
         * @param {mini.ProtoSlotStateResp} message ProtoSlotStateResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoSlotStateResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.initMap = [];
                object.jackpot = [];
            }
            if (options.defaults) {
                object.availableBalance = 0;
                object.params = "";
                object.win = 0;
            }
            if (message.initMap && message.initMap.length) {
                object.initMap = [];
                for (let j = 0; j < message.initMap.length; ++j)
                    object.initMap[j] = message.initMap[j];
            }
            if (message.availableBalance != null && message.hasOwnProperty("availableBalance"))
                object.availableBalance = message.availableBalance;
            if (message.params != null && message.hasOwnProperty("params"))
                object.params = message.params;
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            if (message.jackpot && message.jackpot.length) {
                object.jackpot = [];
                for (let j = 0; j < message.jackpot.length; ++j)
                    object.jackpot[j] = message.jackpot[j];
            }
            return object;
        };

        /**
         * Converts this ProtoSlotStateResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoSlotStateResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoSlotStateResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoSlotStateResp;
    })();

    mini.ProtoZeusBlockReq = (function() {

        /**
         * Properties of a ProtoZeusBlockReq.
         * @memberof mini
         * @interface IProtoZeusBlockReq
         * @property {number|null} [gameType] ProtoZeusBlockReq gameType
         */

        /**
         * Constructs a new ProtoZeusBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoZeusBlockReq.
         * @implements IProtoZeusBlockReq
         * @constructor
         * @param {mini.IProtoZeusBlockReq=} [properties] Properties to set
         */
        function ProtoZeusBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoZeusBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoZeusBlockReq
         * @instance
         */
        ProtoZeusBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoZeusBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoZeusBlockReq
         * @static
         * @param {mini.IProtoZeusBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoZeusBlockReq} ProtoZeusBlockReq instance
         */
        ProtoZeusBlockReq.create = function create(properties) {
            return new ProtoZeusBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoZeusBlockReq message. Does not implicitly {@link mini.ProtoZeusBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoZeusBlockReq
         * @static
         * @param {mini.IProtoZeusBlockReq} message ProtoZeusBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeusBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoZeusBlockReq message, length delimited. Does not implicitly {@link mini.ProtoZeusBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoZeusBlockReq
         * @static
         * @param {mini.IProtoZeusBlockReq} message ProtoZeusBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeusBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoZeusBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoZeusBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoZeusBlockReq} ProtoZeusBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeusBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoZeusBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoZeusBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoZeusBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoZeusBlockReq} ProtoZeusBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeusBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoZeusBlockReq message.
         * @function verify
         * @memberof mini.ProtoZeusBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoZeusBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoZeusBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoZeusBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoZeusBlockReq} ProtoZeusBlockReq
         */
        ProtoZeusBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoZeusBlockReq)
                return object;
            let message = new $root.mini.ProtoZeusBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoZeusBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoZeusBlockReq
         * @static
         * @param {mini.ProtoZeusBlockReq} message ProtoZeusBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoZeusBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoZeusBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoZeusBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoZeusBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoZeusBlockReq;
    })();

    mini.ProtoZeusBlockResp = (function() {

        /**
         * Properties of a ProtoZeusBlockResp.
         * @memberof mini
         * @interface IProtoZeusBlockResp
         * @property {Array.<number>|null} [block] ProtoZeusBlockResp block
         */

        /**
         * Constructs a new ProtoZeusBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoZeusBlockResp.
         * @implements IProtoZeusBlockResp
         * @constructor
         * @param {mini.IProtoZeusBlockResp=} [properties] Properties to set
         */
        function ProtoZeusBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoZeusBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoZeusBlockResp
         * @instance
         */
        ProtoZeusBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoZeusBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoZeusBlockResp
         * @static
         * @param {mini.IProtoZeusBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoZeusBlockResp} ProtoZeusBlockResp instance
         */
        ProtoZeusBlockResp.create = function create(properties) {
            return new ProtoZeusBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoZeusBlockResp message. Does not implicitly {@link mini.ProtoZeusBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoZeusBlockResp
         * @static
         * @param {mini.IProtoZeusBlockResp} message ProtoZeusBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeusBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoZeusBlockResp message, length delimited. Does not implicitly {@link mini.ProtoZeusBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoZeusBlockResp
         * @static
         * @param {mini.IProtoZeusBlockResp} message ProtoZeusBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeusBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoZeusBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoZeusBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoZeusBlockResp} ProtoZeusBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeusBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoZeusBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoZeusBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoZeusBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoZeusBlockResp} ProtoZeusBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeusBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoZeusBlockResp message.
         * @function verify
         * @memberof mini.ProtoZeusBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoZeusBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoZeusBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoZeusBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoZeusBlockResp} ProtoZeusBlockResp
         */
        ProtoZeusBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoZeusBlockResp)
                return object;
            let message = new $root.mini.ProtoZeusBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoZeusBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoZeusBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoZeusBlockResp
         * @static
         * @param {mini.ProtoZeusBlockResp} message ProtoZeusBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoZeusBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoZeusBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoZeusBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoZeusBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoZeusBlockResp;
    })();

    mini.ProtoZeusGameStartReq = (function() {

        /**
         * Properties of a ProtoZeusGameStartReq.
         * @memberof mini
         * @interface IProtoZeusGameStartReq
         * @property {number|null} [score] ProtoZeusGameStartReq score
         * @property {number|null} [type] ProtoZeusGameStartReq type
         * @property {number|null} [area] ProtoZeusGameStartReq area
         * @property {number|null} [buff] ProtoZeusGameStartReq buff
         */

        /**
         * Constructs a new ProtoZeusGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoZeusGameStartReq.
         * @implements IProtoZeusGameStartReq
         * @constructor
         * @param {mini.IProtoZeusGameStartReq=} [properties] Properties to set
         */
        function ProtoZeusGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoZeusGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoZeusGameStartReq
         * @instance
         */
        ProtoZeusGameStartReq.prototype.score = 0;

        /**
         * ProtoZeusGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoZeusGameStartReq
         * @instance
         */
        ProtoZeusGameStartReq.prototype.type = 0;

        /**
         * ProtoZeusGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoZeusGameStartReq
         * @instance
         */
        ProtoZeusGameStartReq.prototype.area = 0;

        /**
         * ProtoZeusGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoZeusGameStartReq
         * @instance
         */
        ProtoZeusGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoZeusGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoZeusGameStartReq
         * @static
         * @param {mini.IProtoZeusGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoZeusGameStartReq} ProtoZeusGameStartReq instance
         */
        ProtoZeusGameStartReq.create = function create(properties) {
            return new ProtoZeusGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoZeusGameStartReq message. Does not implicitly {@link mini.ProtoZeusGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoZeusGameStartReq
         * @static
         * @param {mini.IProtoZeusGameStartReq} message ProtoZeusGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeusGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoZeusGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoZeusGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoZeusGameStartReq
         * @static
         * @param {mini.IProtoZeusGameStartReq} message ProtoZeusGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeusGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoZeusGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoZeusGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoZeusGameStartReq} ProtoZeusGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeusGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoZeusGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoZeusGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoZeusGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoZeusGameStartReq} ProtoZeusGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeusGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoZeusGameStartReq message.
         * @function verify
         * @memberof mini.ProtoZeusGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoZeusGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoZeusGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoZeusGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoZeusGameStartReq} ProtoZeusGameStartReq
         */
        ProtoZeusGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoZeusGameStartReq)
                return object;
            let message = new $root.mini.ProtoZeusGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoZeusGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoZeusGameStartReq
         * @static
         * @param {mini.ProtoZeusGameStartReq} message ProtoZeusGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoZeusGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoZeusGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoZeusGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoZeusGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoZeusGameStartReq;
    })();

    mini.ProtoZeusGameStartResp = (function() {

        /**
         * Properties of a ProtoZeusGameStartResp.
         * @memberof mini
         * @interface IProtoZeusGameStartResp
         * @property {number|null} [stage2Count] ProtoZeusGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoZeusGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoZeusGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoZeusGameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoZeusGameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoZeusGameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [freeResult] ProtoZeusGameStartResp freeResult
         * @property {Array.<number>|null} [param] ProtoZeusGameStartResp param
         * @property {string|null} [gameID] ProtoZeusGameStartResp gameID
         * @property {string|null} [buff] ProtoZeusGameStartResp buff
         * @property {string|null} [area] ProtoZeusGameStartResp area
         * @property {number|null} [per] ProtoZeusGameStartResp per
         * @property {number|null} [errorCode] ProtoZeusGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoZeusGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoZeusGameStartResp.
         * @implements IProtoZeusGameStartResp
         * @constructor
         * @param {mini.IProtoZeusGameStartResp=} [properties] Properties to set
         */
        function ProtoZeusGameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.freeResult = [];
            this.param = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoZeusGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoZeusGameStartResp
         * @instance
         */
        ProtoZeusGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoZeusGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoZeusGameStartResp
         * @instance
         */
        ProtoZeusGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoZeusGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoZeusGameStartResp
         * @instance
         */
        ProtoZeusGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoZeusGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoZeusGameStartResp
         * @instance
         */
        ProtoZeusGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoZeusGameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoZeusGameStartResp
         * @instance
         */
        ProtoZeusGameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoZeusGameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoZeusGameStartResp
         * @instance
         */
        ProtoZeusGameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoZeusGameStartResp freeResult.
         * @member {Array.<mini.IFreeSpin>} freeResult
         * @memberof mini.ProtoZeusGameStartResp
         * @instance
         */
        ProtoZeusGameStartResp.prototype.freeResult = $util.emptyArray;

        /**
         * ProtoZeusGameStartResp param.
         * @member {Array.<number>} param
         * @memberof mini.ProtoZeusGameStartResp
         * @instance
         */
        ProtoZeusGameStartResp.prototype.param = $util.emptyArray;

        /**
         * ProtoZeusGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoZeusGameStartResp
         * @instance
         */
        ProtoZeusGameStartResp.prototype.gameID = "";

        /**
         * ProtoZeusGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoZeusGameStartResp
         * @instance
         */
        ProtoZeusGameStartResp.prototype.buff = "";

        /**
         * ProtoZeusGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoZeusGameStartResp
         * @instance
         */
        ProtoZeusGameStartResp.prototype.area = "";

        /**
         * ProtoZeusGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoZeusGameStartResp
         * @instance
         */
        ProtoZeusGameStartResp.prototype.per = 0;

        /**
         * ProtoZeusGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoZeusGameStartResp
         * @instance
         */
        ProtoZeusGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoZeusGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoZeusGameStartResp
         * @static
         * @param {mini.IProtoZeusGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoZeusGameStartResp} ProtoZeusGameStartResp instance
         */
        ProtoZeusGameStartResp.create = function create(properties) {
            return new ProtoZeusGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoZeusGameStartResp message. Does not implicitly {@link mini.ProtoZeusGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoZeusGameStartResp
         * @static
         * @param {mini.IProtoZeusGameStartResp} message ProtoZeusGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeusGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.freeResult != null && message.freeResult.length)
                for (let i = 0; i < message.freeResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.freeResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.param != null && message.param.length) {
                writer.uint32(/* id 8, wireType 2 =*/66).fork();
                for (let i = 0; i < message.param.length; ++i)
                    writer.int32(message.param[i]);
                writer.ldelim();
            }
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.per);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoZeusGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoZeusGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoZeusGameStartResp
         * @static
         * @param {mini.IProtoZeusGameStartResp} message ProtoZeusGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeusGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoZeusGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoZeusGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoZeusGameStartResp} ProtoZeusGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeusGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoZeusGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.freeResult && message.freeResult.length))
                        message.freeResult = [];
                    message.freeResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                case 9:
                    message.gameID = reader.string();
                    break;
                case 10:
                    message.buff = reader.string();
                    break;
                case 11:
                    message.area = reader.string();
                    break;
                case 12:
                    message.per = reader.uint32();
                    break;
                case 13:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoZeusGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoZeusGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoZeusGameStartResp} ProtoZeusGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeusGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoZeusGameStartResp message.
         * @function verify
         * @memberof mini.ProtoZeusGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoZeusGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.freeResult != null && message.hasOwnProperty("freeResult")) {
                if (!Array.isArray(message.freeResult))
                    return "freeResult: array expected";
                for (let i = 0; i < message.freeResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.freeResult[i]);
                    if (error)
                        return "freeResult." + error;
                }
            }
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (let i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoZeusGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoZeusGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoZeusGameStartResp} ProtoZeusGameStartResp
         */
        ProtoZeusGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoZeusGameStartResp)
                return object;
            let message = new $root.mini.ProtoZeusGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoZeusGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoZeusGameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoZeusGameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoZeusGameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.freeResult) {
                if (!Array.isArray(object.freeResult))
                    throw TypeError(".mini.ProtoZeusGameStartResp.freeResult: array expected");
                message.freeResult = [];
                for (let i = 0; i < object.freeResult.length; ++i) {
                    if (typeof object.freeResult[i] !== "object")
                        throw TypeError(".mini.ProtoZeusGameStartResp.freeResult: object expected");
                    message.freeResult[i] = $root.mini.FreeSpin.fromObject(object.freeResult[i]);
                }
            }
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".mini.ProtoZeusGameStartResp.param: array expected");
                message.param = [];
                for (let i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoZeusGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoZeusGameStartResp
         * @static
         * @param {mini.ProtoZeusGameStartResp} message ProtoZeusGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoZeusGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.freeResult = [];
                object.param = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.freeResult && message.freeResult.length) {
                object.freeResult = [];
                for (let j = 0; j < message.freeResult.length; ++j)
                    object.freeResult[j] = $root.mini.FreeSpin.toObject(message.freeResult[j], options);
            }
            if (message.param && message.param.length) {
                object.param = [];
                for (let j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoZeusGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoZeusGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoZeusGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoZeusGameStartResp;
    })();

    mini.ProtoFruitBlockReq = (function() {

        /**
         * Properties of a ProtoFruitBlockReq.
         * @memberof mini
         * @interface IProtoFruitBlockReq
         * @property {number|null} [gameType] ProtoFruitBlockReq gameType
         */

        /**
         * Constructs a new ProtoFruitBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoFruitBlockReq.
         * @implements IProtoFruitBlockReq
         * @constructor
         * @param {mini.IProtoFruitBlockReq=} [properties] Properties to set
         */
        function ProtoFruitBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoFruitBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoFruitBlockReq
         * @instance
         */
        ProtoFruitBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoFruitBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoFruitBlockReq
         * @static
         * @param {mini.IProtoFruitBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoFruitBlockReq} ProtoFruitBlockReq instance
         */
        ProtoFruitBlockReq.create = function create(properties) {
            return new ProtoFruitBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoFruitBlockReq message. Does not implicitly {@link mini.ProtoFruitBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoFruitBlockReq
         * @static
         * @param {mini.IProtoFruitBlockReq} message ProtoFruitBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFruitBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoFruitBlockReq message, length delimited. Does not implicitly {@link mini.ProtoFruitBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoFruitBlockReq
         * @static
         * @param {mini.IProtoFruitBlockReq} message ProtoFruitBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFruitBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoFruitBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoFruitBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoFruitBlockReq} ProtoFruitBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFruitBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoFruitBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoFruitBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoFruitBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoFruitBlockReq} ProtoFruitBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFruitBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoFruitBlockReq message.
         * @function verify
         * @memberof mini.ProtoFruitBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoFruitBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoFruitBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoFruitBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoFruitBlockReq} ProtoFruitBlockReq
         */
        ProtoFruitBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoFruitBlockReq)
                return object;
            let message = new $root.mini.ProtoFruitBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoFruitBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoFruitBlockReq
         * @static
         * @param {mini.ProtoFruitBlockReq} message ProtoFruitBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoFruitBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoFruitBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoFruitBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoFruitBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoFruitBlockReq;
    })();

    mini.ProtoFruitBlockResp = (function() {

        /**
         * Properties of a ProtoFruitBlockResp.
         * @memberof mini
         * @interface IProtoFruitBlockResp
         * @property {Array.<number>|null} [block] ProtoFruitBlockResp block
         */

        /**
         * Constructs a new ProtoFruitBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoFruitBlockResp.
         * @implements IProtoFruitBlockResp
         * @constructor
         * @param {mini.IProtoFruitBlockResp=} [properties] Properties to set
         */
        function ProtoFruitBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoFruitBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoFruitBlockResp
         * @instance
         */
        ProtoFruitBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoFruitBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoFruitBlockResp
         * @static
         * @param {mini.IProtoFruitBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoFruitBlockResp} ProtoFruitBlockResp instance
         */
        ProtoFruitBlockResp.create = function create(properties) {
            return new ProtoFruitBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoFruitBlockResp message. Does not implicitly {@link mini.ProtoFruitBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoFruitBlockResp
         * @static
         * @param {mini.IProtoFruitBlockResp} message ProtoFruitBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFruitBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoFruitBlockResp message, length delimited. Does not implicitly {@link mini.ProtoFruitBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoFruitBlockResp
         * @static
         * @param {mini.IProtoFruitBlockResp} message ProtoFruitBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFruitBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoFruitBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoFruitBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoFruitBlockResp} ProtoFruitBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFruitBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoFruitBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoFruitBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoFruitBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoFruitBlockResp} ProtoFruitBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFruitBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoFruitBlockResp message.
         * @function verify
         * @memberof mini.ProtoFruitBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoFruitBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoFruitBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoFruitBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoFruitBlockResp} ProtoFruitBlockResp
         */
        ProtoFruitBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoFruitBlockResp)
                return object;
            let message = new $root.mini.ProtoFruitBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoFruitBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoFruitBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoFruitBlockResp
         * @static
         * @param {mini.ProtoFruitBlockResp} message ProtoFruitBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoFruitBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoFruitBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoFruitBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoFruitBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoFruitBlockResp;
    })();

    mini.ProtoFruitGameStartReq = (function() {

        /**
         * Properties of a ProtoFruitGameStartReq.
         * @memberof mini
         * @interface IProtoFruitGameStartReq
         * @property {number|null} [score] ProtoFruitGameStartReq score
         * @property {number|null} [type] ProtoFruitGameStartReq type
         * @property {number|null} [area] ProtoFruitGameStartReq area
         * @property {number|null} [buff] ProtoFruitGameStartReq buff
         */

        /**
         * Constructs a new ProtoFruitGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoFruitGameStartReq.
         * @implements IProtoFruitGameStartReq
         * @constructor
         * @param {mini.IProtoFruitGameStartReq=} [properties] Properties to set
         */
        function ProtoFruitGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoFruitGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoFruitGameStartReq
         * @instance
         */
        ProtoFruitGameStartReq.prototype.score = 0;

        /**
         * ProtoFruitGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoFruitGameStartReq
         * @instance
         */
        ProtoFruitGameStartReq.prototype.type = 0;

        /**
         * ProtoFruitGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoFruitGameStartReq
         * @instance
         */
        ProtoFruitGameStartReq.prototype.area = 0;

        /**
         * ProtoFruitGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoFruitGameStartReq
         * @instance
         */
        ProtoFruitGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoFruitGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoFruitGameStartReq
         * @static
         * @param {mini.IProtoFruitGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoFruitGameStartReq} ProtoFruitGameStartReq instance
         */
        ProtoFruitGameStartReq.create = function create(properties) {
            return new ProtoFruitGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoFruitGameStartReq message. Does not implicitly {@link mini.ProtoFruitGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoFruitGameStartReq
         * @static
         * @param {mini.IProtoFruitGameStartReq} message ProtoFruitGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFruitGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoFruitGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoFruitGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoFruitGameStartReq
         * @static
         * @param {mini.IProtoFruitGameStartReq} message ProtoFruitGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFruitGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoFruitGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoFruitGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoFruitGameStartReq} ProtoFruitGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFruitGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoFruitGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoFruitGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoFruitGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoFruitGameStartReq} ProtoFruitGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFruitGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoFruitGameStartReq message.
         * @function verify
         * @memberof mini.ProtoFruitGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoFruitGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoFruitGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoFruitGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoFruitGameStartReq} ProtoFruitGameStartReq
         */
        ProtoFruitGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoFruitGameStartReq)
                return object;
            let message = new $root.mini.ProtoFruitGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoFruitGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoFruitGameStartReq
         * @static
         * @param {mini.ProtoFruitGameStartReq} message ProtoFruitGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoFruitGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoFruitGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoFruitGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoFruitGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoFruitGameStartReq;
    })();

    mini.ProtoFruitGameStartResp = (function() {

        /**
         * Properties of a ProtoFruitGameStartResp.
         * @memberof mini
         * @interface IProtoFruitGameStartResp
         * @property {number|null} [stage2Count] ProtoFruitGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoFruitGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoFruitGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoFruitGameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoFruitGameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoFruitGameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [freeResult] ProtoFruitGameStartResp freeResult
         * @property {Array.<number>|null} [param] ProtoFruitGameStartResp param
         * @property {string|null} [gameID] ProtoFruitGameStartResp gameID
         * @property {string|null} [buff] ProtoFruitGameStartResp buff
         * @property {string|null} [area] ProtoFruitGameStartResp area
         * @property {number|null} [per] ProtoFruitGameStartResp per
         * @property {number|null} [errorCode] ProtoFruitGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoFruitGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoFruitGameStartResp.
         * @implements IProtoFruitGameStartResp
         * @constructor
         * @param {mini.IProtoFruitGameStartResp=} [properties] Properties to set
         */
        function ProtoFruitGameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.freeResult = [];
            this.param = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoFruitGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoFruitGameStartResp
         * @instance
         */
        ProtoFruitGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoFruitGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoFruitGameStartResp
         * @instance
         */
        ProtoFruitGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoFruitGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoFruitGameStartResp
         * @instance
         */
        ProtoFruitGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoFruitGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoFruitGameStartResp
         * @instance
         */
        ProtoFruitGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoFruitGameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoFruitGameStartResp
         * @instance
         */
        ProtoFruitGameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoFruitGameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoFruitGameStartResp
         * @instance
         */
        ProtoFruitGameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoFruitGameStartResp freeResult.
         * @member {Array.<mini.IFreeSpin>} freeResult
         * @memberof mini.ProtoFruitGameStartResp
         * @instance
         */
        ProtoFruitGameStartResp.prototype.freeResult = $util.emptyArray;

        /**
         * ProtoFruitGameStartResp param.
         * @member {Array.<number>} param
         * @memberof mini.ProtoFruitGameStartResp
         * @instance
         */
        ProtoFruitGameStartResp.prototype.param = $util.emptyArray;

        /**
         * ProtoFruitGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoFruitGameStartResp
         * @instance
         */
        ProtoFruitGameStartResp.prototype.gameID = "";

        /**
         * ProtoFruitGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoFruitGameStartResp
         * @instance
         */
        ProtoFruitGameStartResp.prototype.buff = "";

        /**
         * ProtoFruitGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoFruitGameStartResp
         * @instance
         */
        ProtoFruitGameStartResp.prototype.area = "";

        /**
         * ProtoFruitGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoFruitGameStartResp
         * @instance
         */
        ProtoFruitGameStartResp.prototype.per = 0;

        /**
         * ProtoFruitGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoFruitGameStartResp
         * @instance
         */
        ProtoFruitGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoFruitGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoFruitGameStartResp
         * @static
         * @param {mini.IProtoFruitGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoFruitGameStartResp} ProtoFruitGameStartResp instance
         */
        ProtoFruitGameStartResp.create = function create(properties) {
            return new ProtoFruitGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoFruitGameStartResp message. Does not implicitly {@link mini.ProtoFruitGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoFruitGameStartResp
         * @static
         * @param {mini.IProtoFruitGameStartResp} message ProtoFruitGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFruitGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.freeResult != null && message.freeResult.length)
                for (let i = 0; i < message.freeResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.freeResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.param != null && message.param.length) {
                writer.uint32(/* id 8, wireType 2 =*/66).fork();
                for (let i = 0; i < message.param.length; ++i)
                    writer.int32(message.param[i]);
                writer.ldelim();
            }
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.per);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoFruitGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoFruitGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoFruitGameStartResp
         * @static
         * @param {mini.IProtoFruitGameStartResp} message ProtoFruitGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFruitGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoFruitGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoFruitGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoFruitGameStartResp} ProtoFruitGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFruitGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoFruitGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.freeResult && message.freeResult.length))
                        message.freeResult = [];
                    message.freeResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                case 9:
                    message.gameID = reader.string();
                    break;
                case 10:
                    message.buff = reader.string();
                    break;
                case 11:
                    message.area = reader.string();
                    break;
                case 12:
                    message.per = reader.uint32();
                    break;
                case 13:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoFruitGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoFruitGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoFruitGameStartResp} ProtoFruitGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFruitGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoFruitGameStartResp message.
         * @function verify
         * @memberof mini.ProtoFruitGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoFruitGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.freeResult != null && message.hasOwnProperty("freeResult")) {
                if (!Array.isArray(message.freeResult))
                    return "freeResult: array expected";
                for (let i = 0; i < message.freeResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.freeResult[i]);
                    if (error)
                        return "freeResult." + error;
                }
            }
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (let i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoFruitGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoFruitGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoFruitGameStartResp} ProtoFruitGameStartResp
         */
        ProtoFruitGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoFruitGameStartResp)
                return object;
            let message = new $root.mini.ProtoFruitGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoFruitGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoFruitGameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoFruitGameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoFruitGameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.freeResult) {
                if (!Array.isArray(object.freeResult))
                    throw TypeError(".mini.ProtoFruitGameStartResp.freeResult: array expected");
                message.freeResult = [];
                for (let i = 0; i < object.freeResult.length; ++i) {
                    if (typeof object.freeResult[i] !== "object")
                        throw TypeError(".mini.ProtoFruitGameStartResp.freeResult: object expected");
                    message.freeResult[i] = $root.mini.FreeSpin.fromObject(object.freeResult[i]);
                }
            }
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".mini.ProtoFruitGameStartResp.param: array expected");
                message.param = [];
                for (let i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoFruitGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoFruitGameStartResp
         * @static
         * @param {mini.ProtoFruitGameStartResp} message ProtoFruitGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoFruitGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.freeResult = [];
                object.param = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.freeResult && message.freeResult.length) {
                object.freeResult = [];
                for (let j = 0; j < message.freeResult.length; ++j)
                    object.freeResult[j] = $root.mini.FreeSpin.toObject(message.freeResult[j], options);
            }
            if (message.param && message.param.length) {
                object.param = [];
                for (let j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoFruitGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoFruitGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoFruitGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoFruitGameStartResp;
    })();

    mini.ProtoSJB02BlockReq = (function() {

        /**
         * Properties of a ProtoSJB02BlockReq.
         * @memberof mini
         * @interface IProtoSJB02BlockReq
         * @property {number|null} [gameType] ProtoSJB02BlockReq gameType
         */

        /**
         * Constructs a new ProtoSJB02BlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoSJB02BlockReq.
         * @implements IProtoSJB02BlockReq
         * @constructor
         * @param {mini.IProtoSJB02BlockReq=} [properties] Properties to set
         */
        function ProtoSJB02BlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoSJB02BlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoSJB02BlockReq
         * @instance
         */
        ProtoSJB02BlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoSJB02BlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoSJB02BlockReq
         * @static
         * @param {mini.IProtoSJB02BlockReq=} [properties] Properties to set
         * @returns {mini.ProtoSJB02BlockReq} ProtoSJB02BlockReq instance
         */
        ProtoSJB02BlockReq.create = function create(properties) {
            return new ProtoSJB02BlockReq(properties);
        };

        /**
         * Encodes the specified ProtoSJB02BlockReq message. Does not implicitly {@link mini.ProtoSJB02BlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoSJB02BlockReq
         * @static
         * @param {mini.IProtoSJB02BlockReq} message ProtoSJB02BlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJB02BlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoSJB02BlockReq message, length delimited. Does not implicitly {@link mini.ProtoSJB02BlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoSJB02BlockReq
         * @static
         * @param {mini.IProtoSJB02BlockReq} message ProtoSJB02BlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJB02BlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoSJB02BlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoSJB02BlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoSJB02BlockReq} ProtoSJB02BlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJB02BlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoSJB02BlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoSJB02BlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoSJB02BlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoSJB02BlockReq} ProtoSJB02BlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJB02BlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoSJB02BlockReq message.
         * @function verify
         * @memberof mini.ProtoSJB02BlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoSJB02BlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoSJB02BlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoSJB02BlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoSJB02BlockReq} ProtoSJB02BlockReq
         */
        ProtoSJB02BlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoSJB02BlockReq)
                return object;
            let message = new $root.mini.ProtoSJB02BlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoSJB02BlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoSJB02BlockReq
         * @static
         * @param {mini.ProtoSJB02BlockReq} message ProtoSJB02BlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoSJB02BlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoSJB02BlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoSJB02BlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoSJB02BlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoSJB02BlockReq;
    })();

    mini.ProtoSJB02BlockResp = (function() {

        /**
         * Properties of a ProtoSJB02BlockResp.
         * @memberof mini
         * @interface IProtoSJB02BlockResp
         * @property {Array.<number>|null} [block] ProtoSJB02BlockResp block
         */

        /**
         * Constructs a new ProtoSJB02BlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoSJB02BlockResp.
         * @implements IProtoSJB02BlockResp
         * @constructor
         * @param {mini.IProtoSJB02BlockResp=} [properties] Properties to set
         */
        function ProtoSJB02BlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoSJB02BlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoSJB02BlockResp
         * @instance
         */
        ProtoSJB02BlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoSJB02BlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoSJB02BlockResp
         * @static
         * @param {mini.IProtoSJB02BlockResp=} [properties] Properties to set
         * @returns {mini.ProtoSJB02BlockResp} ProtoSJB02BlockResp instance
         */
        ProtoSJB02BlockResp.create = function create(properties) {
            return new ProtoSJB02BlockResp(properties);
        };

        /**
         * Encodes the specified ProtoSJB02BlockResp message. Does not implicitly {@link mini.ProtoSJB02BlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoSJB02BlockResp
         * @static
         * @param {mini.IProtoSJB02BlockResp} message ProtoSJB02BlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJB02BlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoSJB02BlockResp message, length delimited. Does not implicitly {@link mini.ProtoSJB02BlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoSJB02BlockResp
         * @static
         * @param {mini.IProtoSJB02BlockResp} message ProtoSJB02BlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJB02BlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoSJB02BlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoSJB02BlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoSJB02BlockResp} ProtoSJB02BlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJB02BlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoSJB02BlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoSJB02BlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoSJB02BlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoSJB02BlockResp} ProtoSJB02BlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJB02BlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoSJB02BlockResp message.
         * @function verify
         * @memberof mini.ProtoSJB02BlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoSJB02BlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoSJB02BlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoSJB02BlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoSJB02BlockResp} ProtoSJB02BlockResp
         */
        ProtoSJB02BlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoSJB02BlockResp)
                return object;
            let message = new $root.mini.ProtoSJB02BlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoSJB02BlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoSJB02BlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoSJB02BlockResp
         * @static
         * @param {mini.ProtoSJB02BlockResp} message ProtoSJB02BlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoSJB02BlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoSJB02BlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoSJB02BlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoSJB02BlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoSJB02BlockResp;
    })();

    mini.ProtoSJB02GameStartReq = (function() {

        /**
         * Properties of a ProtoSJB02GameStartReq.
         * @memberof mini
         * @interface IProtoSJB02GameStartReq
         * @property {number|null} [score] ProtoSJB02GameStartReq score
         * @property {number|null} [type] ProtoSJB02GameStartReq type
         * @property {number|null} [area] ProtoSJB02GameStartReq area
         * @property {number|null} [buff] ProtoSJB02GameStartReq buff
         */

        /**
         * Constructs a new ProtoSJB02GameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoSJB02GameStartReq.
         * @implements IProtoSJB02GameStartReq
         * @constructor
         * @param {mini.IProtoSJB02GameStartReq=} [properties] Properties to set
         */
        function ProtoSJB02GameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoSJB02GameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoSJB02GameStartReq
         * @instance
         */
        ProtoSJB02GameStartReq.prototype.score = 0;

        /**
         * ProtoSJB02GameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoSJB02GameStartReq
         * @instance
         */
        ProtoSJB02GameStartReq.prototype.type = 0;

        /**
         * ProtoSJB02GameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoSJB02GameStartReq
         * @instance
         */
        ProtoSJB02GameStartReq.prototype.area = 0;

        /**
         * ProtoSJB02GameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoSJB02GameStartReq
         * @instance
         */
        ProtoSJB02GameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoSJB02GameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoSJB02GameStartReq
         * @static
         * @param {mini.IProtoSJB02GameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoSJB02GameStartReq} ProtoSJB02GameStartReq instance
         */
        ProtoSJB02GameStartReq.create = function create(properties) {
            return new ProtoSJB02GameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoSJB02GameStartReq message. Does not implicitly {@link mini.ProtoSJB02GameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoSJB02GameStartReq
         * @static
         * @param {mini.IProtoSJB02GameStartReq} message ProtoSJB02GameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJB02GameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoSJB02GameStartReq message, length delimited. Does not implicitly {@link mini.ProtoSJB02GameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoSJB02GameStartReq
         * @static
         * @param {mini.IProtoSJB02GameStartReq} message ProtoSJB02GameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJB02GameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoSJB02GameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoSJB02GameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoSJB02GameStartReq} ProtoSJB02GameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJB02GameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoSJB02GameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoSJB02GameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoSJB02GameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoSJB02GameStartReq} ProtoSJB02GameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJB02GameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoSJB02GameStartReq message.
         * @function verify
         * @memberof mini.ProtoSJB02GameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoSJB02GameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoSJB02GameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoSJB02GameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoSJB02GameStartReq} ProtoSJB02GameStartReq
         */
        ProtoSJB02GameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoSJB02GameStartReq)
                return object;
            let message = new $root.mini.ProtoSJB02GameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoSJB02GameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoSJB02GameStartReq
         * @static
         * @param {mini.ProtoSJB02GameStartReq} message ProtoSJB02GameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoSJB02GameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoSJB02GameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoSJB02GameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoSJB02GameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoSJB02GameStartReq;
    })();

    mini.ProtoSJB02GameStartResp = (function() {

        /**
         * Properties of a ProtoSJB02GameStartResp.
         * @memberof mini
         * @interface IProtoSJB02GameStartResp
         * @property {number|null} [stage2Count] ProtoSJB02GameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoSJB02GameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoSJB02GameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoSJB02GameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoSJB02GameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoSJB02GameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [freeResult] ProtoSJB02GameStartResp freeResult
         * @property {Array.<mini.IFreeSpin>|null} [goldResult] ProtoSJB02GameStartResp goldResult
         * @property {string|null} [gameID] ProtoSJB02GameStartResp gameID
         * @property {string|null} [buff] ProtoSJB02GameStartResp buff
         * @property {string|null} [area] ProtoSJB02GameStartResp area
         * @property {number|null} [per] ProtoSJB02GameStartResp per
         * @property {Array.<number>|null} [jackpot] ProtoSJB02GameStartResp jackpot
         * @property {number|null} [errorCode] ProtoSJB02GameStartResp errorCode
         */

        /**
         * Constructs a new ProtoSJB02GameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoSJB02GameStartResp.
         * @implements IProtoSJB02GameStartResp
         * @constructor
         * @param {mini.IProtoSJB02GameStartResp=} [properties] Properties to set
         */
        function ProtoSJB02GameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.freeResult = [];
            this.goldResult = [];
            this.jackpot = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoSJB02GameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoSJB02GameStartResp
         * @instance
         */
        ProtoSJB02GameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoSJB02GameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoSJB02GameStartResp
         * @instance
         */
        ProtoSJB02GameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoSJB02GameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoSJB02GameStartResp
         * @instance
         */
        ProtoSJB02GameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoSJB02GameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoSJB02GameStartResp
         * @instance
         */
        ProtoSJB02GameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoSJB02GameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoSJB02GameStartResp
         * @instance
         */
        ProtoSJB02GameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoSJB02GameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoSJB02GameStartResp
         * @instance
         */
        ProtoSJB02GameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoSJB02GameStartResp freeResult.
         * @member {Array.<mini.IFreeSpin>} freeResult
         * @memberof mini.ProtoSJB02GameStartResp
         * @instance
         */
        ProtoSJB02GameStartResp.prototype.freeResult = $util.emptyArray;

        /**
         * ProtoSJB02GameStartResp goldResult.
         * @member {Array.<mini.IFreeSpin>} goldResult
         * @memberof mini.ProtoSJB02GameStartResp
         * @instance
         */
        ProtoSJB02GameStartResp.prototype.goldResult = $util.emptyArray;

        /**
         * ProtoSJB02GameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoSJB02GameStartResp
         * @instance
         */
        ProtoSJB02GameStartResp.prototype.gameID = "";

        /**
         * ProtoSJB02GameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoSJB02GameStartResp
         * @instance
         */
        ProtoSJB02GameStartResp.prototype.buff = "";

        /**
         * ProtoSJB02GameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoSJB02GameStartResp
         * @instance
         */
        ProtoSJB02GameStartResp.prototype.area = "";

        /**
         * ProtoSJB02GameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoSJB02GameStartResp
         * @instance
         */
        ProtoSJB02GameStartResp.prototype.per = 0;

        /**
         * ProtoSJB02GameStartResp jackpot.
         * @member {Array.<number>} jackpot
         * @memberof mini.ProtoSJB02GameStartResp
         * @instance
         */
        ProtoSJB02GameStartResp.prototype.jackpot = $util.emptyArray;

        /**
         * ProtoSJB02GameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoSJB02GameStartResp
         * @instance
         */
        ProtoSJB02GameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoSJB02GameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoSJB02GameStartResp
         * @static
         * @param {mini.IProtoSJB02GameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoSJB02GameStartResp} ProtoSJB02GameStartResp instance
         */
        ProtoSJB02GameStartResp.create = function create(properties) {
            return new ProtoSJB02GameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoSJB02GameStartResp message. Does not implicitly {@link mini.ProtoSJB02GameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoSJB02GameStartResp
         * @static
         * @param {mini.IProtoSJB02GameStartResp} message ProtoSJB02GameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJB02GameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.freeResult != null && message.freeResult.length)
                for (let i = 0; i < message.freeResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.freeResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.goldResult != null && message.goldResult.length)
                for (let i = 0; i < message.goldResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.goldResult[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.per);
            if (message.jackpot != null && message.jackpot.length) {
                writer.uint32(/* id 13, wireType 2 =*/106).fork();
                for (let i = 0; i < message.jackpot.length; ++i)
                    writer.uint32(message.jackpot[i]);
                writer.ldelim();
            }
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoSJB02GameStartResp message, length delimited. Does not implicitly {@link mini.ProtoSJB02GameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoSJB02GameStartResp
         * @static
         * @param {mini.IProtoSJB02GameStartResp} message ProtoSJB02GameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSJB02GameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoSJB02GameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoSJB02GameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoSJB02GameStartResp} ProtoSJB02GameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJB02GameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoSJB02GameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.freeResult && message.freeResult.length))
                        message.freeResult = [];
                    message.freeResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.goldResult && message.goldResult.length))
                        message.goldResult = [];
                    message.goldResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.gameID = reader.string();
                    break;
                case 10:
                    message.buff = reader.string();
                    break;
                case 11:
                    message.area = reader.string();
                    break;
                case 12:
                    message.per = reader.uint32();
                    break;
                case 13:
                    if (!(message.jackpot && message.jackpot.length))
                        message.jackpot = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.jackpot.push(reader.uint32());
                    } else
                        message.jackpot.push(reader.uint32());
                    break;
                case 14:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoSJB02GameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoSJB02GameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoSJB02GameStartResp} ProtoSJB02GameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSJB02GameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoSJB02GameStartResp message.
         * @function verify
         * @memberof mini.ProtoSJB02GameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoSJB02GameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.freeResult != null && message.hasOwnProperty("freeResult")) {
                if (!Array.isArray(message.freeResult))
                    return "freeResult: array expected";
                for (let i = 0; i < message.freeResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.freeResult[i]);
                    if (error)
                        return "freeResult." + error;
                }
            }
            if (message.goldResult != null && message.hasOwnProperty("goldResult")) {
                if (!Array.isArray(message.goldResult))
                    return "goldResult: array expected";
                for (let i = 0; i < message.goldResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.goldResult[i]);
                    if (error)
                        return "goldResult." + error;
                }
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.jackpot != null && message.hasOwnProperty("jackpot")) {
                if (!Array.isArray(message.jackpot))
                    return "jackpot: array expected";
                for (let i = 0; i < message.jackpot.length; ++i)
                    if (!$util.isInteger(message.jackpot[i]))
                        return "jackpot: integer[] expected";
            }
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoSJB02GameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoSJB02GameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoSJB02GameStartResp} ProtoSJB02GameStartResp
         */
        ProtoSJB02GameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoSJB02GameStartResp)
                return object;
            let message = new $root.mini.ProtoSJB02GameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoSJB02GameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoSJB02GameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoSJB02GameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoSJB02GameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.freeResult) {
                if (!Array.isArray(object.freeResult))
                    throw TypeError(".mini.ProtoSJB02GameStartResp.freeResult: array expected");
                message.freeResult = [];
                for (let i = 0; i < object.freeResult.length; ++i) {
                    if (typeof object.freeResult[i] !== "object")
                        throw TypeError(".mini.ProtoSJB02GameStartResp.freeResult: object expected");
                    message.freeResult[i] = $root.mini.FreeSpin.fromObject(object.freeResult[i]);
                }
            }
            if (object.goldResult) {
                if (!Array.isArray(object.goldResult))
                    throw TypeError(".mini.ProtoSJB02GameStartResp.goldResult: array expected");
                message.goldResult = [];
                for (let i = 0; i < object.goldResult.length; ++i) {
                    if (typeof object.goldResult[i] !== "object")
                        throw TypeError(".mini.ProtoSJB02GameStartResp.goldResult: object expected");
                    message.goldResult[i] = $root.mini.FreeSpin.fromObject(object.goldResult[i]);
                }
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.jackpot) {
                if (!Array.isArray(object.jackpot))
                    throw TypeError(".mini.ProtoSJB02GameStartResp.jackpot: array expected");
                message.jackpot = [];
                for (let i = 0; i < object.jackpot.length; ++i)
                    message.jackpot[i] = object.jackpot[i] >>> 0;
            }
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoSJB02GameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoSJB02GameStartResp
         * @static
         * @param {mini.ProtoSJB02GameStartResp} message ProtoSJB02GameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoSJB02GameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.freeResult = [];
                object.goldResult = [];
                object.jackpot = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.freeResult && message.freeResult.length) {
                object.freeResult = [];
                for (let j = 0; j < message.freeResult.length; ++j)
                    object.freeResult[j] = $root.mini.FreeSpin.toObject(message.freeResult[j], options);
            }
            if (message.goldResult && message.goldResult.length) {
                object.goldResult = [];
                for (let j = 0; j < message.goldResult.length; ++j)
                    object.goldResult[j] = $root.mini.FreeSpin.toObject(message.goldResult[j], options);
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.jackpot && message.jackpot.length) {
                object.jackpot = [];
                for (let j = 0; j < message.jackpot.length; ++j)
                    object.jackpot[j] = message.jackpot[j];
            }
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoSJB02GameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoSJB02GameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoSJB02GameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoSJB02GameStartResp;
    })();

    mini.ProtoSpartaBlockReq = (function() {

        /**
         * Properties of a ProtoSpartaBlockReq.
         * @memberof mini
         * @interface IProtoSpartaBlockReq
         * @property {number|null} [gameType] ProtoSpartaBlockReq gameType
         */

        /**
         * Constructs a new ProtoSpartaBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoSpartaBlockReq.
         * @implements IProtoSpartaBlockReq
         * @constructor
         * @param {mini.IProtoSpartaBlockReq=} [properties] Properties to set
         */
        function ProtoSpartaBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoSpartaBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoSpartaBlockReq
         * @instance
         */
        ProtoSpartaBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoSpartaBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoSpartaBlockReq
         * @static
         * @param {mini.IProtoSpartaBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoSpartaBlockReq} ProtoSpartaBlockReq instance
         */
        ProtoSpartaBlockReq.create = function create(properties) {
            return new ProtoSpartaBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoSpartaBlockReq message. Does not implicitly {@link mini.ProtoSpartaBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoSpartaBlockReq
         * @static
         * @param {mini.IProtoSpartaBlockReq} message ProtoSpartaBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSpartaBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoSpartaBlockReq message, length delimited. Does not implicitly {@link mini.ProtoSpartaBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoSpartaBlockReq
         * @static
         * @param {mini.IProtoSpartaBlockReq} message ProtoSpartaBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSpartaBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoSpartaBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoSpartaBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoSpartaBlockReq} ProtoSpartaBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSpartaBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoSpartaBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoSpartaBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoSpartaBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoSpartaBlockReq} ProtoSpartaBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSpartaBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoSpartaBlockReq message.
         * @function verify
         * @memberof mini.ProtoSpartaBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoSpartaBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoSpartaBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoSpartaBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoSpartaBlockReq} ProtoSpartaBlockReq
         */
        ProtoSpartaBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoSpartaBlockReq)
                return object;
            let message = new $root.mini.ProtoSpartaBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoSpartaBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoSpartaBlockReq
         * @static
         * @param {mini.ProtoSpartaBlockReq} message ProtoSpartaBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoSpartaBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoSpartaBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoSpartaBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoSpartaBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoSpartaBlockReq;
    })();

    mini.ProtoSpartaBlockResp = (function() {

        /**
         * Properties of a ProtoSpartaBlockResp.
         * @memberof mini
         * @interface IProtoSpartaBlockResp
         * @property {Array.<number>|null} [block] ProtoSpartaBlockResp block
         */

        /**
         * Constructs a new ProtoSpartaBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoSpartaBlockResp.
         * @implements IProtoSpartaBlockResp
         * @constructor
         * @param {mini.IProtoSpartaBlockResp=} [properties] Properties to set
         */
        function ProtoSpartaBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoSpartaBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoSpartaBlockResp
         * @instance
         */
        ProtoSpartaBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoSpartaBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoSpartaBlockResp
         * @static
         * @param {mini.IProtoSpartaBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoSpartaBlockResp} ProtoSpartaBlockResp instance
         */
        ProtoSpartaBlockResp.create = function create(properties) {
            return new ProtoSpartaBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoSpartaBlockResp message. Does not implicitly {@link mini.ProtoSpartaBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoSpartaBlockResp
         * @static
         * @param {mini.IProtoSpartaBlockResp} message ProtoSpartaBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSpartaBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoSpartaBlockResp message, length delimited. Does not implicitly {@link mini.ProtoSpartaBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoSpartaBlockResp
         * @static
         * @param {mini.IProtoSpartaBlockResp} message ProtoSpartaBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSpartaBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoSpartaBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoSpartaBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoSpartaBlockResp} ProtoSpartaBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSpartaBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoSpartaBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoSpartaBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoSpartaBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoSpartaBlockResp} ProtoSpartaBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSpartaBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoSpartaBlockResp message.
         * @function verify
         * @memberof mini.ProtoSpartaBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoSpartaBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoSpartaBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoSpartaBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoSpartaBlockResp} ProtoSpartaBlockResp
         */
        ProtoSpartaBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoSpartaBlockResp)
                return object;
            let message = new $root.mini.ProtoSpartaBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoSpartaBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoSpartaBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoSpartaBlockResp
         * @static
         * @param {mini.ProtoSpartaBlockResp} message ProtoSpartaBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoSpartaBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoSpartaBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoSpartaBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoSpartaBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoSpartaBlockResp;
    })();

    mini.ProtoSpartaGameStartReq = (function() {

        /**
         * Properties of a ProtoSpartaGameStartReq.
         * @memberof mini
         * @interface IProtoSpartaGameStartReq
         * @property {number|null} [score] ProtoSpartaGameStartReq score
         * @property {number|null} [type] ProtoSpartaGameStartReq type
         * @property {number|null} [area] ProtoSpartaGameStartReq area
         * @property {number|null} [buff] ProtoSpartaGameStartReq buff
         */

        /**
         * Constructs a new ProtoSpartaGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoSpartaGameStartReq.
         * @implements IProtoSpartaGameStartReq
         * @constructor
         * @param {mini.IProtoSpartaGameStartReq=} [properties] Properties to set
         */
        function ProtoSpartaGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoSpartaGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoSpartaGameStartReq
         * @instance
         */
        ProtoSpartaGameStartReq.prototype.score = 0;

        /**
         * ProtoSpartaGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoSpartaGameStartReq
         * @instance
         */
        ProtoSpartaGameStartReq.prototype.type = 0;

        /**
         * ProtoSpartaGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoSpartaGameStartReq
         * @instance
         */
        ProtoSpartaGameStartReq.prototype.area = 0;

        /**
         * ProtoSpartaGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoSpartaGameStartReq
         * @instance
         */
        ProtoSpartaGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoSpartaGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoSpartaGameStartReq
         * @static
         * @param {mini.IProtoSpartaGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoSpartaGameStartReq} ProtoSpartaGameStartReq instance
         */
        ProtoSpartaGameStartReq.create = function create(properties) {
            return new ProtoSpartaGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoSpartaGameStartReq message. Does not implicitly {@link mini.ProtoSpartaGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoSpartaGameStartReq
         * @static
         * @param {mini.IProtoSpartaGameStartReq} message ProtoSpartaGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSpartaGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoSpartaGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoSpartaGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoSpartaGameStartReq
         * @static
         * @param {mini.IProtoSpartaGameStartReq} message ProtoSpartaGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSpartaGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoSpartaGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoSpartaGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoSpartaGameStartReq} ProtoSpartaGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSpartaGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoSpartaGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoSpartaGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoSpartaGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoSpartaGameStartReq} ProtoSpartaGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSpartaGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoSpartaGameStartReq message.
         * @function verify
         * @memberof mini.ProtoSpartaGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoSpartaGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoSpartaGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoSpartaGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoSpartaGameStartReq} ProtoSpartaGameStartReq
         */
        ProtoSpartaGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoSpartaGameStartReq)
                return object;
            let message = new $root.mini.ProtoSpartaGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoSpartaGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoSpartaGameStartReq
         * @static
         * @param {mini.ProtoSpartaGameStartReq} message ProtoSpartaGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoSpartaGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoSpartaGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoSpartaGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoSpartaGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoSpartaGameStartReq;
    })();

    mini.ProtoSpartaGameStartResp = (function() {

        /**
         * Properties of a ProtoSpartaGameStartResp.
         * @memberof mini
         * @interface IProtoSpartaGameStartResp
         * @property {number|null} [stage2Count] ProtoSpartaGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoSpartaGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoSpartaGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoSpartaGameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoSpartaGameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoSpartaGameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [freeResult] ProtoSpartaGameStartResp freeResult
         * @property {Array.<mini.IFreeSpin>|null} [superResult] ProtoSpartaGameStartResp superResult
         * @property {Array.<number>|null} [param] ProtoSpartaGameStartResp param
         * @property {number|null} [goldValue] ProtoSpartaGameStartResp goldValue
         * @property {string|null} [gameID] ProtoSpartaGameStartResp gameID
         * @property {string|null} [buff] ProtoSpartaGameStartResp buff
         * @property {string|null} [area] ProtoSpartaGameStartResp area
         * @property {number|null} [per] ProtoSpartaGameStartResp per
         * @property {Array.<number>|null} [jackpot] ProtoSpartaGameStartResp jackpot
         * @property {number|null} [errorCode] ProtoSpartaGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoSpartaGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoSpartaGameStartResp.
         * @implements IProtoSpartaGameStartResp
         * @constructor
         * @param {mini.IProtoSpartaGameStartResp=} [properties] Properties to set
         */
        function ProtoSpartaGameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.freeResult = [];
            this.superResult = [];
            this.param = [];
            this.jackpot = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoSpartaGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoSpartaGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoSpartaGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoSpartaGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoSpartaGameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoSpartaGameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoSpartaGameStartResp freeResult.
         * @member {Array.<mini.IFreeSpin>} freeResult
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.freeResult = $util.emptyArray;

        /**
         * ProtoSpartaGameStartResp superResult.
         * @member {Array.<mini.IFreeSpin>} superResult
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.superResult = $util.emptyArray;

        /**
         * ProtoSpartaGameStartResp param.
         * @member {Array.<number>} param
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.param = $util.emptyArray;

        /**
         * ProtoSpartaGameStartResp goldValue.
         * @member {number} goldValue
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.goldValue = 0;

        /**
         * ProtoSpartaGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.gameID = "";

        /**
         * ProtoSpartaGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.buff = "";

        /**
         * ProtoSpartaGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.area = "";

        /**
         * ProtoSpartaGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.per = 0;

        /**
         * ProtoSpartaGameStartResp jackpot.
         * @member {Array.<number>} jackpot
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.jackpot = $util.emptyArray;

        /**
         * ProtoSpartaGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         */
        ProtoSpartaGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoSpartaGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoSpartaGameStartResp
         * @static
         * @param {mini.IProtoSpartaGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoSpartaGameStartResp} ProtoSpartaGameStartResp instance
         */
        ProtoSpartaGameStartResp.create = function create(properties) {
            return new ProtoSpartaGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoSpartaGameStartResp message. Does not implicitly {@link mini.ProtoSpartaGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoSpartaGameStartResp
         * @static
         * @param {mini.IProtoSpartaGameStartResp} message ProtoSpartaGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSpartaGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.freeResult != null && message.freeResult.length)
                for (let i = 0; i < message.freeResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.freeResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.superResult != null && message.superResult.length)
                for (let i = 0; i < message.superResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.superResult[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.param != null && message.param.length) {
                writer.uint32(/* id 9, wireType 2 =*/74).fork();
                for (let i = 0; i < message.param.length; ++i)
                    writer.int32(message.param[i]);
                writer.ldelim();
            }
            if (message.goldValue != null && Object.hasOwnProperty.call(message, "goldValue"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.goldValue);
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.per);
            if (message.jackpot != null && message.jackpot.length) {
                writer.uint32(/* id 15, wireType 2 =*/122).fork();
                for (let i = 0; i < message.jackpot.length; ++i)
                    writer.uint32(message.jackpot[i]);
                writer.ldelim();
            }
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoSpartaGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoSpartaGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoSpartaGameStartResp
         * @static
         * @param {mini.IProtoSpartaGameStartResp} message ProtoSpartaGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoSpartaGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoSpartaGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoSpartaGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoSpartaGameStartResp} ProtoSpartaGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSpartaGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoSpartaGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.freeResult && message.freeResult.length))
                        message.freeResult = [];
                    message.freeResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.superResult && message.superResult.length))
                        message.superResult = [];
                    message.superResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 9:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                case 10:
                    message.goldValue = reader.uint32();
                    break;
                case 11:
                    message.gameID = reader.string();
                    break;
                case 12:
                    message.buff = reader.string();
                    break;
                case 13:
                    message.area = reader.string();
                    break;
                case 14:
                    message.per = reader.uint32();
                    break;
                case 15:
                    if (!(message.jackpot && message.jackpot.length))
                        message.jackpot = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.jackpot.push(reader.uint32());
                    } else
                        message.jackpot.push(reader.uint32());
                    break;
                case 16:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoSpartaGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoSpartaGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoSpartaGameStartResp} ProtoSpartaGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoSpartaGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoSpartaGameStartResp message.
         * @function verify
         * @memberof mini.ProtoSpartaGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoSpartaGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.freeResult != null && message.hasOwnProperty("freeResult")) {
                if (!Array.isArray(message.freeResult))
                    return "freeResult: array expected";
                for (let i = 0; i < message.freeResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.freeResult[i]);
                    if (error)
                        return "freeResult." + error;
                }
            }
            if (message.superResult != null && message.hasOwnProperty("superResult")) {
                if (!Array.isArray(message.superResult))
                    return "superResult: array expected";
                for (let i = 0; i < message.superResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.superResult[i]);
                    if (error)
                        return "superResult." + error;
                }
            }
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (let i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            if (message.goldValue != null && message.hasOwnProperty("goldValue"))
                if (!$util.isInteger(message.goldValue))
                    return "goldValue: integer expected";
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.jackpot != null && message.hasOwnProperty("jackpot")) {
                if (!Array.isArray(message.jackpot))
                    return "jackpot: array expected";
                for (let i = 0; i < message.jackpot.length; ++i)
                    if (!$util.isInteger(message.jackpot[i]))
                        return "jackpot: integer[] expected";
            }
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoSpartaGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoSpartaGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoSpartaGameStartResp} ProtoSpartaGameStartResp
         */
        ProtoSpartaGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoSpartaGameStartResp)
                return object;
            let message = new $root.mini.ProtoSpartaGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoSpartaGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoSpartaGameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoSpartaGameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoSpartaGameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.freeResult) {
                if (!Array.isArray(object.freeResult))
                    throw TypeError(".mini.ProtoSpartaGameStartResp.freeResult: array expected");
                message.freeResult = [];
                for (let i = 0; i < object.freeResult.length; ++i) {
                    if (typeof object.freeResult[i] !== "object")
                        throw TypeError(".mini.ProtoSpartaGameStartResp.freeResult: object expected");
                    message.freeResult[i] = $root.mini.FreeSpin.fromObject(object.freeResult[i]);
                }
            }
            if (object.superResult) {
                if (!Array.isArray(object.superResult))
                    throw TypeError(".mini.ProtoSpartaGameStartResp.superResult: array expected");
                message.superResult = [];
                for (let i = 0; i < object.superResult.length; ++i) {
                    if (typeof object.superResult[i] !== "object")
                        throw TypeError(".mini.ProtoSpartaGameStartResp.superResult: object expected");
                    message.superResult[i] = $root.mini.FreeSpin.fromObject(object.superResult[i]);
                }
            }
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".mini.ProtoSpartaGameStartResp.param: array expected");
                message.param = [];
                for (let i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            if (object.goldValue != null)
                message.goldValue = object.goldValue >>> 0;
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.jackpot) {
                if (!Array.isArray(object.jackpot))
                    throw TypeError(".mini.ProtoSpartaGameStartResp.jackpot: array expected");
                message.jackpot = [];
                for (let i = 0; i < object.jackpot.length; ++i)
                    message.jackpot[i] = object.jackpot[i] >>> 0;
            }
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoSpartaGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoSpartaGameStartResp
         * @static
         * @param {mini.ProtoSpartaGameStartResp} message ProtoSpartaGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoSpartaGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.freeResult = [];
                object.superResult = [];
                object.param = [];
                object.jackpot = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.goldValue = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.freeResult && message.freeResult.length) {
                object.freeResult = [];
                for (let j = 0; j < message.freeResult.length; ++j)
                    object.freeResult[j] = $root.mini.FreeSpin.toObject(message.freeResult[j], options);
            }
            if (message.superResult && message.superResult.length) {
                object.superResult = [];
                for (let j = 0; j < message.superResult.length; ++j)
                    object.superResult[j] = $root.mini.FreeSpin.toObject(message.superResult[j], options);
            }
            if (message.param && message.param.length) {
                object.param = [];
                for (let j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            if (message.goldValue != null && message.hasOwnProperty("goldValue"))
                object.goldValue = message.goldValue;
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.jackpot && message.jackpot.length) {
                object.jackpot = [];
                for (let j = 0; j < message.jackpot.length; ++j)
                    object.jackpot[j] = message.jackpot[j];
            }
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoSpartaGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoSpartaGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoSpartaGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoSpartaGameStartResp;
    })();

    mini.ProtoMoneyBlockReq = (function() {

        /**
         * Properties of a ProtoMoneyBlockReq.
         * @memberof mini
         * @interface IProtoMoneyBlockReq
         * @property {number|null} [gameType] ProtoMoneyBlockReq gameType
         */

        /**
         * Constructs a new ProtoMoneyBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoMoneyBlockReq.
         * @implements IProtoMoneyBlockReq
         * @constructor
         * @param {mini.IProtoMoneyBlockReq=} [properties] Properties to set
         */
        function ProtoMoneyBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoMoneyBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoMoneyBlockReq
         * @instance
         */
        ProtoMoneyBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoMoneyBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoMoneyBlockReq
         * @static
         * @param {mini.IProtoMoneyBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoMoneyBlockReq} ProtoMoneyBlockReq instance
         */
        ProtoMoneyBlockReq.create = function create(properties) {
            return new ProtoMoneyBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoMoneyBlockReq message. Does not implicitly {@link mini.ProtoMoneyBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoMoneyBlockReq
         * @static
         * @param {mini.IProtoMoneyBlockReq} message ProtoMoneyBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoMoneyBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoMoneyBlockReq message, length delimited. Does not implicitly {@link mini.ProtoMoneyBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoMoneyBlockReq
         * @static
         * @param {mini.IProtoMoneyBlockReq} message ProtoMoneyBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoMoneyBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoMoneyBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoMoneyBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoMoneyBlockReq} ProtoMoneyBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoMoneyBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoMoneyBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoMoneyBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoMoneyBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoMoneyBlockReq} ProtoMoneyBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoMoneyBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoMoneyBlockReq message.
         * @function verify
         * @memberof mini.ProtoMoneyBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoMoneyBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoMoneyBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoMoneyBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoMoneyBlockReq} ProtoMoneyBlockReq
         */
        ProtoMoneyBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoMoneyBlockReq)
                return object;
            let message = new $root.mini.ProtoMoneyBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoMoneyBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoMoneyBlockReq
         * @static
         * @param {mini.ProtoMoneyBlockReq} message ProtoMoneyBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoMoneyBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoMoneyBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoMoneyBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoMoneyBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoMoneyBlockReq;
    })();

    mini.ProtoMoneyBlockResp = (function() {

        /**
         * Properties of a ProtoMoneyBlockResp.
         * @memberof mini
         * @interface IProtoMoneyBlockResp
         * @property {Array.<number>|null} [block] ProtoMoneyBlockResp block
         */

        /**
         * Constructs a new ProtoMoneyBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoMoneyBlockResp.
         * @implements IProtoMoneyBlockResp
         * @constructor
         * @param {mini.IProtoMoneyBlockResp=} [properties] Properties to set
         */
        function ProtoMoneyBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoMoneyBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoMoneyBlockResp
         * @instance
         */
        ProtoMoneyBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoMoneyBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoMoneyBlockResp
         * @static
         * @param {mini.IProtoMoneyBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoMoneyBlockResp} ProtoMoneyBlockResp instance
         */
        ProtoMoneyBlockResp.create = function create(properties) {
            return new ProtoMoneyBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoMoneyBlockResp message. Does not implicitly {@link mini.ProtoMoneyBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoMoneyBlockResp
         * @static
         * @param {mini.IProtoMoneyBlockResp} message ProtoMoneyBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoMoneyBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoMoneyBlockResp message, length delimited. Does not implicitly {@link mini.ProtoMoneyBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoMoneyBlockResp
         * @static
         * @param {mini.IProtoMoneyBlockResp} message ProtoMoneyBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoMoneyBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoMoneyBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoMoneyBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoMoneyBlockResp} ProtoMoneyBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoMoneyBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoMoneyBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoMoneyBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoMoneyBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoMoneyBlockResp} ProtoMoneyBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoMoneyBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoMoneyBlockResp message.
         * @function verify
         * @memberof mini.ProtoMoneyBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoMoneyBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoMoneyBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoMoneyBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoMoneyBlockResp} ProtoMoneyBlockResp
         */
        ProtoMoneyBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoMoneyBlockResp)
                return object;
            let message = new $root.mini.ProtoMoneyBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoMoneyBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoMoneyBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoMoneyBlockResp
         * @static
         * @param {mini.ProtoMoneyBlockResp} message ProtoMoneyBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoMoneyBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoMoneyBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoMoneyBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoMoneyBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoMoneyBlockResp;
    })();

    mini.ProtoMoneyGameStartReq = (function() {

        /**
         * Properties of a ProtoMoneyGameStartReq.
         * @memberof mini
         * @interface IProtoMoneyGameStartReq
         * @property {number|null} [score] ProtoMoneyGameStartReq score
         * @property {number|null} [type] ProtoMoneyGameStartReq type
         * @property {number|null} [area] ProtoMoneyGameStartReq area
         * @property {number|null} [buff] ProtoMoneyGameStartReq buff
         */

        /**
         * Constructs a new ProtoMoneyGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoMoneyGameStartReq.
         * @implements IProtoMoneyGameStartReq
         * @constructor
         * @param {mini.IProtoMoneyGameStartReq=} [properties] Properties to set
         */
        function ProtoMoneyGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoMoneyGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoMoneyGameStartReq
         * @instance
         */
        ProtoMoneyGameStartReq.prototype.score = 0;

        /**
         * ProtoMoneyGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoMoneyGameStartReq
         * @instance
         */
        ProtoMoneyGameStartReq.prototype.type = 0;

        /**
         * ProtoMoneyGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoMoneyGameStartReq
         * @instance
         */
        ProtoMoneyGameStartReq.prototype.area = 0;

        /**
         * ProtoMoneyGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoMoneyGameStartReq
         * @instance
         */
        ProtoMoneyGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoMoneyGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoMoneyGameStartReq
         * @static
         * @param {mini.IProtoMoneyGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoMoneyGameStartReq} ProtoMoneyGameStartReq instance
         */
        ProtoMoneyGameStartReq.create = function create(properties) {
            return new ProtoMoneyGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoMoneyGameStartReq message. Does not implicitly {@link mini.ProtoMoneyGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoMoneyGameStartReq
         * @static
         * @param {mini.IProtoMoneyGameStartReq} message ProtoMoneyGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoMoneyGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoMoneyGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoMoneyGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoMoneyGameStartReq
         * @static
         * @param {mini.IProtoMoneyGameStartReq} message ProtoMoneyGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoMoneyGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoMoneyGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoMoneyGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoMoneyGameStartReq} ProtoMoneyGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoMoneyGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoMoneyGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoMoneyGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoMoneyGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoMoneyGameStartReq} ProtoMoneyGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoMoneyGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoMoneyGameStartReq message.
         * @function verify
         * @memberof mini.ProtoMoneyGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoMoneyGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoMoneyGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoMoneyGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoMoneyGameStartReq} ProtoMoneyGameStartReq
         */
        ProtoMoneyGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoMoneyGameStartReq)
                return object;
            let message = new $root.mini.ProtoMoneyGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoMoneyGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoMoneyGameStartReq
         * @static
         * @param {mini.ProtoMoneyGameStartReq} message ProtoMoneyGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoMoneyGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoMoneyGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoMoneyGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoMoneyGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoMoneyGameStartReq;
    })();

    mini.ProtoMoneyGameStartResp = (function() {

        /**
         * Properties of a ProtoMoneyGameStartResp.
         * @memberof mini
         * @interface IProtoMoneyGameStartResp
         * @property {number|null} [stage2Count] ProtoMoneyGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoMoneyGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoMoneyGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoMoneyGameStartResp itemInfo
         * @property {Array.<mini.IFreeSpin>|null} [zeroResult] ProtoMoneyGameStartResp zeroResult
         * @property {Array.<mini.IFreeSpin>|null} [redResult] ProtoMoneyGameStartResp redResult
         * @property {string|null} [gameID] ProtoMoneyGameStartResp gameID
         * @property {string|null} [buff] ProtoMoneyGameStartResp buff
         * @property {string|null} [area] ProtoMoneyGameStartResp area
         * @property {number|null} [per] ProtoMoneyGameStartResp per
         * @property {number|null} [errorCode] ProtoMoneyGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoMoneyGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoMoneyGameStartResp.
         * @implements IProtoMoneyGameStartResp
         * @constructor
         * @param {mini.IProtoMoneyGameStartResp=} [properties] Properties to set
         */
        function ProtoMoneyGameStartResp(properties) {
            this.itemInfo = [];
            this.zeroResult = [];
            this.redResult = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoMoneyGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoMoneyGameStartResp
         * @instance
         */
        ProtoMoneyGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoMoneyGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoMoneyGameStartResp
         * @instance
         */
        ProtoMoneyGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoMoneyGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoMoneyGameStartResp
         * @instance
         */
        ProtoMoneyGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoMoneyGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoMoneyGameStartResp
         * @instance
         */
        ProtoMoneyGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoMoneyGameStartResp zeroResult.
         * @member {Array.<mini.IFreeSpin>} zeroResult
         * @memberof mini.ProtoMoneyGameStartResp
         * @instance
         */
        ProtoMoneyGameStartResp.prototype.zeroResult = $util.emptyArray;

        /**
         * ProtoMoneyGameStartResp redResult.
         * @member {Array.<mini.IFreeSpin>} redResult
         * @memberof mini.ProtoMoneyGameStartResp
         * @instance
         */
        ProtoMoneyGameStartResp.prototype.redResult = $util.emptyArray;

        /**
         * ProtoMoneyGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoMoneyGameStartResp
         * @instance
         */
        ProtoMoneyGameStartResp.prototype.gameID = "";

        /**
         * ProtoMoneyGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoMoneyGameStartResp
         * @instance
         */
        ProtoMoneyGameStartResp.prototype.buff = "";

        /**
         * ProtoMoneyGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoMoneyGameStartResp
         * @instance
         */
        ProtoMoneyGameStartResp.prototype.area = "";

        /**
         * ProtoMoneyGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoMoneyGameStartResp
         * @instance
         */
        ProtoMoneyGameStartResp.prototype.per = 0;

        /**
         * ProtoMoneyGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoMoneyGameStartResp
         * @instance
         */
        ProtoMoneyGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoMoneyGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoMoneyGameStartResp
         * @static
         * @param {mini.IProtoMoneyGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoMoneyGameStartResp} ProtoMoneyGameStartResp instance
         */
        ProtoMoneyGameStartResp.create = function create(properties) {
            return new ProtoMoneyGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoMoneyGameStartResp message. Does not implicitly {@link mini.ProtoMoneyGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoMoneyGameStartResp
         * @static
         * @param {mini.IProtoMoneyGameStartResp} message ProtoMoneyGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoMoneyGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.zeroResult != null && message.zeroResult.length)
                for (let i = 0; i < message.zeroResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.zeroResult[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.redResult != null && message.redResult.length)
                for (let i = 0; i < message.redResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.redResult[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.per);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoMoneyGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoMoneyGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoMoneyGameStartResp
         * @static
         * @param {mini.IProtoMoneyGameStartResp} message ProtoMoneyGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoMoneyGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoMoneyGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoMoneyGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoMoneyGameStartResp} ProtoMoneyGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoMoneyGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoMoneyGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.zeroResult && message.zeroResult.length))
                        message.zeroResult = [];
                    message.zeroResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.redResult && message.redResult.length))
                        message.redResult = [];
                    message.redResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.gameID = reader.string();
                    break;
                case 8:
                    message.buff = reader.string();
                    break;
                case 9:
                    message.area = reader.string();
                    break;
                case 10:
                    message.per = reader.uint32();
                    break;
                case 11:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoMoneyGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoMoneyGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoMoneyGameStartResp} ProtoMoneyGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoMoneyGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoMoneyGameStartResp message.
         * @function verify
         * @memberof mini.ProtoMoneyGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoMoneyGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.zeroResult != null && message.hasOwnProperty("zeroResult")) {
                if (!Array.isArray(message.zeroResult))
                    return "zeroResult: array expected";
                for (let i = 0; i < message.zeroResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.zeroResult[i]);
                    if (error)
                        return "zeroResult." + error;
                }
            }
            if (message.redResult != null && message.hasOwnProperty("redResult")) {
                if (!Array.isArray(message.redResult))
                    return "redResult: array expected";
                for (let i = 0; i < message.redResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.redResult[i]);
                    if (error)
                        return "redResult." + error;
                }
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoMoneyGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoMoneyGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoMoneyGameStartResp} ProtoMoneyGameStartResp
         */
        ProtoMoneyGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoMoneyGameStartResp)
                return object;
            let message = new $root.mini.ProtoMoneyGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoMoneyGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.zeroResult) {
                if (!Array.isArray(object.zeroResult))
                    throw TypeError(".mini.ProtoMoneyGameStartResp.zeroResult: array expected");
                message.zeroResult = [];
                for (let i = 0; i < object.zeroResult.length; ++i) {
                    if (typeof object.zeroResult[i] !== "object")
                        throw TypeError(".mini.ProtoMoneyGameStartResp.zeroResult: object expected");
                    message.zeroResult[i] = $root.mini.FreeSpin.fromObject(object.zeroResult[i]);
                }
            }
            if (object.redResult) {
                if (!Array.isArray(object.redResult))
                    throw TypeError(".mini.ProtoMoneyGameStartResp.redResult: array expected");
                message.redResult = [];
                for (let i = 0; i < object.redResult.length; ++i) {
                    if (typeof object.redResult[i] !== "object")
                        throw TypeError(".mini.ProtoMoneyGameStartResp.redResult: object expected");
                    message.redResult[i] = $root.mini.FreeSpin.fromObject(object.redResult[i]);
                }
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoMoneyGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoMoneyGameStartResp
         * @static
         * @param {mini.ProtoMoneyGameStartResp} message ProtoMoneyGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoMoneyGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.zeroResult = [];
                object.redResult = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.zeroResult && message.zeroResult.length) {
                object.zeroResult = [];
                for (let j = 0; j < message.zeroResult.length; ++j)
                    object.zeroResult[j] = $root.mini.FreeSpin.toObject(message.zeroResult[j], options);
            }
            if (message.redResult && message.redResult.length) {
                object.redResult = [];
                for (let j = 0; j < message.redResult.length; ++j)
                    object.redResult[j] = $root.mini.FreeSpin.toObject(message.redResult[j], options);
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoMoneyGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoMoneyGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoMoneyGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoMoneyGameStartResp;
    })();

    mini.ProtoTigerBlockReq = (function() {

        /**
         * Properties of a ProtoTigerBlockReq.
         * @memberof mini
         * @interface IProtoTigerBlockReq
         * @property {number|null} [gameType] ProtoTigerBlockReq gameType
         */

        /**
         * Constructs a new ProtoTigerBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoTigerBlockReq.
         * @implements IProtoTigerBlockReq
         * @constructor
         * @param {mini.IProtoTigerBlockReq=} [properties] Properties to set
         */
        function ProtoTigerBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoTigerBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoTigerBlockReq
         * @instance
         */
        ProtoTigerBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoTigerBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoTigerBlockReq
         * @static
         * @param {mini.IProtoTigerBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoTigerBlockReq} ProtoTigerBlockReq instance
         */
        ProtoTigerBlockReq.create = function create(properties) {
            return new ProtoTigerBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoTigerBlockReq message. Does not implicitly {@link mini.ProtoTigerBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoTigerBlockReq
         * @static
         * @param {mini.IProtoTigerBlockReq} message ProtoTigerBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTigerBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoTigerBlockReq message, length delimited. Does not implicitly {@link mini.ProtoTigerBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoTigerBlockReq
         * @static
         * @param {mini.IProtoTigerBlockReq} message ProtoTigerBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTigerBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoTigerBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoTigerBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoTigerBlockReq} ProtoTigerBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTigerBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoTigerBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoTigerBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoTigerBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoTigerBlockReq} ProtoTigerBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTigerBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoTigerBlockReq message.
         * @function verify
         * @memberof mini.ProtoTigerBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoTigerBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoTigerBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoTigerBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoTigerBlockReq} ProtoTigerBlockReq
         */
        ProtoTigerBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoTigerBlockReq)
                return object;
            let message = new $root.mini.ProtoTigerBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoTigerBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoTigerBlockReq
         * @static
         * @param {mini.ProtoTigerBlockReq} message ProtoTigerBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoTigerBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoTigerBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoTigerBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoTigerBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoTigerBlockReq;
    })();

    mini.ProtoTigerBlockResp = (function() {

        /**
         * Properties of a ProtoTigerBlockResp.
         * @memberof mini
         * @interface IProtoTigerBlockResp
         * @property {Array.<number>|null} [block] ProtoTigerBlockResp block
         */

        /**
         * Constructs a new ProtoTigerBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoTigerBlockResp.
         * @implements IProtoTigerBlockResp
         * @constructor
         * @param {mini.IProtoTigerBlockResp=} [properties] Properties to set
         */
        function ProtoTigerBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoTigerBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoTigerBlockResp
         * @instance
         */
        ProtoTigerBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoTigerBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoTigerBlockResp
         * @static
         * @param {mini.IProtoTigerBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoTigerBlockResp} ProtoTigerBlockResp instance
         */
        ProtoTigerBlockResp.create = function create(properties) {
            return new ProtoTigerBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoTigerBlockResp message. Does not implicitly {@link mini.ProtoTigerBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoTigerBlockResp
         * @static
         * @param {mini.IProtoTigerBlockResp} message ProtoTigerBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTigerBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoTigerBlockResp message, length delimited. Does not implicitly {@link mini.ProtoTigerBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoTigerBlockResp
         * @static
         * @param {mini.IProtoTigerBlockResp} message ProtoTigerBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTigerBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoTigerBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoTigerBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoTigerBlockResp} ProtoTigerBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTigerBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoTigerBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoTigerBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoTigerBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoTigerBlockResp} ProtoTigerBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTigerBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoTigerBlockResp message.
         * @function verify
         * @memberof mini.ProtoTigerBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoTigerBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoTigerBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoTigerBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoTigerBlockResp} ProtoTigerBlockResp
         */
        ProtoTigerBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoTigerBlockResp)
                return object;
            let message = new $root.mini.ProtoTigerBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoTigerBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoTigerBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoTigerBlockResp
         * @static
         * @param {mini.ProtoTigerBlockResp} message ProtoTigerBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoTigerBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoTigerBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoTigerBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoTigerBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoTigerBlockResp;
    })();

    mini.ProtoTigerGameStartReq = (function() {

        /**
         * Properties of a ProtoTigerGameStartReq.
         * @memberof mini
         * @interface IProtoTigerGameStartReq
         * @property {number|null} [score] ProtoTigerGameStartReq score
         * @property {number|null} [type] ProtoTigerGameStartReq type
         * @property {number|null} [area] ProtoTigerGameStartReq area
         * @property {number|null} [buff] ProtoTigerGameStartReq buff
         */

        /**
         * Constructs a new ProtoTigerGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoTigerGameStartReq.
         * @implements IProtoTigerGameStartReq
         * @constructor
         * @param {mini.IProtoTigerGameStartReq=} [properties] Properties to set
         */
        function ProtoTigerGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoTigerGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoTigerGameStartReq
         * @instance
         */
        ProtoTigerGameStartReq.prototype.score = 0;

        /**
         * ProtoTigerGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoTigerGameStartReq
         * @instance
         */
        ProtoTigerGameStartReq.prototype.type = 0;

        /**
         * ProtoTigerGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoTigerGameStartReq
         * @instance
         */
        ProtoTigerGameStartReq.prototype.area = 0;

        /**
         * ProtoTigerGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoTigerGameStartReq
         * @instance
         */
        ProtoTigerGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoTigerGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoTigerGameStartReq
         * @static
         * @param {mini.IProtoTigerGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoTigerGameStartReq} ProtoTigerGameStartReq instance
         */
        ProtoTigerGameStartReq.create = function create(properties) {
            return new ProtoTigerGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoTigerGameStartReq message. Does not implicitly {@link mini.ProtoTigerGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoTigerGameStartReq
         * @static
         * @param {mini.IProtoTigerGameStartReq} message ProtoTigerGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTigerGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoTigerGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoTigerGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoTigerGameStartReq
         * @static
         * @param {mini.IProtoTigerGameStartReq} message ProtoTigerGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTigerGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoTigerGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoTigerGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoTigerGameStartReq} ProtoTigerGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTigerGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoTigerGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoTigerGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoTigerGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoTigerGameStartReq} ProtoTigerGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTigerGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoTigerGameStartReq message.
         * @function verify
         * @memberof mini.ProtoTigerGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoTigerGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoTigerGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoTigerGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoTigerGameStartReq} ProtoTigerGameStartReq
         */
        ProtoTigerGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoTigerGameStartReq)
                return object;
            let message = new $root.mini.ProtoTigerGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoTigerGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoTigerGameStartReq
         * @static
         * @param {mini.ProtoTigerGameStartReq} message ProtoTigerGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoTigerGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoTigerGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoTigerGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoTigerGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoTigerGameStartReq;
    })();

    mini.ProtoTigerGameStartResp = (function() {

        /**
         * Properties of a ProtoTigerGameStartResp.
         * @memberof mini
         * @interface IProtoTigerGameStartResp
         * @property {number|null} [stage2Count] ProtoTigerGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoTigerGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoTigerGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoTigerGameStartResp itemInfo
         * @property {string|null} [gameID] ProtoTigerGameStartResp gameID
         * @property {string|null} [buff] ProtoTigerGameStartResp buff
         * @property {string|null} [area] ProtoTigerGameStartResp area
         * @property {number|null} [per] ProtoTigerGameStartResp per
         * @property {number|null} [errorCode] ProtoTigerGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoTigerGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoTigerGameStartResp.
         * @implements IProtoTigerGameStartResp
         * @constructor
         * @param {mini.IProtoTigerGameStartResp=} [properties] Properties to set
         */
        function ProtoTigerGameStartResp(properties) {
            this.itemInfo = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoTigerGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoTigerGameStartResp
         * @instance
         */
        ProtoTigerGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoTigerGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoTigerGameStartResp
         * @instance
         */
        ProtoTigerGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoTigerGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoTigerGameStartResp
         * @instance
         */
        ProtoTigerGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoTigerGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoTigerGameStartResp
         * @instance
         */
        ProtoTigerGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoTigerGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoTigerGameStartResp
         * @instance
         */
        ProtoTigerGameStartResp.prototype.gameID = "";

        /**
         * ProtoTigerGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoTigerGameStartResp
         * @instance
         */
        ProtoTigerGameStartResp.prototype.buff = "";

        /**
         * ProtoTigerGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoTigerGameStartResp
         * @instance
         */
        ProtoTigerGameStartResp.prototype.area = "";

        /**
         * ProtoTigerGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoTigerGameStartResp
         * @instance
         */
        ProtoTigerGameStartResp.prototype.per = 0;

        /**
         * ProtoTigerGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoTigerGameStartResp
         * @instance
         */
        ProtoTigerGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoTigerGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoTigerGameStartResp
         * @static
         * @param {mini.IProtoTigerGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoTigerGameStartResp} ProtoTigerGameStartResp instance
         */
        ProtoTigerGameStartResp.create = function create(properties) {
            return new ProtoTigerGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoTigerGameStartResp message. Does not implicitly {@link mini.ProtoTigerGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoTigerGameStartResp
         * @static
         * @param {mini.IProtoTigerGameStartResp} message ProtoTigerGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTigerGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.per);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoTigerGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoTigerGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoTigerGameStartResp
         * @static
         * @param {mini.IProtoTigerGameStartResp} message ProtoTigerGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTigerGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoTigerGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoTigerGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoTigerGameStartResp} ProtoTigerGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTigerGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoTigerGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    message.gameID = reader.string();
                    break;
                case 6:
                    message.buff = reader.string();
                    break;
                case 7:
                    message.area = reader.string();
                    break;
                case 8:
                    message.per = reader.uint32();
                    break;
                case 9:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoTigerGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoTigerGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoTigerGameStartResp} ProtoTigerGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTigerGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoTigerGameStartResp message.
         * @function verify
         * @memberof mini.ProtoTigerGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoTigerGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoTigerGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoTigerGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoTigerGameStartResp} ProtoTigerGameStartResp
         */
        ProtoTigerGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoTigerGameStartResp)
                return object;
            let message = new $root.mini.ProtoTigerGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoTigerGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoTigerGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoTigerGameStartResp
         * @static
         * @param {mini.ProtoTigerGameStartResp} message ProtoTigerGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoTigerGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.itemInfo = [];
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoTigerGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoTigerGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoTigerGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoTigerGameStartResp;
    })();

    mini.ProtoZeus02BlockReq = (function() {

        /**
         * Properties of a ProtoZeus02BlockReq.
         * @memberof mini
         * @interface IProtoZeus02BlockReq
         * @property {number|null} [gameType] ProtoZeus02BlockReq gameType
         */

        /**
         * Constructs a new ProtoZeus02BlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoZeus02BlockReq.
         * @implements IProtoZeus02BlockReq
         * @constructor
         * @param {mini.IProtoZeus02BlockReq=} [properties] Properties to set
         */
        function ProtoZeus02BlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoZeus02BlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoZeus02BlockReq
         * @instance
         */
        ProtoZeus02BlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoZeus02BlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoZeus02BlockReq
         * @static
         * @param {mini.IProtoZeus02BlockReq=} [properties] Properties to set
         * @returns {mini.ProtoZeus02BlockReq} ProtoZeus02BlockReq instance
         */
        ProtoZeus02BlockReq.create = function create(properties) {
            return new ProtoZeus02BlockReq(properties);
        };

        /**
         * Encodes the specified ProtoZeus02BlockReq message. Does not implicitly {@link mini.ProtoZeus02BlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoZeus02BlockReq
         * @static
         * @param {mini.IProtoZeus02BlockReq} message ProtoZeus02BlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeus02BlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoZeus02BlockReq message, length delimited. Does not implicitly {@link mini.ProtoZeus02BlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoZeus02BlockReq
         * @static
         * @param {mini.IProtoZeus02BlockReq} message ProtoZeus02BlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeus02BlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoZeus02BlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoZeus02BlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoZeus02BlockReq} ProtoZeus02BlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeus02BlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoZeus02BlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoZeus02BlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoZeus02BlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoZeus02BlockReq} ProtoZeus02BlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeus02BlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoZeus02BlockReq message.
         * @function verify
         * @memberof mini.ProtoZeus02BlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoZeus02BlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoZeus02BlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoZeus02BlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoZeus02BlockReq} ProtoZeus02BlockReq
         */
        ProtoZeus02BlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoZeus02BlockReq)
                return object;
            let message = new $root.mini.ProtoZeus02BlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoZeus02BlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoZeus02BlockReq
         * @static
         * @param {mini.ProtoZeus02BlockReq} message ProtoZeus02BlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoZeus02BlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoZeus02BlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoZeus02BlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoZeus02BlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoZeus02BlockReq;
    })();

    mini.ProtoZeus02BlockResp = (function() {

        /**
         * Properties of a ProtoZeus02BlockResp.
         * @memberof mini
         * @interface IProtoZeus02BlockResp
         * @property {Array.<number>|null} [block] ProtoZeus02BlockResp block
         */

        /**
         * Constructs a new ProtoZeus02BlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoZeus02BlockResp.
         * @implements IProtoZeus02BlockResp
         * @constructor
         * @param {mini.IProtoZeus02BlockResp=} [properties] Properties to set
         */
        function ProtoZeus02BlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoZeus02BlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoZeus02BlockResp
         * @instance
         */
        ProtoZeus02BlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoZeus02BlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoZeus02BlockResp
         * @static
         * @param {mini.IProtoZeus02BlockResp=} [properties] Properties to set
         * @returns {mini.ProtoZeus02BlockResp} ProtoZeus02BlockResp instance
         */
        ProtoZeus02BlockResp.create = function create(properties) {
            return new ProtoZeus02BlockResp(properties);
        };

        /**
         * Encodes the specified ProtoZeus02BlockResp message. Does not implicitly {@link mini.ProtoZeus02BlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoZeus02BlockResp
         * @static
         * @param {mini.IProtoZeus02BlockResp} message ProtoZeus02BlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeus02BlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoZeus02BlockResp message, length delimited. Does not implicitly {@link mini.ProtoZeus02BlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoZeus02BlockResp
         * @static
         * @param {mini.IProtoZeus02BlockResp} message ProtoZeus02BlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeus02BlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoZeus02BlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoZeus02BlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoZeus02BlockResp} ProtoZeus02BlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeus02BlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoZeus02BlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoZeus02BlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoZeus02BlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoZeus02BlockResp} ProtoZeus02BlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeus02BlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoZeus02BlockResp message.
         * @function verify
         * @memberof mini.ProtoZeus02BlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoZeus02BlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoZeus02BlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoZeus02BlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoZeus02BlockResp} ProtoZeus02BlockResp
         */
        ProtoZeus02BlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoZeus02BlockResp)
                return object;
            let message = new $root.mini.ProtoZeus02BlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoZeus02BlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoZeus02BlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoZeus02BlockResp
         * @static
         * @param {mini.ProtoZeus02BlockResp} message ProtoZeus02BlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoZeus02BlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoZeus02BlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoZeus02BlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoZeus02BlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoZeus02BlockResp;
    })();

    mini.ProtoZeus02GameStartReq = (function() {

        /**
         * Properties of a ProtoZeus02GameStartReq.
         * @memberof mini
         * @interface IProtoZeus02GameStartReq
         * @property {number|null} [score] ProtoZeus02GameStartReq score
         * @property {number|null} [type] ProtoZeus02GameStartReq type
         * @property {number|null} [area] ProtoZeus02GameStartReq area
         * @property {number|null} [buff] ProtoZeus02GameStartReq buff
         */

        /**
         * Constructs a new ProtoZeus02GameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoZeus02GameStartReq.
         * @implements IProtoZeus02GameStartReq
         * @constructor
         * @param {mini.IProtoZeus02GameStartReq=} [properties] Properties to set
         */
        function ProtoZeus02GameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoZeus02GameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoZeus02GameStartReq
         * @instance
         */
        ProtoZeus02GameStartReq.prototype.score = 0;

        /**
         * ProtoZeus02GameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoZeus02GameStartReq
         * @instance
         */
        ProtoZeus02GameStartReq.prototype.type = 0;

        /**
         * ProtoZeus02GameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoZeus02GameStartReq
         * @instance
         */
        ProtoZeus02GameStartReq.prototype.area = 0;

        /**
         * ProtoZeus02GameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoZeus02GameStartReq
         * @instance
         */
        ProtoZeus02GameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoZeus02GameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoZeus02GameStartReq
         * @static
         * @param {mini.IProtoZeus02GameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoZeus02GameStartReq} ProtoZeus02GameStartReq instance
         */
        ProtoZeus02GameStartReq.create = function create(properties) {
            return new ProtoZeus02GameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoZeus02GameStartReq message. Does not implicitly {@link mini.ProtoZeus02GameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoZeus02GameStartReq
         * @static
         * @param {mini.IProtoZeus02GameStartReq} message ProtoZeus02GameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeus02GameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoZeus02GameStartReq message, length delimited. Does not implicitly {@link mini.ProtoZeus02GameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoZeus02GameStartReq
         * @static
         * @param {mini.IProtoZeus02GameStartReq} message ProtoZeus02GameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeus02GameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoZeus02GameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoZeus02GameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoZeus02GameStartReq} ProtoZeus02GameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeus02GameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoZeus02GameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoZeus02GameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoZeus02GameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoZeus02GameStartReq} ProtoZeus02GameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeus02GameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoZeus02GameStartReq message.
         * @function verify
         * @memberof mini.ProtoZeus02GameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoZeus02GameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoZeus02GameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoZeus02GameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoZeus02GameStartReq} ProtoZeus02GameStartReq
         */
        ProtoZeus02GameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoZeus02GameStartReq)
                return object;
            let message = new $root.mini.ProtoZeus02GameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoZeus02GameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoZeus02GameStartReq
         * @static
         * @param {mini.ProtoZeus02GameStartReq} message ProtoZeus02GameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoZeus02GameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoZeus02GameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoZeus02GameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoZeus02GameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoZeus02GameStartReq;
    })();

    mini.ProtoZeus02GameStartResp = (function() {

        /**
         * Properties of a ProtoZeus02GameStartResp.
         * @memberof mini
         * @interface IProtoZeus02GameStartResp
         * @property {number|null} [stage2Count] ProtoZeus02GameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoZeus02GameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoZeus02GameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoZeus02GameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoZeus02GameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoZeus02GameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [freeResult] ProtoZeus02GameStartResp freeResult
         * @property {Array.<mini.IFreeSpin>|null} [superResult] ProtoZeus02GameStartResp superResult
         * @property {Array.<number>|null} [param] ProtoZeus02GameStartResp param
         * @property {number|null} [goldValue] ProtoZeus02GameStartResp goldValue
         * @property {string|null} [gameID] ProtoZeus02GameStartResp gameID
         * @property {string|null} [buff] ProtoZeus02GameStartResp buff
         * @property {string|null} [area] ProtoZeus02GameStartResp area
         * @property {number|null} [per] ProtoZeus02GameStartResp per
         * @property {Array.<number>|null} [jackpot] ProtoZeus02GameStartResp jackpot
         * @property {number|null} [errorCode] ProtoZeus02GameStartResp errorCode
         */

        /**
         * Constructs a new ProtoZeus02GameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoZeus02GameStartResp.
         * @implements IProtoZeus02GameStartResp
         * @constructor
         * @param {mini.IProtoZeus02GameStartResp=} [properties] Properties to set
         */
        function ProtoZeus02GameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.freeResult = [];
            this.superResult = [];
            this.param = [];
            this.jackpot = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoZeus02GameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoZeus02GameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoZeus02GameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoZeus02GameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoZeus02GameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoZeus02GameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoZeus02GameStartResp freeResult.
         * @member {Array.<mini.IFreeSpin>} freeResult
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.freeResult = $util.emptyArray;

        /**
         * ProtoZeus02GameStartResp superResult.
         * @member {Array.<mini.IFreeSpin>} superResult
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.superResult = $util.emptyArray;

        /**
         * ProtoZeus02GameStartResp param.
         * @member {Array.<number>} param
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.param = $util.emptyArray;

        /**
         * ProtoZeus02GameStartResp goldValue.
         * @member {number} goldValue
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.goldValue = 0;

        /**
         * ProtoZeus02GameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.gameID = "";

        /**
         * ProtoZeus02GameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.buff = "";

        /**
         * ProtoZeus02GameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.area = "";

        /**
         * ProtoZeus02GameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.per = 0;

        /**
         * ProtoZeus02GameStartResp jackpot.
         * @member {Array.<number>} jackpot
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.jackpot = $util.emptyArray;

        /**
         * ProtoZeus02GameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         */
        ProtoZeus02GameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoZeus02GameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoZeus02GameStartResp
         * @static
         * @param {mini.IProtoZeus02GameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoZeus02GameStartResp} ProtoZeus02GameStartResp instance
         */
        ProtoZeus02GameStartResp.create = function create(properties) {
            return new ProtoZeus02GameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoZeus02GameStartResp message. Does not implicitly {@link mini.ProtoZeus02GameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoZeus02GameStartResp
         * @static
         * @param {mini.IProtoZeus02GameStartResp} message ProtoZeus02GameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeus02GameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.freeResult != null && message.freeResult.length)
                for (let i = 0; i < message.freeResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.freeResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.superResult != null && message.superResult.length)
                for (let i = 0; i < message.superResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.superResult[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.param != null && message.param.length) {
                writer.uint32(/* id 9, wireType 2 =*/74).fork();
                for (let i = 0; i < message.param.length; ++i)
                    writer.int32(message.param[i]);
                writer.ldelim();
            }
            if (message.goldValue != null && Object.hasOwnProperty.call(message, "goldValue"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.goldValue);
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.per);
            if (message.jackpot != null && message.jackpot.length) {
                writer.uint32(/* id 15, wireType 2 =*/122).fork();
                for (let i = 0; i < message.jackpot.length; ++i)
                    writer.uint32(message.jackpot[i]);
                writer.ldelim();
            }
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoZeus02GameStartResp message, length delimited. Does not implicitly {@link mini.ProtoZeus02GameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoZeus02GameStartResp
         * @static
         * @param {mini.IProtoZeus02GameStartResp} message ProtoZeus02GameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoZeus02GameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoZeus02GameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoZeus02GameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoZeus02GameStartResp} ProtoZeus02GameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeus02GameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoZeus02GameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.freeResult && message.freeResult.length))
                        message.freeResult = [];
                    message.freeResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.superResult && message.superResult.length))
                        message.superResult = [];
                    message.superResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 9:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                case 10:
                    message.goldValue = reader.uint32();
                    break;
                case 11:
                    message.gameID = reader.string();
                    break;
                case 12:
                    message.buff = reader.string();
                    break;
                case 13:
                    message.area = reader.string();
                    break;
                case 14:
                    message.per = reader.uint32();
                    break;
                case 15:
                    if (!(message.jackpot && message.jackpot.length))
                        message.jackpot = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.jackpot.push(reader.uint32());
                    } else
                        message.jackpot.push(reader.uint32());
                    break;
                case 16:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoZeus02GameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoZeus02GameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoZeus02GameStartResp} ProtoZeus02GameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoZeus02GameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoZeus02GameStartResp message.
         * @function verify
         * @memberof mini.ProtoZeus02GameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoZeus02GameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.freeResult != null && message.hasOwnProperty("freeResult")) {
                if (!Array.isArray(message.freeResult))
                    return "freeResult: array expected";
                for (let i = 0; i < message.freeResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.freeResult[i]);
                    if (error)
                        return "freeResult." + error;
                }
            }
            if (message.superResult != null && message.hasOwnProperty("superResult")) {
                if (!Array.isArray(message.superResult))
                    return "superResult: array expected";
                for (let i = 0; i < message.superResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.superResult[i]);
                    if (error)
                        return "superResult." + error;
                }
            }
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (let i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            if (message.goldValue != null && message.hasOwnProperty("goldValue"))
                if (!$util.isInteger(message.goldValue))
                    return "goldValue: integer expected";
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.jackpot != null && message.hasOwnProperty("jackpot")) {
                if (!Array.isArray(message.jackpot))
                    return "jackpot: array expected";
                for (let i = 0; i < message.jackpot.length; ++i)
                    if (!$util.isInteger(message.jackpot[i]))
                        return "jackpot: integer[] expected";
            }
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoZeus02GameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoZeus02GameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoZeus02GameStartResp} ProtoZeus02GameStartResp
         */
        ProtoZeus02GameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoZeus02GameStartResp)
                return object;
            let message = new $root.mini.ProtoZeus02GameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoZeus02GameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoZeus02GameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoZeus02GameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoZeus02GameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.freeResult) {
                if (!Array.isArray(object.freeResult))
                    throw TypeError(".mini.ProtoZeus02GameStartResp.freeResult: array expected");
                message.freeResult = [];
                for (let i = 0; i < object.freeResult.length; ++i) {
                    if (typeof object.freeResult[i] !== "object")
                        throw TypeError(".mini.ProtoZeus02GameStartResp.freeResult: object expected");
                    message.freeResult[i] = $root.mini.FreeSpin.fromObject(object.freeResult[i]);
                }
            }
            if (object.superResult) {
                if (!Array.isArray(object.superResult))
                    throw TypeError(".mini.ProtoZeus02GameStartResp.superResult: array expected");
                message.superResult = [];
                for (let i = 0; i < object.superResult.length; ++i) {
                    if (typeof object.superResult[i] !== "object")
                        throw TypeError(".mini.ProtoZeus02GameStartResp.superResult: object expected");
                    message.superResult[i] = $root.mini.FreeSpin.fromObject(object.superResult[i]);
                }
            }
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".mini.ProtoZeus02GameStartResp.param: array expected");
                message.param = [];
                for (let i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            if (object.goldValue != null)
                message.goldValue = object.goldValue >>> 0;
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.jackpot) {
                if (!Array.isArray(object.jackpot))
                    throw TypeError(".mini.ProtoZeus02GameStartResp.jackpot: array expected");
                message.jackpot = [];
                for (let i = 0; i < object.jackpot.length; ++i)
                    message.jackpot[i] = object.jackpot[i] >>> 0;
            }
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoZeus02GameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoZeus02GameStartResp
         * @static
         * @param {mini.ProtoZeus02GameStartResp} message ProtoZeus02GameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoZeus02GameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.freeResult = [];
                object.superResult = [];
                object.param = [];
                object.jackpot = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.goldValue = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.freeResult && message.freeResult.length) {
                object.freeResult = [];
                for (let j = 0; j < message.freeResult.length; ++j)
                    object.freeResult[j] = $root.mini.FreeSpin.toObject(message.freeResult[j], options);
            }
            if (message.superResult && message.superResult.length) {
                object.superResult = [];
                for (let j = 0; j < message.superResult.length; ++j)
                    object.superResult[j] = $root.mini.FreeSpin.toObject(message.superResult[j], options);
            }
            if (message.param && message.param.length) {
                object.param = [];
                for (let j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            if (message.goldValue != null && message.hasOwnProperty("goldValue"))
                object.goldValue = message.goldValue;
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.jackpot && message.jackpot.length) {
                object.jackpot = [];
                for (let j = 0; j < message.jackpot.length; ++j)
                    object.jackpot[j] = message.jackpot[j];
            }
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoZeus02GameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoZeus02GameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoZeus02GameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoZeus02GameStartResp;
    })();

    mini.ProtoBullBlockReq = (function() {

        /**
         * Properties of a ProtoBullBlockReq.
         * @memberof mini
         * @interface IProtoBullBlockReq
         * @property {number|null} [gameType] ProtoBullBlockReq gameType
         */

        /**
         * Constructs a new ProtoBullBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoBullBlockReq.
         * @implements IProtoBullBlockReq
         * @constructor
         * @param {mini.IProtoBullBlockReq=} [properties] Properties to set
         */
        function ProtoBullBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoBullBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoBullBlockReq
         * @instance
         */
        ProtoBullBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoBullBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoBullBlockReq
         * @static
         * @param {mini.IProtoBullBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoBullBlockReq} ProtoBullBlockReq instance
         */
        ProtoBullBlockReq.create = function create(properties) {
            return new ProtoBullBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoBullBlockReq message. Does not implicitly {@link mini.ProtoBullBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoBullBlockReq
         * @static
         * @param {mini.IProtoBullBlockReq} message ProtoBullBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoBullBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoBullBlockReq message, length delimited. Does not implicitly {@link mini.ProtoBullBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoBullBlockReq
         * @static
         * @param {mini.IProtoBullBlockReq} message ProtoBullBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoBullBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoBullBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoBullBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoBullBlockReq} ProtoBullBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoBullBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoBullBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoBullBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoBullBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoBullBlockReq} ProtoBullBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoBullBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoBullBlockReq message.
         * @function verify
         * @memberof mini.ProtoBullBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoBullBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoBullBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoBullBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoBullBlockReq} ProtoBullBlockReq
         */
        ProtoBullBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoBullBlockReq)
                return object;
            let message = new $root.mini.ProtoBullBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoBullBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoBullBlockReq
         * @static
         * @param {mini.ProtoBullBlockReq} message ProtoBullBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoBullBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoBullBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoBullBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoBullBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoBullBlockReq;
    })();

    mini.ProtoBullBlockResp = (function() {

        /**
         * Properties of a ProtoBullBlockResp.
         * @memberof mini
         * @interface IProtoBullBlockResp
         * @property {Array.<number>|null} [block] ProtoBullBlockResp block
         */

        /**
         * Constructs a new ProtoBullBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoBullBlockResp.
         * @implements IProtoBullBlockResp
         * @constructor
         * @param {mini.IProtoBullBlockResp=} [properties] Properties to set
         */
        function ProtoBullBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoBullBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoBullBlockResp
         * @instance
         */
        ProtoBullBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoBullBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoBullBlockResp
         * @static
         * @param {mini.IProtoBullBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoBullBlockResp} ProtoBullBlockResp instance
         */
        ProtoBullBlockResp.create = function create(properties) {
            return new ProtoBullBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoBullBlockResp message. Does not implicitly {@link mini.ProtoBullBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoBullBlockResp
         * @static
         * @param {mini.IProtoBullBlockResp} message ProtoBullBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoBullBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoBullBlockResp message, length delimited. Does not implicitly {@link mini.ProtoBullBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoBullBlockResp
         * @static
         * @param {mini.IProtoBullBlockResp} message ProtoBullBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoBullBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoBullBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoBullBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoBullBlockResp} ProtoBullBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoBullBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoBullBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoBullBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoBullBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoBullBlockResp} ProtoBullBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoBullBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoBullBlockResp message.
         * @function verify
         * @memberof mini.ProtoBullBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoBullBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoBullBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoBullBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoBullBlockResp} ProtoBullBlockResp
         */
        ProtoBullBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoBullBlockResp)
                return object;
            let message = new $root.mini.ProtoBullBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoBullBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoBullBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoBullBlockResp
         * @static
         * @param {mini.ProtoBullBlockResp} message ProtoBullBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoBullBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoBullBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoBullBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoBullBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoBullBlockResp;
    })();

    mini.ProtoBullGameStartReq = (function() {

        /**
         * Properties of a ProtoBullGameStartReq.
         * @memberof mini
         * @interface IProtoBullGameStartReq
         * @property {number|null} [score] ProtoBullGameStartReq score
         * @property {number|null} [type] ProtoBullGameStartReq type
         * @property {number|null} [area] ProtoBullGameStartReq area
         * @property {number|null} [buff] ProtoBullGameStartReq buff
         */

        /**
         * Constructs a new ProtoBullGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoBullGameStartReq.
         * @implements IProtoBullGameStartReq
         * @constructor
         * @param {mini.IProtoBullGameStartReq=} [properties] Properties to set
         */
        function ProtoBullGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoBullGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoBullGameStartReq
         * @instance
         */
        ProtoBullGameStartReq.prototype.score = 0;

        /**
         * ProtoBullGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoBullGameStartReq
         * @instance
         */
        ProtoBullGameStartReq.prototype.type = 0;

        /**
         * ProtoBullGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoBullGameStartReq
         * @instance
         */
        ProtoBullGameStartReq.prototype.area = 0;

        /**
         * ProtoBullGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoBullGameStartReq
         * @instance
         */
        ProtoBullGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoBullGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoBullGameStartReq
         * @static
         * @param {mini.IProtoBullGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoBullGameStartReq} ProtoBullGameStartReq instance
         */
        ProtoBullGameStartReq.create = function create(properties) {
            return new ProtoBullGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoBullGameStartReq message. Does not implicitly {@link mini.ProtoBullGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoBullGameStartReq
         * @static
         * @param {mini.IProtoBullGameStartReq} message ProtoBullGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoBullGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoBullGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoBullGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoBullGameStartReq
         * @static
         * @param {mini.IProtoBullGameStartReq} message ProtoBullGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoBullGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoBullGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoBullGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoBullGameStartReq} ProtoBullGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoBullGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoBullGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoBullGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoBullGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoBullGameStartReq} ProtoBullGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoBullGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoBullGameStartReq message.
         * @function verify
         * @memberof mini.ProtoBullGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoBullGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoBullGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoBullGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoBullGameStartReq} ProtoBullGameStartReq
         */
        ProtoBullGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoBullGameStartReq)
                return object;
            let message = new $root.mini.ProtoBullGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoBullGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoBullGameStartReq
         * @static
         * @param {mini.ProtoBullGameStartReq} message ProtoBullGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoBullGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoBullGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoBullGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoBullGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoBullGameStartReq;
    })();

    mini.ProtoBullGameStartResp = (function() {

        /**
         * Properties of a ProtoBullGameStartResp.
         * @memberof mini
         * @interface IProtoBullGameStartResp
         * @property {number|null} [stage2Count] ProtoBullGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoBullGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoBullGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoBullGameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoBullGameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoBullGameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [freeResult] ProtoBullGameStartResp freeResult
         * @property {Array.<number>|null} [param] ProtoBullGameStartResp param
         * @property {string|null} [gameID] ProtoBullGameStartResp gameID
         * @property {string|null} [buff] ProtoBullGameStartResp buff
         * @property {string|null} [area] ProtoBullGameStartResp area
         * @property {number|null} [per] ProtoBullGameStartResp per
         * @property {number|null} [errorCode] ProtoBullGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoBullGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoBullGameStartResp.
         * @implements IProtoBullGameStartResp
         * @constructor
         * @param {mini.IProtoBullGameStartResp=} [properties] Properties to set
         */
        function ProtoBullGameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.freeResult = [];
            this.param = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoBullGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoBullGameStartResp
         * @instance
         */
        ProtoBullGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoBullGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoBullGameStartResp
         * @instance
         */
        ProtoBullGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoBullGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoBullGameStartResp
         * @instance
         */
        ProtoBullGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoBullGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoBullGameStartResp
         * @instance
         */
        ProtoBullGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoBullGameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoBullGameStartResp
         * @instance
         */
        ProtoBullGameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoBullGameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoBullGameStartResp
         * @instance
         */
        ProtoBullGameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoBullGameStartResp freeResult.
         * @member {Array.<mini.IFreeSpin>} freeResult
         * @memberof mini.ProtoBullGameStartResp
         * @instance
         */
        ProtoBullGameStartResp.prototype.freeResult = $util.emptyArray;

        /**
         * ProtoBullGameStartResp param.
         * @member {Array.<number>} param
         * @memberof mini.ProtoBullGameStartResp
         * @instance
         */
        ProtoBullGameStartResp.prototype.param = $util.emptyArray;

        /**
         * ProtoBullGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoBullGameStartResp
         * @instance
         */
        ProtoBullGameStartResp.prototype.gameID = "";

        /**
         * ProtoBullGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoBullGameStartResp
         * @instance
         */
        ProtoBullGameStartResp.prototype.buff = "";

        /**
         * ProtoBullGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoBullGameStartResp
         * @instance
         */
        ProtoBullGameStartResp.prototype.area = "";

        /**
         * ProtoBullGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoBullGameStartResp
         * @instance
         */
        ProtoBullGameStartResp.prototype.per = 0;

        /**
         * ProtoBullGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoBullGameStartResp
         * @instance
         */
        ProtoBullGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoBullGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoBullGameStartResp
         * @static
         * @param {mini.IProtoBullGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoBullGameStartResp} ProtoBullGameStartResp instance
         */
        ProtoBullGameStartResp.create = function create(properties) {
            return new ProtoBullGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoBullGameStartResp message. Does not implicitly {@link mini.ProtoBullGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoBullGameStartResp
         * @static
         * @param {mini.IProtoBullGameStartResp} message ProtoBullGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoBullGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.freeResult != null && message.freeResult.length)
                for (let i = 0; i < message.freeResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.freeResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.param != null && message.param.length) {
                writer.uint32(/* id 8, wireType 2 =*/66).fork();
                for (let i = 0; i < message.param.length; ++i)
                    writer.int32(message.param[i]);
                writer.ldelim();
            }
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.per);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoBullGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoBullGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoBullGameStartResp
         * @static
         * @param {mini.IProtoBullGameStartResp} message ProtoBullGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoBullGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoBullGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoBullGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoBullGameStartResp} ProtoBullGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoBullGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoBullGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.freeResult && message.freeResult.length))
                        message.freeResult = [];
                    message.freeResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                case 9:
                    message.gameID = reader.string();
                    break;
                case 10:
                    message.buff = reader.string();
                    break;
                case 11:
                    message.area = reader.string();
                    break;
                case 12:
                    message.per = reader.uint32();
                    break;
                case 13:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoBullGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoBullGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoBullGameStartResp} ProtoBullGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoBullGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoBullGameStartResp message.
         * @function verify
         * @memberof mini.ProtoBullGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoBullGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.freeResult != null && message.hasOwnProperty("freeResult")) {
                if (!Array.isArray(message.freeResult))
                    return "freeResult: array expected";
                for (let i = 0; i < message.freeResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.freeResult[i]);
                    if (error)
                        return "freeResult." + error;
                }
            }
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (let i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoBullGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoBullGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoBullGameStartResp} ProtoBullGameStartResp
         */
        ProtoBullGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoBullGameStartResp)
                return object;
            let message = new $root.mini.ProtoBullGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoBullGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoBullGameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoBullGameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoBullGameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.freeResult) {
                if (!Array.isArray(object.freeResult))
                    throw TypeError(".mini.ProtoBullGameStartResp.freeResult: array expected");
                message.freeResult = [];
                for (let i = 0; i < object.freeResult.length; ++i) {
                    if (typeof object.freeResult[i] !== "object")
                        throw TypeError(".mini.ProtoBullGameStartResp.freeResult: object expected");
                    message.freeResult[i] = $root.mini.FreeSpin.fromObject(object.freeResult[i]);
                }
            }
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".mini.ProtoBullGameStartResp.param: array expected");
                message.param = [];
                for (let i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoBullGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoBullGameStartResp
         * @static
         * @param {mini.ProtoBullGameStartResp} message ProtoBullGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoBullGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.freeResult = [];
                object.param = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.freeResult && message.freeResult.length) {
                object.freeResult = [];
                for (let j = 0; j < message.freeResult.length; ++j)
                    object.freeResult[j] = $root.mini.FreeSpin.toObject(message.freeResult[j], options);
            }
            if (message.param && message.param.length) {
                object.param = [];
                for (let j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoBullGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoBullGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoBullGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoBullGameStartResp;
    })();

    mini.ProtoWolfBlockReq = (function() {

        /**
         * Properties of a ProtoWolfBlockReq.
         * @memberof mini
         * @interface IProtoWolfBlockReq
         * @property {number|null} [gameType] ProtoWolfBlockReq gameType
         */

        /**
         * Constructs a new ProtoWolfBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoWolfBlockReq.
         * @implements IProtoWolfBlockReq
         * @constructor
         * @param {mini.IProtoWolfBlockReq=} [properties] Properties to set
         */
        function ProtoWolfBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoWolfBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoWolfBlockReq
         * @instance
         */
        ProtoWolfBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoWolfBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoWolfBlockReq
         * @static
         * @param {mini.IProtoWolfBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoWolfBlockReq} ProtoWolfBlockReq instance
         */
        ProtoWolfBlockReq.create = function create(properties) {
            return new ProtoWolfBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoWolfBlockReq message. Does not implicitly {@link mini.ProtoWolfBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoWolfBlockReq
         * @static
         * @param {mini.IProtoWolfBlockReq} message ProtoWolfBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoWolfBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoWolfBlockReq message, length delimited. Does not implicitly {@link mini.ProtoWolfBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoWolfBlockReq
         * @static
         * @param {mini.IProtoWolfBlockReq} message ProtoWolfBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoWolfBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoWolfBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoWolfBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoWolfBlockReq} ProtoWolfBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoWolfBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoWolfBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoWolfBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoWolfBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoWolfBlockReq} ProtoWolfBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoWolfBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoWolfBlockReq message.
         * @function verify
         * @memberof mini.ProtoWolfBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoWolfBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoWolfBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoWolfBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoWolfBlockReq} ProtoWolfBlockReq
         */
        ProtoWolfBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoWolfBlockReq)
                return object;
            let message = new $root.mini.ProtoWolfBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoWolfBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoWolfBlockReq
         * @static
         * @param {mini.ProtoWolfBlockReq} message ProtoWolfBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoWolfBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoWolfBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoWolfBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoWolfBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoWolfBlockReq;
    })();

    mini.ProtoWolfBlockResp = (function() {

        /**
         * Properties of a ProtoWolfBlockResp.
         * @memberof mini
         * @interface IProtoWolfBlockResp
         * @property {Array.<number>|null} [block] ProtoWolfBlockResp block
         */

        /**
         * Constructs a new ProtoWolfBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoWolfBlockResp.
         * @implements IProtoWolfBlockResp
         * @constructor
         * @param {mini.IProtoWolfBlockResp=} [properties] Properties to set
         */
        function ProtoWolfBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoWolfBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoWolfBlockResp
         * @instance
         */
        ProtoWolfBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoWolfBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoWolfBlockResp
         * @static
         * @param {mini.IProtoWolfBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoWolfBlockResp} ProtoWolfBlockResp instance
         */
        ProtoWolfBlockResp.create = function create(properties) {
            return new ProtoWolfBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoWolfBlockResp message. Does not implicitly {@link mini.ProtoWolfBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoWolfBlockResp
         * @static
         * @param {mini.IProtoWolfBlockResp} message ProtoWolfBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoWolfBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoWolfBlockResp message, length delimited. Does not implicitly {@link mini.ProtoWolfBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoWolfBlockResp
         * @static
         * @param {mini.IProtoWolfBlockResp} message ProtoWolfBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoWolfBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoWolfBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoWolfBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoWolfBlockResp} ProtoWolfBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoWolfBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoWolfBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoWolfBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoWolfBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoWolfBlockResp} ProtoWolfBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoWolfBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoWolfBlockResp message.
         * @function verify
         * @memberof mini.ProtoWolfBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoWolfBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoWolfBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoWolfBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoWolfBlockResp} ProtoWolfBlockResp
         */
        ProtoWolfBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoWolfBlockResp)
                return object;
            let message = new $root.mini.ProtoWolfBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoWolfBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoWolfBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoWolfBlockResp
         * @static
         * @param {mini.ProtoWolfBlockResp} message ProtoWolfBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoWolfBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoWolfBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoWolfBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoWolfBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoWolfBlockResp;
    })();

    mini.ProtoWolfGameStartReq = (function() {

        /**
         * Properties of a ProtoWolfGameStartReq.
         * @memberof mini
         * @interface IProtoWolfGameStartReq
         * @property {number|null} [score] ProtoWolfGameStartReq score
         * @property {number|null} [type] ProtoWolfGameStartReq type
         * @property {number|null} [area] ProtoWolfGameStartReq area
         * @property {number|null} [buff] ProtoWolfGameStartReq buff
         */

        /**
         * Constructs a new ProtoWolfGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoWolfGameStartReq.
         * @implements IProtoWolfGameStartReq
         * @constructor
         * @param {mini.IProtoWolfGameStartReq=} [properties] Properties to set
         */
        function ProtoWolfGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoWolfGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoWolfGameStartReq
         * @instance
         */
        ProtoWolfGameStartReq.prototype.score = 0;

        /**
         * ProtoWolfGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoWolfGameStartReq
         * @instance
         */
        ProtoWolfGameStartReq.prototype.type = 0;

        /**
         * ProtoWolfGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoWolfGameStartReq
         * @instance
         */
        ProtoWolfGameStartReq.prototype.area = 0;

        /**
         * ProtoWolfGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoWolfGameStartReq
         * @instance
         */
        ProtoWolfGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoWolfGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoWolfGameStartReq
         * @static
         * @param {mini.IProtoWolfGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoWolfGameStartReq} ProtoWolfGameStartReq instance
         */
        ProtoWolfGameStartReq.create = function create(properties) {
            return new ProtoWolfGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoWolfGameStartReq message. Does not implicitly {@link mini.ProtoWolfGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoWolfGameStartReq
         * @static
         * @param {mini.IProtoWolfGameStartReq} message ProtoWolfGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoWolfGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoWolfGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoWolfGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoWolfGameStartReq
         * @static
         * @param {mini.IProtoWolfGameStartReq} message ProtoWolfGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoWolfGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoWolfGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoWolfGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoWolfGameStartReq} ProtoWolfGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoWolfGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoWolfGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoWolfGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoWolfGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoWolfGameStartReq} ProtoWolfGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoWolfGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoWolfGameStartReq message.
         * @function verify
         * @memberof mini.ProtoWolfGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoWolfGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoWolfGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoWolfGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoWolfGameStartReq} ProtoWolfGameStartReq
         */
        ProtoWolfGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoWolfGameStartReq)
                return object;
            let message = new $root.mini.ProtoWolfGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoWolfGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoWolfGameStartReq
         * @static
         * @param {mini.ProtoWolfGameStartReq} message ProtoWolfGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoWolfGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoWolfGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoWolfGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoWolfGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoWolfGameStartReq;
    })();

    mini.ProtoWolfGameStartResp = (function() {

        /**
         * Properties of a ProtoWolfGameStartResp.
         * @memberof mini
         * @interface IProtoWolfGameStartResp
         * @property {number|null} [stage2Count] ProtoWolfGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoWolfGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoWolfGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoWolfGameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoWolfGameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoWolfGameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [superResult] ProtoWolfGameStartResp superResult
         * @property {Array.<number>|null} [param] ProtoWolfGameStartResp param
         * @property {number|null} [goldValue] ProtoWolfGameStartResp goldValue
         * @property {string|null} [gameID] ProtoWolfGameStartResp gameID
         * @property {string|null} [buff] ProtoWolfGameStartResp buff
         * @property {string|null} [area] ProtoWolfGameStartResp area
         * @property {number|null} [per] ProtoWolfGameStartResp per
         * @property {Array.<number>|null} [jackpot] ProtoWolfGameStartResp jackpot
         * @property {number|null} [errorCode] ProtoWolfGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoWolfGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoWolfGameStartResp.
         * @implements IProtoWolfGameStartResp
         * @constructor
         * @param {mini.IProtoWolfGameStartResp=} [properties] Properties to set
         */
        function ProtoWolfGameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.superResult = [];
            this.param = [];
            this.jackpot = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoWolfGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         */
        ProtoWolfGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoWolfGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         */
        ProtoWolfGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoWolfGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         */
        ProtoWolfGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoWolfGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         */
        ProtoWolfGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoWolfGameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         */
        ProtoWolfGameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoWolfGameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         */
        ProtoWolfGameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoWolfGameStartResp superResult.
         * @member {Array.<mini.IFreeSpin>} superResult
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         */
        ProtoWolfGameStartResp.prototype.superResult = $util.emptyArray;

        /**
         * ProtoWolfGameStartResp param.
         * @member {Array.<number>} param
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         */
        ProtoWolfGameStartResp.prototype.param = $util.emptyArray;

        /**
         * ProtoWolfGameStartResp goldValue.
         * @member {number} goldValue
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         */
        ProtoWolfGameStartResp.prototype.goldValue = 0;

        /**
         * ProtoWolfGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         */
        ProtoWolfGameStartResp.prototype.gameID = "";

        /**
         * ProtoWolfGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         */
        ProtoWolfGameStartResp.prototype.buff = "";

        /**
         * ProtoWolfGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         */
        ProtoWolfGameStartResp.prototype.area = "";

        /**
         * ProtoWolfGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         */
        ProtoWolfGameStartResp.prototype.per = 0;

        /**
         * ProtoWolfGameStartResp jackpot.
         * @member {Array.<number>} jackpot
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         */
        ProtoWolfGameStartResp.prototype.jackpot = $util.emptyArray;

        /**
         * ProtoWolfGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         */
        ProtoWolfGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoWolfGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoWolfGameStartResp
         * @static
         * @param {mini.IProtoWolfGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoWolfGameStartResp} ProtoWolfGameStartResp instance
         */
        ProtoWolfGameStartResp.create = function create(properties) {
            return new ProtoWolfGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoWolfGameStartResp message. Does not implicitly {@link mini.ProtoWolfGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoWolfGameStartResp
         * @static
         * @param {mini.IProtoWolfGameStartResp} message ProtoWolfGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoWolfGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.superResult != null && message.superResult.length)
                for (let i = 0; i < message.superResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.superResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.param != null && message.param.length) {
                writer.uint32(/* id 8, wireType 2 =*/66).fork();
                for (let i = 0; i < message.param.length; ++i)
                    writer.int32(message.param[i]);
                writer.ldelim();
            }
            if (message.goldValue != null && Object.hasOwnProperty.call(message, "goldValue"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.goldValue);
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.per);
            if (message.jackpot != null && message.jackpot.length) {
                writer.uint32(/* id 14, wireType 2 =*/114).fork();
                for (let i = 0; i < message.jackpot.length; ++i)
                    writer.uint32(message.jackpot[i]);
                writer.ldelim();
            }
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoWolfGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoWolfGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoWolfGameStartResp
         * @static
         * @param {mini.IProtoWolfGameStartResp} message ProtoWolfGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoWolfGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoWolfGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoWolfGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoWolfGameStartResp} ProtoWolfGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoWolfGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoWolfGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.superResult && message.superResult.length))
                        message.superResult = [];
                    message.superResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                case 9:
                    message.goldValue = reader.uint32();
                    break;
                case 10:
                    message.gameID = reader.string();
                    break;
                case 11:
                    message.buff = reader.string();
                    break;
                case 12:
                    message.area = reader.string();
                    break;
                case 13:
                    message.per = reader.uint32();
                    break;
                case 14:
                    if (!(message.jackpot && message.jackpot.length))
                        message.jackpot = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.jackpot.push(reader.uint32());
                    } else
                        message.jackpot.push(reader.uint32());
                    break;
                case 15:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoWolfGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoWolfGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoWolfGameStartResp} ProtoWolfGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoWolfGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoWolfGameStartResp message.
         * @function verify
         * @memberof mini.ProtoWolfGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoWolfGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.superResult != null && message.hasOwnProperty("superResult")) {
                if (!Array.isArray(message.superResult))
                    return "superResult: array expected";
                for (let i = 0; i < message.superResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.superResult[i]);
                    if (error)
                        return "superResult." + error;
                }
            }
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (let i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            if (message.goldValue != null && message.hasOwnProperty("goldValue"))
                if (!$util.isInteger(message.goldValue))
                    return "goldValue: integer expected";
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.jackpot != null && message.hasOwnProperty("jackpot")) {
                if (!Array.isArray(message.jackpot))
                    return "jackpot: array expected";
                for (let i = 0; i < message.jackpot.length; ++i)
                    if (!$util.isInteger(message.jackpot[i]))
                        return "jackpot: integer[] expected";
            }
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoWolfGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoWolfGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoWolfGameStartResp} ProtoWolfGameStartResp
         */
        ProtoWolfGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoWolfGameStartResp)
                return object;
            let message = new $root.mini.ProtoWolfGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoWolfGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoWolfGameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoWolfGameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoWolfGameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.superResult) {
                if (!Array.isArray(object.superResult))
                    throw TypeError(".mini.ProtoWolfGameStartResp.superResult: array expected");
                message.superResult = [];
                for (let i = 0; i < object.superResult.length; ++i) {
                    if (typeof object.superResult[i] !== "object")
                        throw TypeError(".mini.ProtoWolfGameStartResp.superResult: object expected");
                    message.superResult[i] = $root.mini.FreeSpin.fromObject(object.superResult[i]);
                }
            }
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".mini.ProtoWolfGameStartResp.param: array expected");
                message.param = [];
                for (let i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            if (object.goldValue != null)
                message.goldValue = object.goldValue >>> 0;
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.jackpot) {
                if (!Array.isArray(object.jackpot))
                    throw TypeError(".mini.ProtoWolfGameStartResp.jackpot: array expected");
                message.jackpot = [];
                for (let i = 0; i < object.jackpot.length; ++i)
                    message.jackpot[i] = object.jackpot[i] >>> 0;
            }
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoWolfGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoWolfGameStartResp
         * @static
         * @param {mini.ProtoWolfGameStartResp} message ProtoWolfGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoWolfGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.superResult = [];
                object.param = [];
                object.jackpot = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.goldValue = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.superResult && message.superResult.length) {
                object.superResult = [];
                for (let j = 0; j < message.superResult.length; ++j)
                    object.superResult[j] = $root.mini.FreeSpin.toObject(message.superResult[j], options);
            }
            if (message.param && message.param.length) {
                object.param = [];
                for (let j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            if (message.goldValue != null && message.hasOwnProperty("goldValue"))
                object.goldValue = message.goldValue;
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.jackpot && message.jackpot.length) {
                object.jackpot = [];
                for (let j = 0; j < message.jackpot.length; ++j)
                    object.jackpot[j] = message.jackpot[j];
            }
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoWolfGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoWolfGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoWolfGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoWolfGameStartResp;
    })();

    mini.ProtoTiger02BlockReq = (function() {

        /**
         * Properties of a ProtoTiger02BlockReq.
         * @memberof mini
         * @interface IProtoTiger02BlockReq
         * @property {number|null} [gameType] ProtoTiger02BlockReq gameType
         */

        /**
         * Constructs a new ProtoTiger02BlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoTiger02BlockReq.
         * @implements IProtoTiger02BlockReq
         * @constructor
         * @param {mini.IProtoTiger02BlockReq=} [properties] Properties to set
         */
        function ProtoTiger02BlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoTiger02BlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoTiger02BlockReq
         * @instance
         */
        ProtoTiger02BlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoTiger02BlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoTiger02BlockReq
         * @static
         * @param {mini.IProtoTiger02BlockReq=} [properties] Properties to set
         * @returns {mini.ProtoTiger02BlockReq} ProtoTiger02BlockReq instance
         */
        ProtoTiger02BlockReq.create = function create(properties) {
            return new ProtoTiger02BlockReq(properties);
        };

        /**
         * Encodes the specified ProtoTiger02BlockReq message. Does not implicitly {@link mini.ProtoTiger02BlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoTiger02BlockReq
         * @static
         * @param {mini.IProtoTiger02BlockReq} message ProtoTiger02BlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTiger02BlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoTiger02BlockReq message, length delimited. Does not implicitly {@link mini.ProtoTiger02BlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoTiger02BlockReq
         * @static
         * @param {mini.IProtoTiger02BlockReq} message ProtoTiger02BlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTiger02BlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoTiger02BlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoTiger02BlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoTiger02BlockReq} ProtoTiger02BlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTiger02BlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoTiger02BlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoTiger02BlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoTiger02BlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoTiger02BlockReq} ProtoTiger02BlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTiger02BlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoTiger02BlockReq message.
         * @function verify
         * @memberof mini.ProtoTiger02BlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoTiger02BlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoTiger02BlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoTiger02BlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoTiger02BlockReq} ProtoTiger02BlockReq
         */
        ProtoTiger02BlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoTiger02BlockReq)
                return object;
            let message = new $root.mini.ProtoTiger02BlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoTiger02BlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoTiger02BlockReq
         * @static
         * @param {mini.ProtoTiger02BlockReq} message ProtoTiger02BlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoTiger02BlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoTiger02BlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoTiger02BlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoTiger02BlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoTiger02BlockReq;
    })();

    mini.ProtoTiger02BlockResp = (function() {

        /**
         * Properties of a ProtoTiger02BlockResp.
         * @memberof mini
         * @interface IProtoTiger02BlockResp
         * @property {Array.<number>|null} [block] ProtoTiger02BlockResp block
         */

        /**
         * Constructs a new ProtoTiger02BlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoTiger02BlockResp.
         * @implements IProtoTiger02BlockResp
         * @constructor
         * @param {mini.IProtoTiger02BlockResp=} [properties] Properties to set
         */
        function ProtoTiger02BlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoTiger02BlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoTiger02BlockResp
         * @instance
         */
        ProtoTiger02BlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoTiger02BlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoTiger02BlockResp
         * @static
         * @param {mini.IProtoTiger02BlockResp=} [properties] Properties to set
         * @returns {mini.ProtoTiger02BlockResp} ProtoTiger02BlockResp instance
         */
        ProtoTiger02BlockResp.create = function create(properties) {
            return new ProtoTiger02BlockResp(properties);
        };

        /**
         * Encodes the specified ProtoTiger02BlockResp message. Does not implicitly {@link mini.ProtoTiger02BlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoTiger02BlockResp
         * @static
         * @param {mini.IProtoTiger02BlockResp} message ProtoTiger02BlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTiger02BlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoTiger02BlockResp message, length delimited. Does not implicitly {@link mini.ProtoTiger02BlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoTiger02BlockResp
         * @static
         * @param {mini.IProtoTiger02BlockResp} message ProtoTiger02BlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTiger02BlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoTiger02BlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoTiger02BlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoTiger02BlockResp} ProtoTiger02BlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTiger02BlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoTiger02BlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoTiger02BlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoTiger02BlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoTiger02BlockResp} ProtoTiger02BlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTiger02BlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoTiger02BlockResp message.
         * @function verify
         * @memberof mini.ProtoTiger02BlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoTiger02BlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoTiger02BlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoTiger02BlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoTiger02BlockResp} ProtoTiger02BlockResp
         */
        ProtoTiger02BlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoTiger02BlockResp)
                return object;
            let message = new $root.mini.ProtoTiger02BlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoTiger02BlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoTiger02BlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoTiger02BlockResp
         * @static
         * @param {mini.ProtoTiger02BlockResp} message ProtoTiger02BlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoTiger02BlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoTiger02BlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoTiger02BlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoTiger02BlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoTiger02BlockResp;
    })();

    mini.ProtoTiger02GameStartReq = (function() {

        /**
         * Properties of a ProtoTiger02GameStartReq.
         * @memberof mini
         * @interface IProtoTiger02GameStartReq
         * @property {number|null} [score] ProtoTiger02GameStartReq score
         * @property {number|null} [type] ProtoTiger02GameStartReq type
         * @property {number|null} [area] ProtoTiger02GameStartReq area
         * @property {number|null} [buff] ProtoTiger02GameStartReq buff
         */

        /**
         * Constructs a new ProtoTiger02GameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoTiger02GameStartReq.
         * @implements IProtoTiger02GameStartReq
         * @constructor
         * @param {mini.IProtoTiger02GameStartReq=} [properties] Properties to set
         */
        function ProtoTiger02GameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoTiger02GameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoTiger02GameStartReq
         * @instance
         */
        ProtoTiger02GameStartReq.prototype.score = 0;

        /**
         * ProtoTiger02GameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoTiger02GameStartReq
         * @instance
         */
        ProtoTiger02GameStartReq.prototype.type = 0;

        /**
         * ProtoTiger02GameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoTiger02GameStartReq
         * @instance
         */
        ProtoTiger02GameStartReq.prototype.area = 0;

        /**
         * ProtoTiger02GameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoTiger02GameStartReq
         * @instance
         */
        ProtoTiger02GameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoTiger02GameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoTiger02GameStartReq
         * @static
         * @param {mini.IProtoTiger02GameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoTiger02GameStartReq} ProtoTiger02GameStartReq instance
         */
        ProtoTiger02GameStartReq.create = function create(properties) {
            return new ProtoTiger02GameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoTiger02GameStartReq message. Does not implicitly {@link mini.ProtoTiger02GameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoTiger02GameStartReq
         * @static
         * @param {mini.IProtoTiger02GameStartReq} message ProtoTiger02GameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTiger02GameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoTiger02GameStartReq message, length delimited. Does not implicitly {@link mini.ProtoTiger02GameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoTiger02GameStartReq
         * @static
         * @param {mini.IProtoTiger02GameStartReq} message ProtoTiger02GameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTiger02GameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoTiger02GameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoTiger02GameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoTiger02GameStartReq} ProtoTiger02GameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTiger02GameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoTiger02GameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoTiger02GameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoTiger02GameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoTiger02GameStartReq} ProtoTiger02GameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTiger02GameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoTiger02GameStartReq message.
         * @function verify
         * @memberof mini.ProtoTiger02GameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoTiger02GameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoTiger02GameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoTiger02GameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoTiger02GameStartReq} ProtoTiger02GameStartReq
         */
        ProtoTiger02GameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoTiger02GameStartReq)
                return object;
            let message = new $root.mini.ProtoTiger02GameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoTiger02GameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoTiger02GameStartReq
         * @static
         * @param {mini.ProtoTiger02GameStartReq} message ProtoTiger02GameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoTiger02GameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoTiger02GameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoTiger02GameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoTiger02GameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoTiger02GameStartReq;
    })();

    mini.ProtoTiger02GameStartResp = (function() {

        /**
         * Properties of a ProtoTiger02GameStartResp.
         * @memberof mini
         * @interface IProtoTiger02GameStartResp
         * @property {number|null} [stage2Count] ProtoTiger02GameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoTiger02GameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoTiger02GameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoTiger02GameStartResp itemInfo
         * @property {Array.<mini.IFreeSpin>|null} [superResult] ProtoTiger02GameStartResp superResult
         * @property {string|null} [gameID] ProtoTiger02GameStartResp gameID
         * @property {string|null} [buff] ProtoTiger02GameStartResp buff
         * @property {string|null} [area] ProtoTiger02GameStartResp area
         * @property {number|null} [per] ProtoTiger02GameStartResp per
         * @property {Array.<number>|null} [jackpot] ProtoTiger02GameStartResp jackpot
         * @property {number|null} [errorCode] ProtoTiger02GameStartResp errorCode
         */

        /**
         * Constructs a new ProtoTiger02GameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoTiger02GameStartResp.
         * @implements IProtoTiger02GameStartResp
         * @constructor
         * @param {mini.IProtoTiger02GameStartResp=} [properties] Properties to set
         */
        function ProtoTiger02GameStartResp(properties) {
            this.itemInfo = [];
            this.superResult = [];
            this.jackpot = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoTiger02GameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoTiger02GameStartResp
         * @instance
         */
        ProtoTiger02GameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoTiger02GameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoTiger02GameStartResp
         * @instance
         */
        ProtoTiger02GameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoTiger02GameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoTiger02GameStartResp
         * @instance
         */
        ProtoTiger02GameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoTiger02GameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoTiger02GameStartResp
         * @instance
         */
        ProtoTiger02GameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoTiger02GameStartResp superResult.
         * @member {Array.<mini.IFreeSpin>} superResult
         * @memberof mini.ProtoTiger02GameStartResp
         * @instance
         */
        ProtoTiger02GameStartResp.prototype.superResult = $util.emptyArray;

        /**
         * ProtoTiger02GameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoTiger02GameStartResp
         * @instance
         */
        ProtoTiger02GameStartResp.prototype.gameID = "";

        /**
         * ProtoTiger02GameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoTiger02GameStartResp
         * @instance
         */
        ProtoTiger02GameStartResp.prototype.buff = "";

        /**
         * ProtoTiger02GameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoTiger02GameStartResp
         * @instance
         */
        ProtoTiger02GameStartResp.prototype.area = "";

        /**
         * ProtoTiger02GameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoTiger02GameStartResp
         * @instance
         */
        ProtoTiger02GameStartResp.prototype.per = 0;

        /**
         * ProtoTiger02GameStartResp jackpot.
         * @member {Array.<number>} jackpot
         * @memberof mini.ProtoTiger02GameStartResp
         * @instance
         */
        ProtoTiger02GameStartResp.prototype.jackpot = $util.emptyArray;

        /**
         * ProtoTiger02GameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoTiger02GameStartResp
         * @instance
         */
        ProtoTiger02GameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoTiger02GameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoTiger02GameStartResp
         * @static
         * @param {mini.IProtoTiger02GameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoTiger02GameStartResp} ProtoTiger02GameStartResp instance
         */
        ProtoTiger02GameStartResp.create = function create(properties) {
            return new ProtoTiger02GameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoTiger02GameStartResp message. Does not implicitly {@link mini.ProtoTiger02GameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoTiger02GameStartResp
         * @static
         * @param {mini.IProtoTiger02GameStartResp} message ProtoTiger02GameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTiger02GameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.superResult != null && message.superResult.length)
                for (let i = 0; i < message.superResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.superResult[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.per);
            if (message.jackpot != null && message.jackpot.length) {
                writer.uint32(/* id 10, wireType 2 =*/82).fork();
                for (let i = 0; i < message.jackpot.length; ++i)
                    writer.uint32(message.jackpot[i]);
                writer.ldelim();
            }
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoTiger02GameStartResp message, length delimited. Does not implicitly {@link mini.ProtoTiger02GameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoTiger02GameStartResp
         * @static
         * @param {mini.IProtoTiger02GameStartResp} message ProtoTiger02GameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoTiger02GameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoTiger02GameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoTiger02GameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoTiger02GameStartResp} ProtoTiger02GameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTiger02GameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoTiger02GameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.superResult && message.superResult.length))
                        message.superResult = [];
                    message.superResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.gameID = reader.string();
                    break;
                case 7:
                    message.buff = reader.string();
                    break;
                case 8:
                    message.area = reader.string();
                    break;
                case 9:
                    message.per = reader.uint32();
                    break;
                case 10:
                    if (!(message.jackpot && message.jackpot.length))
                        message.jackpot = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.jackpot.push(reader.uint32());
                    } else
                        message.jackpot.push(reader.uint32());
                    break;
                case 11:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoTiger02GameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoTiger02GameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoTiger02GameStartResp} ProtoTiger02GameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoTiger02GameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoTiger02GameStartResp message.
         * @function verify
         * @memberof mini.ProtoTiger02GameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoTiger02GameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.superResult != null && message.hasOwnProperty("superResult")) {
                if (!Array.isArray(message.superResult))
                    return "superResult: array expected";
                for (let i = 0; i < message.superResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.superResult[i]);
                    if (error)
                        return "superResult." + error;
                }
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.jackpot != null && message.hasOwnProperty("jackpot")) {
                if (!Array.isArray(message.jackpot))
                    return "jackpot: array expected";
                for (let i = 0; i < message.jackpot.length; ++i)
                    if (!$util.isInteger(message.jackpot[i]))
                        return "jackpot: integer[] expected";
            }
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoTiger02GameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoTiger02GameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoTiger02GameStartResp} ProtoTiger02GameStartResp
         */
        ProtoTiger02GameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoTiger02GameStartResp)
                return object;
            let message = new $root.mini.ProtoTiger02GameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoTiger02GameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.superResult) {
                if (!Array.isArray(object.superResult))
                    throw TypeError(".mini.ProtoTiger02GameStartResp.superResult: array expected");
                message.superResult = [];
                for (let i = 0; i < object.superResult.length; ++i) {
                    if (typeof object.superResult[i] !== "object")
                        throw TypeError(".mini.ProtoTiger02GameStartResp.superResult: object expected");
                    message.superResult[i] = $root.mini.FreeSpin.fromObject(object.superResult[i]);
                }
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.jackpot) {
                if (!Array.isArray(object.jackpot))
                    throw TypeError(".mini.ProtoTiger02GameStartResp.jackpot: array expected");
                message.jackpot = [];
                for (let i = 0; i < object.jackpot.length; ++i)
                    message.jackpot[i] = object.jackpot[i] >>> 0;
            }
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoTiger02GameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoTiger02GameStartResp
         * @static
         * @param {mini.ProtoTiger02GameStartResp} message ProtoTiger02GameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoTiger02GameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.superResult = [];
                object.jackpot = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.superResult && message.superResult.length) {
                object.superResult = [];
                for (let j = 0; j < message.superResult.length; ++j)
                    object.superResult[j] = $root.mini.FreeSpin.toObject(message.superResult[j], options);
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.jackpot && message.jackpot.length) {
                object.jackpot = [];
                for (let j = 0; j < message.jackpot.length; ++j)
                    object.jackpot[j] = message.jackpot[j];
            }
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoTiger02GameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoTiger02GameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoTiger02GameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoTiger02GameStartResp;
    })();

    mini.ProtoLPigBlockReq = (function() {

        /**
         * Properties of a ProtoLPigBlockReq.
         * @memberof mini
         * @interface IProtoLPigBlockReq
         * @property {number|null} [gameType] ProtoLPigBlockReq gameType
         */

        /**
         * Constructs a new ProtoLPigBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoLPigBlockReq.
         * @implements IProtoLPigBlockReq
         * @constructor
         * @param {mini.IProtoLPigBlockReq=} [properties] Properties to set
         */
        function ProtoLPigBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoLPigBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoLPigBlockReq
         * @instance
         */
        ProtoLPigBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoLPigBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoLPigBlockReq
         * @static
         * @param {mini.IProtoLPigBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoLPigBlockReq} ProtoLPigBlockReq instance
         */
        ProtoLPigBlockReq.create = function create(properties) {
            return new ProtoLPigBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoLPigBlockReq message. Does not implicitly {@link mini.ProtoLPigBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoLPigBlockReq
         * @static
         * @param {mini.IProtoLPigBlockReq} message ProtoLPigBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoLPigBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoLPigBlockReq message, length delimited. Does not implicitly {@link mini.ProtoLPigBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoLPigBlockReq
         * @static
         * @param {mini.IProtoLPigBlockReq} message ProtoLPigBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoLPigBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoLPigBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoLPigBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoLPigBlockReq} ProtoLPigBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoLPigBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoLPigBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoLPigBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoLPigBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoLPigBlockReq} ProtoLPigBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoLPigBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoLPigBlockReq message.
         * @function verify
         * @memberof mini.ProtoLPigBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoLPigBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoLPigBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoLPigBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoLPigBlockReq} ProtoLPigBlockReq
         */
        ProtoLPigBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoLPigBlockReq)
                return object;
            let message = new $root.mini.ProtoLPigBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoLPigBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoLPigBlockReq
         * @static
         * @param {mini.ProtoLPigBlockReq} message ProtoLPigBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoLPigBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoLPigBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoLPigBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoLPigBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoLPigBlockReq;
    })();

    mini.ProtoLPigBlockResp = (function() {

        /**
         * Properties of a ProtoLPigBlockResp.
         * @memberof mini
         * @interface IProtoLPigBlockResp
         * @property {Array.<number>|null} [block] ProtoLPigBlockResp block
         */

        /**
         * Constructs a new ProtoLPigBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoLPigBlockResp.
         * @implements IProtoLPigBlockResp
         * @constructor
         * @param {mini.IProtoLPigBlockResp=} [properties] Properties to set
         */
        function ProtoLPigBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoLPigBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoLPigBlockResp
         * @instance
         */
        ProtoLPigBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoLPigBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoLPigBlockResp
         * @static
         * @param {mini.IProtoLPigBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoLPigBlockResp} ProtoLPigBlockResp instance
         */
        ProtoLPigBlockResp.create = function create(properties) {
            return new ProtoLPigBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoLPigBlockResp message. Does not implicitly {@link mini.ProtoLPigBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoLPigBlockResp
         * @static
         * @param {mini.IProtoLPigBlockResp} message ProtoLPigBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoLPigBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoLPigBlockResp message, length delimited. Does not implicitly {@link mini.ProtoLPigBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoLPigBlockResp
         * @static
         * @param {mini.IProtoLPigBlockResp} message ProtoLPigBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoLPigBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoLPigBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoLPigBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoLPigBlockResp} ProtoLPigBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoLPigBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoLPigBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoLPigBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoLPigBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoLPigBlockResp} ProtoLPigBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoLPigBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoLPigBlockResp message.
         * @function verify
         * @memberof mini.ProtoLPigBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoLPigBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoLPigBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoLPigBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoLPigBlockResp} ProtoLPigBlockResp
         */
        ProtoLPigBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoLPigBlockResp)
                return object;
            let message = new $root.mini.ProtoLPigBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoLPigBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoLPigBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoLPigBlockResp
         * @static
         * @param {mini.ProtoLPigBlockResp} message ProtoLPigBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoLPigBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoLPigBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoLPigBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoLPigBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoLPigBlockResp;
    })();

    mini.ProtoLPigGameStartReq = (function() {

        /**
         * Properties of a ProtoLPigGameStartReq.
         * @memberof mini
         * @interface IProtoLPigGameStartReq
         * @property {number|null} [score] ProtoLPigGameStartReq score
         * @property {number|null} [type] ProtoLPigGameStartReq type
         * @property {number|null} [area] ProtoLPigGameStartReq area
         * @property {number|null} [buff] ProtoLPigGameStartReq buff
         */

        /**
         * Constructs a new ProtoLPigGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoLPigGameStartReq.
         * @implements IProtoLPigGameStartReq
         * @constructor
         * @param {mini.IProtoLPigGameStartReq=} [properties] Properties to set
         */
        function ProtoLPigGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoLPigGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoLPigGameStartReq
         * @instance
         */
        ProtoLPigGameStartReq.prototype.score = 0;

        /**
         * ProtoLPigGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoLPigGameStartReq
         * @instance
         */
        ProtoLPigGameStartReq.prototype.type = 0;

        /**
         * ProtoLPigGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoLPigGameStartReq
         * @instance
         */
        ProtoLPigGameStartReq.prototype.area = 0;

        /**
         * ProtoLPigGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoLPigGameStartReq
         * @instance
         */
        ProtoLPigGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoLPigGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoLPigGameStartReq
         * @static
         * @param {mini.IProtoLPigGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoLPigGameStartReq} ProtoLPigGameStartReq instance
         */
        ProtoLPigGameStartReq.create = function create(properties) {
            return new ProtoLPigGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoLPigGameStartReq message. Does not implicitly {@link mini.ProtoLPigGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoLPigGameStartReq
         * @static
         * @param {mini.IProtoLPigGameStartReq} message ProtoLPigGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoLPigGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoLPigGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoLPigGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoLPigGameStartReq
         * @static
         * @param {mini.IProtoLPigGameStartReq} message ProtoLPigGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoLPigGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoLPigGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoLPigGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoLPigGameStartReq} ProtoLPigGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoLPigGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoLPigGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoLPigGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoLPigGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoLPigGameStartReq} ProtoLPigGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoLPigGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoLPigGameStartReq message.
         * @function verify
         * @memberof mini.ProtoLPigGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoLPigGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoLPigGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoLPigGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoLPigGameStartReq} ProtoLPigGameStartReq
         */
        ProtoLPigGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoLPigGameStartReq)
                return object;
            let message = new $root.mini.ProtoLPigGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoLPigGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoLPigGameStartReq
         * @static
         * @param {mini.ProtoLPigGameStartReq} message ProtoLPigGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoLPigGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoLPigGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoLPigGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoLPigGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoLPigGameStartReq;
    })();

    mini.ProtoLPigGameStartResp = (function() {

        /**
         * Properties of a ProtoLPigGameStartResp.
         * @memberof mini
         * @interface IProtoLPigGameStartResp
         * @property {number|null} [stage2Count] ProtoLPigGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoLPigGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoLPigGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoLPigGameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoLPigGameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoLPigGameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [normalResult] ProtoLPigGameStartResp normalResult
         * @property {Array.<mini.IFreeSpin>|null} [superResult] ProtoLPigGameStartResp superResult
         * @property {Array.<number>|null} [param] ProtoLPigGameStartResp param
         * @property {string|null} [gameID] ProtoLPigGameStartResp gameID
         * @property {string|null} [buff] ProtoLPigGameStartResp buff
         * @property {string|null} [area] ProtoLPigGameStartResp area
         * @property {number|null} [per] ProtoLPigGameStartResp per
         * @property {number|null} [errorCode] ProtoLPigGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoLPigGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoLPigGameStartResp.
         * @implements IProtoLPigGameStartResp
         * @constructor
         * @param {mini.IProtoLPigGameStartResp=} [properties] Properties to set
         */
        function ProtoLPigGameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.normalResult = [];
            this.superResult = [];
            this.param = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoLPigGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoLPigGameStartResp
         * @instance
         */
        ProtoLPigGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoLPigGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoLPigGameStartResp
         * @instance
         */
        ProtoLPigGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoLPigGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoLPigGameStartResp
         * @instance
         */
        ProtoLPigGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoLPigGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoLPigGameStartResp
         * @instance
         */
        ProtoLPigGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoLPigGameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoLPigGameStartResp
         * @instance
         */
        ProtoLPigGameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoLPigGameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoLPigGameStartResp
         * @instance
         */
        ProtoLPigGameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoLPigGameStartResp normalResult.
         * @member {Array.<mini.IFreeSpin>} normalResult
         * @memberof mini.ProtoLPigGameStartResp
         * @instance
         */
        ProtoLPigGameStartResp.prototype.normalResult = $util.emptyArray;

        /**
         * ProtoLPigGameStartResp superResult.
         * @member {Array.<mini.IFreeSpin>} superResult
         * @memberof mini.ProtoLPigGameStartResp
         * @instance
         */
        ProtoLPigGameStartResp.prototype.superResult = $util.emptyArray;

        /**
         * ProtoLPigGameStartResp param.
         * @member {Array.<number>} param
         * @memberof mini.ProtoLPigGameStartResp
         * @instance
         */
        ProtoLPigGameStartResp.prototype.param = $util.emptyArray;

        /**
         * ProtoLPigGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoLPigGameStartResp
         * @instance
         */
        ProtoLPigGameStartResp.prototype.gameID = "";

        /**
         * ProtoLPigGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoLPigGameStartResp
         * @instance
         */
        ProtoLPigGameStartResp.prototype.buff = "";

        /**
         * ProtoLPigGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoLPigGameStartResp
         * @instance
         */
        ProtoLPigGameStartResp.prototype.area = "";

        /**
         * ProtoLPigGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoLPigGameStartResp
         * @instance
         */
        ProtoLPigGameStartResp.prototype.per = 0;

        /**
         * ProtoLPigGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoLPigGameStartResp
         * @instance
         */
        ProtoLPigGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoLPigGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoLPigGameStartResp
         * @static
         * @param {mini.IProtoLPigGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoLPigGameStartResp} ProtoLPigGameStartResp instance
         */
        ProtoLPigGameStartResp.create = function create(properties) {
            return new ProtoLPigGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoLPigGameStartResp message. Does not implicitly {@link mini.ProtoLPigGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoLPigGameStartResp
         * @static
         * @param {mini.IProtoLPigGameStartResp} message ProtoLPigGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoLPigGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.normalResult != null && message.normalResult.length)
                for (let i = 0; i < message.normalResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.normalResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.superResult != null && message.superResult.length)
                for (let i = 0; i < message.superResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.superResult[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.param != null && message.param.length) {
                writer.uint32(/* id 9, wireType 2 =*/74).fork();
                for (let i = 0; i < message.param.length; ++i)
                    writer.int32(message.param[i]);
                writer.ldelim();
            }
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.per);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoLPigGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoLPigGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoLPigGameStartResp
         * @static
         * @param {mini.IProtoLPigGameStartResp} message ProtoLPigGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoLPigGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoLPigGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoLPigGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoLPigGameStartResp} ProtoLPigGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoLPigGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoLPigGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.normalResult && message.normalResult.length))
                        message.normalResult = [];
                    message.normalResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.superResult && message.superResult.length))
                        message.superResult = [];
                    message.superResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 9:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                case 10:
                    message.gameID = reader.string();
                    break;
                case 11:
                    message.buff = reader.string();
                    break;
                case 12:
                    message.area = reader.string();
                    break;
                case 13:
                    message.per = reader.uint32();
                    break;
                case 14:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoLPigGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoLPigGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoLPigGameStartResp} ProtoLPigGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoLPigGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoLPigGameStartResp message.
         * @function verify
         * @memberof mini.ProtoLPigGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoLPigGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.normalResult != null && message.hasOwnProperty("normalResult")) {
                if (!Array.isArray(message.normalResult))
                    return "normalResult: array expected";
                for (let i = 0; i < message.normalResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.normalResult[i]);
                    if (error)
                        return "normalResult." + error;
                }
            }
            if (message.superResult != null && message.hasOwnProperty("superResult")) {
                if (!Array.isArray(message.superResult))
                    return "superResult: array expected";
                for (let i = 0; i < message.superResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.superResult[i]);
                    if (error)
                        return "superResult." + error;
                }
            }
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (let i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoLPigGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoLPigGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoLPigGameStartResp} ProtoLPigGameStartResp
         */
        ProtoLPigGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoLPigGameStartResp)
                return object;
            let message = new $root.mini.ProtoLPigGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoLPigGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoLPigGameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoLPigGameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoLPigGameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.normalResult) {
                if (!Array.isArray(object.normalResult))
                    throw TypeError(".mini.ProtoLPigGameStartResp.normalResult: array expected");
                message.normalResult = [];
                for (let i = 0; i < object.normalResult.length; ++i) {
                    if (typeof object.normalResult[i] !== "object")
                        throw TypeError(".mini.ProtoLPigGameStartResp.normalResult: object expected");
                    message.normalResult[i] = $root.mini.FreeSpin.fromObject(object.normalResult[i]);
                }
            }
            if (object.superResult) {
                if (!Array.isArray(object.superResult))
                    throw TypeError(".mini.ProtoLPigGameStartResp.superResult: array expected");
                message.superResult = [];
                for (let i = 0; i < object.superResult.length; ++i) {
                    if (typeof object.superResult[i] !== "object")
                        throw TypeError(".mini.ProtoLPigGameStartResp.superResult: object expected");
                    message.superResult[i] = $root.mini.FreeSpin.fromObject(object.superResult[i]);
                }
            }
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".mini.ProtoLPigGameStartResp.param: array expected");
                message.param = [];
                for (let i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoLPigGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoLPigGameStartResp
         * @static
         * @param {mini.ProtoLPigGameStartResp} message ProtoLPigGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoLPigGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.normalResult = [];
                object.superResult = [];
                object.param = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.normalResult && message.normalResult.length) {
                object.normalResult = [];
                for (let j = 0; j < message.normalResult.length; ++j)
                    object.normalResult[j] = $root.mini.FreeSpin.toObject(message.normalResult[j], options);
            }
            if (message.superResult && message.superResult.length) {
                object.superResult = [];
                for (let j = 0; j < message.superResult.length; ++j)
                    object.superResult[j] = $root.mini.FreeSpin.toObject(message.superResult[j], options);
            }
            if (message.param && message.param.length) {
                object.param = [];
                for (let j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoLPigGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoLPigGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoLPigGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoLPigGameStartResp;
    })();

    mini.ProtoNMouseBlockReq = (function() {

        /**
         * Properties of a ProtoNMouseBlockReq.
         * @memberof mini
         * @interface IProtoNMouseBlockReq
         * @property {number|null} [gameType] ProtoNMouseBlockReq gameType
         */

        /**
         * Constructs a new ProtoNMouseBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoNMouseBlockReq.
         * @implements IProtoNMouseBlockReq
         * @constructor
         * @param {mini.IProtoNMouseBlockReq=} [properties] Properties to set
         */
        function ProtoNMouseBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNMouseBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoNMouseBlockReq
         * @instance
         */
        ProtoNMouseBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoNMouseBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNMouseBlockReq
         * @static
         * @param {mini.IProtoNMouseBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoNMouseBlockReq} ProtoNMouseBlockReq instance
         */
        ProtoNMouseBlockReq.create = function create(properties) {
            return new ProtoNMouseBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoNMouseBlockReq message. Does not implicitly {@link mini.ProtoNMouseBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNMouseBlockReq
         * @static
         * @param {mini.IProtoNMouseBlockReq} message ProtoNMouseBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNMouseBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoNMouseBlockReq message, length delimited. Does not implicitly {@link mini.ProtoNMouseBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNMouseBlockReq
         * @static
         * @param {mini.IProtoNMouseBlockReq} message ProtoNMouseBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNMouseBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNMouseBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNMouseBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNMouseBlockReq} ProtoNMouseBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNMouseBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNMouseBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNMouseBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNMouseBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNMouseBlockReq} ProtoNMouseBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNMouseBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNMouseBlockReq message.
         * @function verify
         * @memberof mini.ProtoNMouseBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNMouseBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoNMouseBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNMouseBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNMouseBlockReq} ProtoNMouseBlockReq
         */
        ProtoNMouseBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNMouseBlockReq)
                return object;
            let message = new $root.mini.ProtoNMouseBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoNMouseBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNMouseBlockReq
         * @static
         * @param {mini.ProtoNMouseBlockReq} message ProtoNMouseBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNMouseBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoNMouseBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoNMouseBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNMouseBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNMouseBlockReq;
    })();

    mini.ProtoNMouseBlockResp = (function() {

        /**
         * Properties of a ProtoNMouseBlockResp.
         * @memberof mini
         * @interface IProtoNMouseBlockResp
         * @property {Array.<number>|null} [block] ProtoNMouseBlockResp block
         */

        /**
         * Constructs a new ProtoNMouseBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoNMouseBlockResp.
         * @implements IProtoNMouseBlockResp
         * @constructor
         * @param {mini.IProtoNMouseBlockResp=} [properties] Properties to set
         */
        function ProtoNMouseBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNMouseBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoNMouseBlockResp
         * @instance
         */
        ProtoNMouseBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoNMouseBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNMouseBlockResp
         * @static
         * @param {mini.IProtoNMouseBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoNMouseBlockResp} ProtoNMouseBlockResp instance
         */
        ProtoNMouseBlockResp.create = function create(properties) {
            return new ProtoNMouseBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoNMouseBlockResp message. Does not implicitly {@link mini.ProtoNMouseBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNMouseBlockResp
         * @static
         * @param {mini.IProtoNMouseBlockResp} message ProtoNMouseBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNMouseBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoNMouseBlockResp message, length delimited. Does not implicitly {@link mini.ProtoNMouseBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNMouseBlockResp
         * @static
         * @param {mini.IProtoNMouseBlockResp} message ProtoNMouseBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNMouseBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNMouseBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNMouseBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNMouseBlockResp} ProtoNMouseBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNMouseBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNMouseBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNMouseBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNMouseBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNMouseBlockResp} ProtoNMouseBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNMouseBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNMouseBlockResp message.
         * @function verify
         * @memberof mini.ProtoNMouseBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNMouseBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoNMouseBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNMouseBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNMouseBlockResp} ProtoNMouseBlockResp
         */
        ProtoNMouseBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNMouseBlockResp)
                return object;
            let message = new $root.mini.ProtoNMouseBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoNMouseBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoNMouseBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNMouseBlockResp
         * @static
         * @param {mini.ProtoNMouseBlockResp} message ProtoNMouseBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNMouseBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoNMouseBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoNMouseBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNMouseBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNMouseBlockResp;
    })();

    mini.ProtoNMouseGameStartReq = (function() {

        /**
         * Properties of a ProtoNMouseGameStartReq.
         * @memberof mini
         * @interface IProtoNMouseGameStartReq
         * @property {number|null} [score] ProtoNMouseGameStartReq score
         * @property {number|null} [type] ProtoNMouseGameStartReq type
         * @property {number|null} [area] ProtoNMouseGameStartReq area
         * @property {number|null} [buff] ProtoNMouseGameStartReq buff
         */

        /**
         * Constructs a new ProtoNMouseGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoNMouseGameStartReq.
         * @implements IProtoNMouseGameStartReq
         * @constructor
         * @param {mini.IProtoNMouseGameStartReq=} [properties] Properties to set
         */
        function ProtoNMouseGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNMouseGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoNMouseGameStartReq
         * @instance
         */
        ProtoNMouseGameStartReq.prototype.score = 0;

        /**
         * ProtoNMouseGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoNMouseGameStartReq
         * @instance
         */
        ProtoNMouseGameStartReq.prototype.type = 0;

        /**
         * ProtoNMouseGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoNMouseGameStartReq
         * @instance
         */
        ProtoNMouseGameStartReq.prototype.area = 0;

        /**
         * ProtoNMouseGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoNMouseGameStartReq
         * @instance
         */
        ProtoNMouseGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoNMouseGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNMouseGameStartReq
         * @static
         * @param {mini.IProtoNMouseGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoNMouseGameStartReq} ProtoNMouseGameStartReq instance
         */
        ProtoNMouseGameStartReq.create = function create(properties) {
            return new ProtoNMouseGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoNMouseGameStartReq message. Does not implicitly {@link mini.ProtoNMouseGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNMouseGameStartReq
         * @static
         * @param {mini.IProtoNMouseGameStartReq} message ProtoNMouseGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNMouseGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoNMouseGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoNMouseGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNMouseGameStartReq
         * @static
         * @param {mini.IProtoNMouseGameStartReq} message ProtoNMouseGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNMouseGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNMouseGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNMouseGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNMouseGameStartReq} ProtoNMouseGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNMouseGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNMouseGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNMouseGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNMouseGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNMouseGameStartReq} ProtoNMouseGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNMouseGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNMouseGameStartReq message.
         * @function verify
         * @memberof mini.ProtoNMouseGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNMouseGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoNMouseGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNMouseGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNMouseGameStartReq} ProtoNMouseGameStartReq
         */
        ProtoNMouseGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNMouseGameStartReq)
                return object;
            let message = new $root.mini.ProtoNMouseGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoNMouseGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNMouseGameStartReq
         * @static
         * @param {mini.ProtoNMouseGameStartReq} message ProtoNMouseGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNMouseGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoNMouseGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoNMouseGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNMouseGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNMouseGameStartReq;
    })();

    mini.ProtoNMouseGameStartResp = (function() {

        /**
         * Properties of a ProtoNMouseGameStartResp.
         * @memberof mini
         * @interface IProtoNMouseGameStartResp
         * @property {number|null} [stage2Count] ProtoNMouseGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoNMouseGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoNMouseGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoNMouseGameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoNMouseGameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoNMouseGameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [superResult] ProtoNMouseGameStartResp superResult
         * @property {string|null} [gameID] ProtoNMouseGameStartResp gameID
         * @property {string|null} [buff] ProtoNMouseGameStartResp buff
         * @property {string|null} [area] ProtoNMouseGameStartResp area
         * @property {number|null} [per] ProtoNMouseGameStartResp per
         * @property {number|null} [errorCode] ProtoNMouseGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoNMouseGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoNMouseGameStartResp.
         * @implements IProtoNMouseGameStartResp
         * @constructor
         * @param {mini.IProtoNMouseGameStartResp=} [properties] Properties to set
         */
        function ProtoNMouseGameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.superResult = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNMouseGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoNMouseGameStartResp
         * @instance
         */
        ProtoNMouseGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoNMouseGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoNMouseGameStartResp
         * @instance
         */
        ProtoNMouseGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoNMouseGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoNMouseGameStartResp
         * @instance
         */
        ProtoNMouseGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoNMouseGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoNMouseGameStartResp
         * @instance
         */
        ProtoNMouseGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoNMouseGameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoNMouseGameStartResp
         * @instance
         */
        ProtoNMouseGameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoNMouseGameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoNMouseGameStartResp
         * @instance
         */
        ProtoNMouseGameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoNMouseGameStartResp superResult.
         * @member {Array.<mini.IFreeSpin>} superResult
         * @memberof mini.ProtoNMouseGameStartResp
         * @instance
         */
        ProtoNMouseGameStartResp.prototype.superResult = $util.emptyArray;

        /**
         * ProtoNMouseGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoNMouseGameStartResp
         * @instance
         */
        ProtoNMouseGameStartResp.prototype.gameID = "";

        /**
         * ProtoNMouseGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoNMouseGameStartResp
         * @instance
         */
        ProtoNMouseGameStartResp.prototype.buff = "";

        /**
         * ProtoNMouseGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoNMouseGameStartResp
         * @instance
         */
        ProtoNMouseGameStartResp.prototype.area = "";

        /**
         * ProtoNMouseGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoNMouseGameStartResp
         * @instance
         */
        ProtoNMouseGameStartResp.prototype.per = 0;

        /**
         * ProtoNMouseGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoNMouseGameStartResp
         * @instance
         */
        ProtoNMouseGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoNMouseGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNMouseGameStartResp
         * @static
         * @param {mini.IProtoNMouseGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoNMouseGameStartResp} ProtoNMouseGameStartResp instance
         */
        ProtoNMouseGameStartResp.create = function create(properties) {
            return new ProtoNMouseGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoNMouseGameStartResp message. Does not implicitly {@link mini.ProtoNMouseGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNMouseGameStartResp
         * @static
         * @param {mini.IProtoNMouseGameStartResp} message ProtoNMouseGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNMouseGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.superResult != null && message.superResult.length)
                for (let i = 0; i < message.superResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.superResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.per);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoNMouseGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoNMouseGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNMouseGameStartResp
         * @static
         * @param {mini.IProtoNMouseGameStartResp} message ProtoNMouseGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNMouseGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNMouseGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNMouseGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNMouseGameStartResp} ProtoNMouseGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNMouseGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNMouseGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.superResult && message.superResult.length))
                        message.superResult = [];
                    message.superResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.gameID = reader.string();
                    break;
                case 9:
                    message.buff = reader.string();
                    break;
                case 10:
                    message.area = reader.string();
                    break;
                case 11:
                    message.per = reader.uint32();
                    break;
                case 12:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNMouseGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNMouseGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNMouseGameStartResp} ProtoNMouseGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNMouseGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNMouseGameStartResp message.
         * @function verify
         * @memberof mini.ProtoNMouseGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNMouseGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.superResult != null && message.hasOwnProperty("superResult")) {
                if (!Array.isArray(message.superResult))
                    return "superResult: array expected";
                for (let i = 0; i < message.superResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.superResult[i]);
                    if (error)
                        return "superResult." + error;
                }
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoNMouseGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNMouseGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNMouseGameStartResp} ProtoNMouseGameStartResp
         */
        ProtoNMouseGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNMouseGameStartResp)
                return object;
            let message = new $root.mini.ProtoNMouseGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoNMouseGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoNMouseGameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoNMouseGameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoNMouseGameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.superResult) {
                if (!Array.isArray(object.superResult))
                    throw TypeError(".mini.ProtoNMouseGameStartResp.superResult: array expected");
                message.superResult = [];
                for (let i = 0; i < object.superResult.length; ++i) {
                    if (typeof object.superResult[i] !== "object")
                        throw TypeError(".mini.ProtoNMouseGameStartResp.superResult: object expected");
                    message.superResult[i] = $root.mini.FreeSpin.fromObject(object.superResult[i]);
                }
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoNMouseGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNMouseGameStartResp
         * @static
         * @param {mini.ProtoNMouseGameStartResp} message ProtoNMouseGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNMouseGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.superResult = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.superResult && message.superResult.length) {
                object.superResult = [];
                for (let j = 0; j < message.superResult.length; ++j)
                    object.superResult[j] = $root.mini.FreeSpin.toObject(message.superResult[j], options);
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoNMouseGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoNMouseGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNMouseGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNMouseGameStartResp;
    })();

    mini.ProtoNCowBlockReq = (function() {

        /**
         * Properties of a ProtoNCowBlockReq.
         * @memberof mini
         * @interface IProtoNCowBlockReq
         * @property {number|null} [gameType] ProtoNCowBlockReq gameType
         */

        /**
         * Constructs a new ProtoNCowBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoNCowBlockReq.
         * @implements IProtoNCowBlockReq
         * @constructor
         * @param {mini.IProtoNCowBlockReq=} [properties] Properties to set
         */
        function ProtoNCowBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNCowBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoNCowBlockReq
         * @instance
         */
        ProtoNCowBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoNCowBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNCowBlockReq
         * @static
         * @param {mini.IProtoNCowBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoNCowBlockReq} ProtoNCowBlockReq instance
         */
        ProtoNCowBlockReq.create = function create(properties) {
            return new ProtoNCowBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoNCowBlockReq message. Does not implicitly {@link mini.ProtoNCowBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNCowBlockReq
         * @static
         * @param {mini.IProtoNCowBlockReq} message ProtoNCowBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNCowBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoNCowBlockReq message, length delimited. Does not implicitly {@link mini.ProtoNCowBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNCowBlockReq
         * @static
         * @param {mini.IProtoNCowBlockReq} message ProtoNCowBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNCowBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNCowBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNCowBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNCowBlockReq} ProtoNCowBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNCowBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNCowBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNCowBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNCowBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNCowBlockReq} ProtoNCowBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNCowBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNCowBlockReq message.
         * @function verify
         * @memberof mini.ProtoNCowBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNCowBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoNCowBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNCowBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNCowBlockReq} ProtoNCowBlockReq
         */
        ProtoNCowBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNCowBlockReq)
                return object;
            let message = new $root.mini.ProtoNCowBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoNCowBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNCowBlockReq
         * @static
         * @param {mini.ProtoNCowBlockReq} message ProtoNCowBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNCowBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoNCowBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoNCowBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNCowBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNCowBlockReq;
    })();

    mini.ProtoNCowBlockResp = (function() {

        /**
         * Properties of a ProtoNCowBlockResp.
         * @memberof mini
         * @interface IProtoNCowBlockResp
         * @property {Array.<number>|null} [block] ProtoNCowBlockResp block
         */

        /**
         * Constructs a new ProtoNCowBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoNCowBlockResp.
         * @implements IProtoNCowBlockResp
         * @constructor
         * @param {mini.IProtoNCowBlockResp=} [properties] Properties to set
         */
        function ProtoNCowBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNCowBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoNCowBlockResp
         * @instance
         */
        ProtoNCowBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoNCowBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNCowBlockResp
         * @static
         * @param {mini.IProtoNCowBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoNCowBlockResp} ProtoNCowBlockResp instance
         */
        ProtoNCowBlockResp.create = function create(properties) {
            return new ProtoNCowBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoNCowBlockResp message. Does not implicitly {@link mini.ProtoNCowBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNCowBlockResp
         * @static
         * @param {mini.IProtoNCowBlockResp} message ProtoNCowBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNCowBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoNCowBlockResp message, length delimited. Does not implicitly {@link mini.ProtoNCowBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNCowBlockResp
         * @static
         * @param {mini.IProtoNCowBlockResp} message ProtoNCowBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNCowBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNCowBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNCowBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNCowBlockResp} ProtoNCowBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNCowBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNCowBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNCowBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNCowBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNCowBlockResp} ProtoNCowBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNCowBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNCowBlockResp message.
         * @function verify
         * @memberof mini.ProtoNCowBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNCowBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoNCowBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNCowBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNCowBlockResp} ProtoNCowBlockResp
         */
        ProtoNCowBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNCowBlockResp)
                return object;
            let message = new $root.mini.ProtoNCowBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoNCowBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoNCowBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNCowBlockResp
         * @static
         * @param {mini.ProtoNCowBlockResp} message ProtoNCowBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNCowBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoNCowBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoNCowBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNCowBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNCowBlockResp;
    })();

    mini.ProtoNCowGameStartReq = (function() {

        /**
         * Properties of a ProtoNCowGameStartReq.
         * @memberof mini
         * @interface IProtoNCowGameStartReq
         * @property {number|null} [score] ProtoNCowGameStartReq score
         * @property {number|null} [type] ProtoNCowGameStartReq type
         * @property {number|null} [area] ProtoNCowGameStartReq area
         * @property {number|null} [buff] ProtoNCowGameStartReq buff
         */

        /**
         * Constructs a new ProtoNCowGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoNCowGameStartReq.
         * @implements IProtoNCowGameStartReq
         * @constructor
         * @param {mini.IProtoNCowGameStartReq=} [properties] Properties to set
         */
        function ProtoNCowGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNCowGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoNCowGameStartReq
         * @instance
         */
        ProtoNCowGameStartReq.prototype.score = 0;

        /**
         * ProtoNCowGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoNCowGameStartReq
         * @instance
         */
        ProtoNCowGameStartReq.prototype.type = 0;

        /**
         * ProtoNCowGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoNCowGameStartReq
         * @instance
         */
        ProtoNCowGameStartReq.prototype.area = 0;

        /**
         * ProtoNCowGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoNCowGameStartReq
         * @instance
         */
        ProtoNCowGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoNCowGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNCowGameStartReq
         * @static
         * @param {mini.IProtoNCowGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoNCowGameStartReq} ProtoNCowGameStartReq instance
         */
        ProtoNCowGameStartReq.create = function create(properties) {
            return new ProtoNCowGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoNCowGameStartReq message. Does not implicitly {@link mini.ProtoNCowGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNCowGameStartReq
         * @static
         * @param {mini.IProtoNCowGameStartReq} message ProtoNCowGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNCowGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoNCowGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoNCowGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNCowGameStartReq
         * @static
         * @param {mini.IProtoNCowGameStartReq} message ProtoNCowGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNCowGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNCowGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNCowGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNCowGameStartReq} ProtoNCowGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNCowGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNCowGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNCowGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNCowGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNCowGameStartReq} ProtoNCowGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNCowGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNCowGameStartReq message.
         * @function verify
         * @memberof mini.ProtoNCowGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNCowGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoNCowGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNCowGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNCowGameStartReq} ProtoNCowGameStartReq
         */
        ProtoNCowGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNCowGameStartReq)
                return object;
            let message = new $root.mini.ProtoNCowGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoNCowGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNCowGameStartReq
         * @static
         * @param {mini.ProtoNCowGameStartReq} message ProtoNCowGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNCowGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoNCowGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoNCowGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNCowGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNCowGameStartReq;
    })();

    mini.ProtoNCowGameStartResp = (function() {

        /**
         * Properties of a ProtoNCowGameStartResp.
         * @memberof mini
         * @interface IProtoNCowGameStartResp
         * @property {number|null} [stage2Count] ProtoNCowGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoNCowGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoNCowGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoNCowGameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoNCowGameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoNCowGameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [normalResult] ProtoNCowGameStartResp normalResult
         * @property {Array.<mini.IFreeSpin>|null} [superResult] ProtoNCowGameStartResp superResult
         * @property {Array.<number>|null} [param] ProtoNCowGameStartResp param
         * @property {string|null} [gameID] ProtoNCowGameStartResp gameID
         * @property {string|null} [buff] ProtoNCowGameStartResp buff
         * @property {string|null} [area] ProtoNCowGameStartResp area
         * @property {number|null} [per] ProtoNCowGameStartResp per
         * @property {number|null} [errorCode] ProtoNCowGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoNCowGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoNCowGameStartResp.
         * @implements IProtoNCowGameStartResp
         * @constructor
         * @param {mini.IProtoNCowGameStartResp=} [properties] Properties to set
         */
        function ProtoNCowGameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.normalResult = [];
            this.superResult = [];
            this.param = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNCowGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoNCowGameStartResp
         * @instance
         */
        ProtoNCowGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoNCowGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoNCowGameStartResp
         * @instance
         */
        ProtoNCowGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoNCowGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoNCowGameStartResp
         * @instance
         */
        ProtoNCowGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoNCowGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoNCowGameStartResp
         * @instance
         */
        ProtoNCowGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoNCowGameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoNCowGameStartResp
         * @instance
         */
        ProtoNCowGameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoNCowGameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoNCowGameStartResp
         * @instance
         */
        ProtoNCowGameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoNCowGameStartResp normalResult.
         * @member {Array.<mini.IFreeSpin>} normalResult
         * @memberof mini.ProtoNCowGameStartResp
         * @instance
         */
        ProtoNCowGameStartResp.prototype.normalResult = $util.emptyArray;

        /**
         * ProtoNCowGameStartResp superResult.
         * @member {Array.<mini.IFreeSpin>} superResult
         * @memberof mini.ProtoNCowGameStartResp
         * @instance
         */
        ProtoNCowGameStartResp.prototype.superResult = $util.emptyArray;

        /**
         * ProtoNCowGameStartResp param.
         * @member {Array.<number>} param
         * @memberof mini.ProtoNCowGameStartResp
         * @instance
         */
        ProtoNCowGameStartResp.prototype.param = $util.emptyArray;

        /**
         * ProtoNCowGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoNCowGameStartResp
         * @instance
         */
        ProtoNCowGameStartResp.prototype.gameID = "";

        /**
         * ProtoNCowGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoNCowGameStartResp
         * @instance
         */
        ProtoNCowGameStartResp.prototype.buff = "";

        /**
         * ProtoNCowGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoNCowGameStartResp
         * @instance
         */
        ProtoNCowGameStartResp.prototype.area = "";

        /**
         * ProtoNCowGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoNCowGameStartResp
         * @instance
         */
        ProtoNCowGameStartResp.prototype.per = 0;

        /**
         * ProtoNCowGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoNCowGameStartResp
         * @instance
         */
        ProtoNCowGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoNCowGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNCowGameStartResp
         * @static
         * @param {mini.IProtoNCowGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoNCowGameStartResp} ProtoNCowGameStartResp instance
         */
        ProtoNCowGameStartResp.create = function create(properties) {
            return new ProtoNCowGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoNCowGameStartResp message. Does not implicitly {@link mini.ProtoNCowGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNCowGameStartResp
         * @static
         * @param {mini.IProtoNCowGameStartResp} message ProtoNCowGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNCowGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.normalResult != null && message.normalResult.length)
                for (let i = 0; i < message.normalResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.normalResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.superResult != null && message.superResult.length)
                for (let i = 0; i < message.superResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.superResult[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.param != null && message.param.length) {
                writer.uint32(/* id 9, wireType 2 =*/74).fork();
                for (let i = 0; i < message.param.length; ++i)
                    writer.int32(message.param[i]);
                writer.ldelim();
            }
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.per);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoNCowGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoNCowGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNCowGameStartResp
         * @static
         * @param {mini.IProtoNCowGameStartResp} message ProtoNCowGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNCowGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNCowGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNCowGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNCowGameStartResp} ProtoNCowGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNCowGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNCowGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.normalResult && message.normalResult.length))
                        message.normalResult = [];
                    message.normalResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.superResult && message.superResult.length))
                        message.superResult = [];
                    message.superResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 9:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                case 10:
                    message.gameID = reader.string();
                    break;
                case 11:
                    message.buff = reader.string();
                    break;
                case 12:
                    message.area = reader.string();
                    break;
                case 13:
                    message.per = reader.uint32();
                    break;
                case 14:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNCowGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNCowGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNCowGameStartResp} ProtoNCowGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNCowGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNCowGameStartResp message.
         * @function verify
         * @memberof mini.ProtoNCowGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNCowGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.normalResult != null && message.hasOwnProperty("normalResult")) {
                if (!Array.isArray(message.normalResult))
                    return "normalResult: array expected";
                for (let i = 0; i < message.normalResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.normalResult[i]);
                    if (error)
                        return "normalResult." + error;
                }
            }
            if (message.superResult != null && message.hasOwnProperty("superResult")) {
                if (!Array.isArray(message.superResult))
                    return "superResult: array expected";
                for (let i = 0; i < message.superResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.superResult[i]);
                    if (error)
                        return "superResult." + error;
                }
            }
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (let i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoNCowGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNCowGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNCowGameStartResp} ProtoNCowGameStartResp
         */
        ProtoNCowGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNCowGameStartResp)
                return object;
            let message = new $root.mini.ProtoNCowGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoNCowGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoNCowGameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoNCowGameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoNCowGameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.normalResult) {
                if (!Array.isArray(object.normalResult))
                    throw TypeError(".mini.ProtoNCowGameStartResp.normalResult: array expected");
                message.normalResult = [];
                for (let i = 0; i < object.normalResult.length; ++i) {
                    if (typeof object.normalResult[i] !== "object")
                        throw TypeError(".mini.ProtoNCowGameStartResp.normalResult: object expected");
                    message.normalResult[i] = $root.mini.FreeSpin.fromObject(object.normalResult[i]);
                }
            }
            if (object.superResult) {
                if (!Array.isArray(object.superResult))
                    throw TypeError(".mini.ProtoNCowGameStartResp.superResult: array expected");
                message.superResult = [];
                for (let i = 0; i < object.superResult.length; ++i) {
                    if (typeof object.superResult[i] !== "object")
                        throw TypeError(".mini.ProtoNCowGameStartResp.superResult: object expected");
                    message.superResult[i] = $root.mini.FreeSpin.fromObject(object.superResult[i]);
                }
            }
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".mini.ProtoNCowGameStartResp.param: array expected");
                message.param = [];
                for (let i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoNCowGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNCowGameStartResp
         * @static
         * @param {mini.ProtoNCowGameStartResp} message ProtoNCowGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNCowGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.normalResult = [];
                object.superResult = [];
                object.param = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.normalResult && message.normalResult.length) {
                object.normalResult = [];
                for (let j = 0; j < message.normalResult.length; ++j)
                    object.normalResult[j] = $root.mini.FreeSpin.toObject(message.normalResult[j], options);
            }
            if (message.superResult && message.superResult.length) {
                object.superResult = [];
                for (let j = 0; j < message.superResult.length; ++j)
                    object.superResult[j] = $root.mini.FreeSpin.toObject(message.superResult[j], options);
            }
            if (message.param && message.param.length) {
                object.param = [];
                for (let j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoNCowGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoNCowGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNCowGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNCowGameStartResp;
    })();

    mini.ProtoNTigerBlockReq = (function() {

        /**
         * Properties of a ProtoNTigerBlockReq.
         * @memberof mini
         * @interface IProtoNTigerBlockReq
         * @property {number|null} [gameType] ProtoNTigerBlockReq gameType
         */

        /**
         * Constructs a new ProtoNTigerBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoNTigerBlockReq.
         * @implements IProtoNTigerBlockReq
         * @constructor
         * @param {mini.IProtoNTigerBlockReq=} [properties] Properties to set
         */
        function ProtoNTigerBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNTigerBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoNTigerBlockReq
         * @instance
         */
        ProtoNTigerBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoNTigerBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNTigerBlockReq
         * @static
         * @param {mini.IProtoNTigerBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoNTigerBlockReq} ProtoNTigerBlockReq instance
         */
        ProtoNTigerBlockReq.create = function create(properties) {
            return new ProtoNTigerBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoNTigerBlockReq message. Does not implicitly {@link mini.ProtoNTigerBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNTigerBlockReq
         * @static
         * @param {mini.IProtoNTigerBlockReq} message ProtoNTigerBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNTigerBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoNTigerBlockReq message, length delimited. Does not implicitly {@link mini.ProtoNTigerBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNTigerBlockReq
         * @static
         * @param {mini.IProtoNTigerBlockReq} message ProtoNTigerBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNTigerBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNTigerBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNTigerBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNTigerBlockReq} ProtoNTigerBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNTigerBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNTigerBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNTigerBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNTigerBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNTigerBlockReq} ProtoNTigerBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNTigerBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNTigerBlockReq message.
         * @function verify
         * @memberof mini.ProtoNTigerBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNTigerBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoNTigerBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNTigerBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNTigerBlockReq} ProtoNTigerBlockReq
         */
        ProtoNTigerBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNTigerBlockReq)
                return object;
            let message = new $root.mini.ProtoNTigerBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoNTigerBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNTigerBlockReq
         * @static
         * @param {mini.ProtoNTigerBlockReq} message ProtoNTigerBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNTigerBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoNTigerBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoNTigerBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNTigerBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNTigerBlockReq;
    })();

    mini.ProtoNTigerBlockResp = (function() {

        /**
         * Properties of a ProtoNTigerBlockResp.
         * @memberof mini
         * @interface IProtoNTigerBlockResp
         * @property {Array.<number>|null} [block] ProtoNTigerBlockResp block
         */

        /**
         * Constructs a new ProtoNTigerBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoNTigerBlockResp.
         * @implements IProtoNTigerBlockResp
         * @constructor
         * @param {mini.IProtoNTigerBlockResp=} [properties] Properties to set
         */
        function ProtoNTigerBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNTigerBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoNTigerBlockResp
         * @instance
         */
        ProtoNTigerBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoNTigerBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNTigerBlockResp
         * @static
         * @param {mini.IProtoNTigerBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoNTigerBlockResp} ProtoNTigerBlockResp instance
         */
        ProtoNTigerBlockResp.create = function create(properties) {
            return new ProtoNTigerBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoNTigerBlockResp message. Does not implicitly {@link mini.ProtoNTigerBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNTigerBlockResp
         * @static
         * @param {mini.IProtoNTigerBlockResp} message ProtoNTigerBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNTigerBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoNTigerBlockResp message, length delimited. Does not implicitly {@link mini.ProtoNTigerBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNTigerBlockResp
         * @static
         * @param {mini.IProtoNTigerBlockResp} message ProtoNTigerBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNTigerBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNTigerBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNTigerBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNTigerBlockResp} ProtoNTigerBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNTigerBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNTigerBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNTigerBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNTigerBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNTigerBlockResp} ProtoNTigerBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNTigerBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNTigerBlockResp message.
         * @function verify
         * @memberof mini.ProtoNTigerBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNTigerBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoNTigerBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNTigerBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNTigerBlockResp} ProtoNTigerBlockResp
         */
        ProtoNTigerBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNTigerBlockResp)
                return object;
            let message = new $root.mini.ProtoNTigerBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoNTigerBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoNTigerBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNTigerBlockResp
         * @static
         * @param {mini.ProtoNTigerBlockResp} message ProtoNTigerBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNTigerBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoNTigerBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoNTigerBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNTigerBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNTigerBlockResp;
    })();

    mini.ProtoNTigerGameStartReq = (function() {

        /**
         * Properties of a ProtoNTigerGameStartReq.
         * @memberof mini
         * @interface IProtoNTigerGameStartReq
         * @property {number|null} [score] ProtoNTigerGameStartReq score
         * @property {number|null} [type] ProtoNTigerGameStartReq type
         * @property {number|null} [area] ProtoNTigerGameStartReq area
         * @property {number|null} [buff] ProtoNTigerGameStartReq buff
         */

        /**
         * Constructs a new ProtoNTigerGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoNTigerGameStartReq.
         * @implements IProtoNTigerGameStartReq
         * @constructor
         * @param {mini.IProtoNTigerGameStartReq=} [properties] Properties to set
         */
        function ProtoNTigerGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNTigerGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoNTigerGameStartReq
         * @instance
         */
        ProtoNTigerGameStartReq.prototype.score = 0;

        /**
         * ProtoNTigerGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoNTigerGameStartReq
         * @instance
         */
        ProtoNTigerGameStartReq.prototype.type = 0;

        /**
         * ProtoNTigerGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoNTigerGameStartReq
         * @instance
         */
        ProtoNTigerGameStartReq.prototype.area = 0;

        /**
         * ProtoNTigerGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoNTigerGameStartReq
         * @instance
         */
        ProtoNTigerGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoNTigerGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNTigerGameStartReq
         * @static
         * @param {mini.IProtoNTigerGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoNTigerGameStartReq} ProtoNTigerGameStartReq instance
         */
        ProtoNTigerGameStartReq.create = function create(properties) {
            return new ProtoNTigerGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoNTigerGameStartReq message. Does not implicitly {@link mini.ProtoNTigerGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNTigerGameStartReq
         * @static
         * @param {mini.IProtoNTigerGameStartReq} message ProtoNTigerGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNTigerGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoNTigerGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoNTigerGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNTigerGameStartReq
         * @static
         * @param {mini.IProtoNTigerGameStartReq} message ProtoNTigerGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNTigerGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNTigerGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNTigerGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNTigerGameStartReq} ProtoNTigerGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNTigerGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNTigerGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNTigerGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNTigerGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNTigerGameStartReq} ProtoNTigerGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNTigerGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNTigerGameStartReq message.
         * @function verify
         * @memberof mini.ProtoNTigerGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNTigerGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoNTigerGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNTigerGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNTigerGameStartReq} ProtoNTigerGameStartReq
         */
        ProtoNTigerGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNTigerGameStartReq)
                return object;
            let message = new $root.mini.ProtoNTigerGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoNTigerGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNTigerGameStartReq
         * @static
         * @param {mini.ProtoNTigerGameStartReq} message ProtoNTigerGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNTigerGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoNTigerGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoNTigerGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNTigerGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNTigerGameStartReq;
    })();

    mini.ProtoNTigerGameStartResp = (function() {

        /**
         * Properties of a ProtoNTigerGameStartResp.
         * @memberof mini
         * @interface IProtoNTigerGameStartResp
         * @property {number|null} [stage2Count] ProtoNTigerGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoNTigerGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoNTigerGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoNTigerGameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoNTigerGameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoNTigerGameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [superResult] ProtoNTigerGameStartResp superResult
         * @property {string|null} [gameID] ProtoNTigerGameStartResp gameID
         * @property {string|null} [buff] ProtoNTigerGameStartResp buff
         * @property {string|null} [area] ProtoNTigerGameStartResp area
         * @property {number|null} [per] ProtoNTigerGameStartResp per
         * @property {number|null} [errorCode] ProtoNTigerGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoNTigerGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoNTigerGameStartResp.
         * @implements IProtoNTigerGameStartResp
         * @constructor
         * @param {mini.IProtoNTigerGameStartResp=} [properties] Properties to set
         */
        function ProtoNTigerGameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.superResult = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNTigerGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoNTigerGameStartResp
         * @instance
         */
        ProtoNTigerGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoNTigerGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoNTigerGameStartResp
         * @instance
         */
        ProtoNTigerGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoNTigerGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoNTigerGameStartResp
         * @instance
         */
        ProtoNTigerGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoNTigerGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoNTigerGameStartResp
         * @instance
         */
        ProtoNTigerGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoNTigerGameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoNTigerGameStartResp
         * @instance
         */
        ProtoNTigerGameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoNTigerGameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoNTigerGameStartResp
         * @instance
         */
        ProtoNTigerGameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoNTigerGameStartResp superResult.
         * @member {Array.<mini.IFreeSpin>} superResult
         * @memberof mini.ProtoNTigerGameStartResp
         * @instance
         */
        ProtoNTigerGameStartResp.prototype.superResult = $util.emptyArray;

        /**
         * ProtoNTigerGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoNTigerGameStartResp
         * @instance
         */
        ProtoNTigerGameStartResp.prototype.gameID = "";

        /**
         * ProtoNTigerGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoNTigerGameStartResp
         * @instance
         */
        ProtoNTigerGameStartResp.prototype.buff = "";

        /**
         * ProtoNTigerGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoNTigerGameStartResp
         * @instance
         */
        ProtoNTigerGameStartResp.prototype.area = "";

        /**
         * ProtoNTigerGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoNTigerGameStartResp
         * @instance
         */
        ProtoNTigerGameStartResp.prototype.per = 0;

        /**
         * ProtoNTigerGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoNTigerGameStartResp
         * @instance
         */
        ProtoNTigerGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoNTigerGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNTigerGameStartResp
         * @static
         * @param {mini.IProtoNTigerGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoNTigerGameStartResp} ProtoNTigerGameStartResp instance
         */
        ProtoNTigerGameStartResp.create = function create(properties) {
            return new ProtoNTigerGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoNTigerGameStartResp message. Does not implicitly {@link mini.ProtoNTigerGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNTigerGameStartResp
         * @static
         * @param {mini.IProtoNTigerGameStartResp} message ProtoNTigerGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNTigerGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.superResult != null && message.superResult.length)
                for (let i = 0; i < message.superResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.superResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.per);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoNTigerGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoNTigerGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNTigerGameStartResp
         * @static
         * @param {mini.IProtoNTigerGameStartResp} message ProtoNTigerGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNTigerGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNTigerGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNTigerGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNTigerGameStartResp} ProtoNTigerGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNTigerGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNTigerGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.superResult && message.superResult.length))
                        message.superResult = [];
                    message.superResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.gameID = reader.string();
                    break;
                case 9:
                    message.buff = reader.string();
                    break;
                case 10:
                    message.area = reader.string();
                    break;
                case 11:
                    message.per = reader.uint32();
                    break;
                case 12:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNTigerGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNTigerGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNTigerGameStartResp} ProtoNTigerGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNTigerGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNTigerGameStartResp message.
         * @function verify
         * @memberof mini.ProtoNTigerGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNTigerGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.superResult != null && message.hasOwnProperty("superResult")) {
                if (!Array.isArray(message.superResult))
                    return "superResult: array expected";
                for (let i = 0; i < message.superResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.superResult[i]);
                    if (error)
                        return "superResult." + error;
                }
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoNTigerGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNTigerGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNTigerGameStartResp} ProtoNTigerGameStartResp
         */
        ProtoNTigerGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNTigerGameStartResp)
                return object;
            let message = new $root.mini.ProtoNTigerGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoNTigerGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoNTigerGameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoNTigerGameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoNTigerGameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.superResult) {
                if (!Array.isArray(object.superResult))
                    throw TypeError(".mini.ProtoNTigerGameStartResp.superResult: array expected");
                message.superResult = [];
                for (let i = 0; i < object.superResult.length; ++i) {
                    if (typeof object.superResult[i] !== "object")
                        throw TypeError(".mini.ProtoNTigerGameStartResp.superResult: object expected");
                    message.superResult[i] = $root.mini.FreeSpin.fromObject(object.superResult[i]);
                }
            }
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoNTigerGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNTigerGameStartResp
         * @static
         * @param {mini.ProtoNTigerGameStartResp} message ProtoNTigerGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNTigerGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.superResult = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.superResult && message.superResult.length) {
                object.superResult = [];
                for (let j = 0; j < message.superResult.length; ++j)
                    object.superResult[j] = $root.mini.FreeSpin.toObject(message.superResult[j], options);
            }
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoNTigerGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoNTigerGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNTigerGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNTigerGameStartResp;
    })();

    mini.ProtoNRabitBlockReq = (function() {

        /**
         * Properties of a ProtoNRabitBlockReq.
         * @memberof mini
         * @interface IProtoNRabitBlockReq
         * @property {number|null} [gameType] ProtoNRabitBlockReq gameType
         */

        /**
         * Constructs a new ProtoNRabitBlockReq.
         * @memberof mini
         * @classdesc Represents a ProtoNRabitBlockReq.
         * @implements IProtoNRabitBlockReq
         * @constructor
         * @param {mini.IProtoNRabitBlockReq=} [properties] Properties to set
         */
        function ProtoNRabitBlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNRabitBlockReq gameType.
         * @member {number} gameType
         * @memberof mini.ProtoNRabitBlockReq
         * @instance
         */
        ProtoNRabitBlockReq.prototype.gameType = 0;

        /**
         * Creates a new ProtoNRabitBlockReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNRabitBlockReq
         * @static
         * @param {mini.IProtoNRabitBlockReq=} [properties] Properties to set
         * @returns {mini.ProtoNRabitBlockReq} ProtoNRabitBlockReq instance
         */
        ProtoNRabitBlockReq.create = function create(properties) {
            return new ProtoNRabitBlockReq(properties);
        };

        /**
         * Encodes the specified ProtoNRabitBlockReq message. Does not implicitly {@link mini.ProtoNRabitBlockReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNRabitBlockReq
         * @static
         * @param {mini.IProtoNRabitBlockReq} message ProtoNRabitBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNRabitBlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gameType);
            return writer;
        };

        /**
         * Encodes the specified ProtoNRabitBlockReq message, length delimited. Does not implicitly {@link mini.ProtoNRabitBlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNRabitBlockReq
         * @static
         * @param {mini.IProtoNRabitBlockReq} message ProtoNRabitBlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNRabitBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNRabitBlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNRabitBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNRabitBlockReq} ProtoNRabitBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNRabitBlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNRabitBlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNRabitBlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNRabitBlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNRabitBlockReq} ProtoNRabitBlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNRabitBlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNRabitBlockReq message.
         * @function verify
         * @memberof mini.ProtoNRabitBlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNRabitBlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                if (!$util.isInteger(message.gameType))
                    return "gameType: integer expected";
            return null;
        };

        /**
         * Creates a ProtoNRabitBlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNRabitBlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNRabitBlockReq} ProtoNRabitBlockReq
         */
        ProtoNRabitBlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNRabitBlockReq)
                return object;
            let message = new $root.mini.ProtoNRabitBlockReq();
            if (object.gameType != null)
                message.gameType = object.gameType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoNRabitBlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNRabitBlockReq
         * @static
         * @param {mini.ProtoNRabitBlockReq} message ProtoNRabitBlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNRabitBlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameType = 0;
            if (message.gameType != null && message.hasOwnProperty("gameType"))
                object.gameType = message.gameType;
            return object;
        };

        /**
         * Converts this ProtoNRabitBlockReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoNRabitBlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNRabitBlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNRabitBlockReq;
    })();

    mini.ProtoNRabitBlockResp = (function() {

        /**
         * Properties of a ProtoNRabitBlockResp.
         * @memberof mini
         * @interface IProtoNRabitBlockResp
         * @property {Array.<number>|null} [block] ProtoNRabitBlockResp block
         */

        /**
         * Constructs a new ProtoNRabitBlockResp.
         * @memberof mini
         * @classdesc Represents a ProtoNRabitBlockResp.
         * @implements IProtoNRabitBlockResp
         * @constructor
         * @param {mini.IProtoNRabitBlockResp=} [properties] Properties to set
         */
        function ProtoNRabitBlockResp(properties) {
            this.block = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNRabitBlockResp block.
         * @member {Array.<number>} block
         * @memberof mini.ProtoNRabitBlockResp
         * @instance
         */
        ProtoNRabitBlockResp.prototype.block = $util.emptyArray;

        /**
         * Creates a new ProtoNRabitBlockResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNRabitBlockResp
         * @static
         * @param {mini.IProtoNRabitBlockResp=} [properties] Properties to set
         * @returns {mini.ProtoNRabitBlockResp} ProtoNRabitBlockResp instance
         */
        ProtoNRabitBlockResp.create = function create(properties) {
            return new ProtoNRabitBlockResp(properties);
        };

        /**
         * Encodes the specified ProtoNRabitBlockResp message. Does not implicitly {@link mini.ProtoNRabitBlockResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNRabitBlockResp
         * @static
         * @param {mini.IProtoNRabitBlockResp} message ProtoNRabitBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNRabitBlockResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.block.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.block.length; ++i)
                    writer.uint32(message.block[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ProtoNRabitBlockResp message, length delimited. Does not implicitly {@link mini.ProtoNRabitBlockResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNRabitBlockResp
         * @static
         * @param {mini.IProtoNRabitBlockResp} message ProtoNRabitBlockResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNRabitBlockResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNRabitBlockResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNRabitBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNRabitBlockResp} ProtoNRabitBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNRabitBlockResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNRabitBlockResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.block && message.block.length))
                        message.block = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.block.push(reader.uint32());
                    } else
                        message.block.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNRabitBlockResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNRabitBlockResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNRabitBlockResp} ProtoNRabitBlockResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNRabitBlockResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNRabitBlockResp message.
         * @function verify
         * @memberof mini.ProtoNRabitBlockResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNRabitBlockResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                if (!Array.isArray(message.block))
                    return "block: array expected";
                for (let i = 0; i < message.block.length; ++i)
                    if (!$util.isInteger(message.block[i]))
                        return "block: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ProtoNRabitBlockResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNRabitBlockResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNRabitBlockResp} ProtoNRabitBlockResp
         */
        ProtoNRabitBlockResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNRabitBlockResp)
                return object;
            let message = new $root.mini.ProtoNRabitBlockResp();
            if (object.block) {
                if (!Array.isArray(object.block))
                    throw TypeError(".mini.ProtoNRabitBlockResp.block: array expected");
                message.block = [];
                for (let i = 0; i < object.block.length; ++i)
                    message.block[i] = object.block[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtoNRabitBlockResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNRabitBlockResp
         * @static
         * @param {mini.ProtoNRabitBlockResp} message ProtoNRabitBlockResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNRabitBlockResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.block = [];
            if (message.block && message.block.length) {
                object.block = [];
                for (let j = 0; j < message.block.length; ++j)
                    object.block[j] = message.block[j];
            }
            return object;
        };

        /**
         * Converts this ProtoNRabitBlockResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoNRabitBlockResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNRabitBlockResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNRabitBlockResp;
    })();

    mini.ProtoNRabitGameStartReq = (function() {

        /**
         * Properties of a ProtoNRabitGameStartReq.
         * @memberof mini
         * @interface IProtoNRabitGameStartReq
         * @property {number|null} [score] ProtoNRabitGameStartReq score
         * @property {number|null} [type] ProtoNRabitGameStartReq type
         * @property {number|null} [area] ProtoNRabitGameStartReq area
         * @property {number|null} [buff] ProtoNRabitGameStartReq buff
         */

        /**
         * Constructs a new ProtoNRabitGameStartReq.
         * @memberof mini
         * @classdesc Represents a ProtoNRabitGameStartReq.
         * @implements IProtoNRabitGameStartReq
         * @constructor
         * @param {mini.IProtoNRabitGameStartReq=} [properties] Properties to set
         */
        function ProtoNRabitGameStartReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNRabitGameStartReq score.
         * @member {number} score
         * @memberof mini.ProtoNRabitGameStartReq
         * @instance
         */
        ProtoNRabitGameStartReq.prototype.score = 0;

        /**
         * ProtoNRabitGameStartReq type.
         * @member {number} type
         * @memberof mini.ProtoNRabitGameStartReq
         * @instance
         */
        ProtoNRabitGameStartReq.prototype.type = 0;

        /**
         * ProtoNRabitGameStartReq area.
         * @member {number} area
         * @memberof mini.ProtoNRabitGameStartReq
         * @instance
         */
        ProtoNRabitGameStartReq.prototype.area = 0;

        /**
         * ProtoNRabitGameStartReq buff.
         * @member {number} buff
         * @memberof mini.ProtoNRabitGameStartReq
         * @instance
         */
        ProtoNRabitGameStartReq.prototype.buff = 0;

        /**
         * Creates a new ProtoNRabitGameStartReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNRabitGameStartReq
         * @static
         * @param {mini.IProtoNRabitGameStartReq=} [properties] Properties to set
         * @returns {mini.ProtoNRabitGameStartReq} ProtoNRabitGameStartReq instance
         */
        ProtoNRabitGameStartReq.create = function create(properties) {
            return new ProtoNRabitGameStartReq(properties);
        };

        /**
         * Encodes the specified ProtoNRabitGameStartReq message. Does not implicitly {@link mini.ProtoNRabitGameStartReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNRabitGameStartReq
         * @static
         * @param {mini.IProtoNRabitGameStartReq} message ProtoNRabitGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNRabitGameStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.score);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.area);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buff);
            return writer;
        };

        /**
         * Encodes the specified ProtoNRabitGameStartReq message, length delimited. Does not implicitly {@link mini.ProtoNRabitGameStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNRabitGameStartReq
         * @static
         * @param {mini.IProtoNRabitGameStartReq} message ProtoNRabitGameStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNRabitGameStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNRabitGameStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNRabitGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNRabitGameStartReq} ProtoNRabitGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNRabitGameStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNRabitGameStartReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.area = reader.uint32();
                    break;
                case 4:
                    message.buff = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNRabitGameStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNRabitGameStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNRabitGameStartReq} ProtoNRabitGameStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNRabitGameStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNRabitGameStartReq message.
         * @function verify
         * @memberof mini.ProtoNRabitGameStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNRabitGameStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };

        /**
         * Creates a ProtoNRabitGameStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNRabitGameStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNRabitGameStartReq} ProtoNRabitGameStartReq
         */
        ProtoNRabitGameStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNRabitGameStartReq)
                return object;
            let message = new $root.mini.ProtoNRabitGameStartReq();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.buff != null)
                message.buff = object.buff >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoNRabitGameStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNRabitGameStartReq
         * @static
         * @param {mini.ProtoNRabitGameStartReq} message ProtoNRabitGameStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNRabitGameStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.score = 0;
                object.type = 0;
                object.area = 0;
                object.buff = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };

        /**
         * Converts this ProtoNRabitGameStartReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoNRabitGameStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNRabitGameStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNRabitGameStartReq;
    })();

    mini.ProtoNRabitGameStartResp = (function() {

        /**
         * Properties of a ProtoNRabitGameStartResp.
         * @memberof mini
         * @interface IProtoNRabitGameStartResp
         * @property {number|null} [stage2Count] ProtoNRabitGameStartResp stage2Count
         * @property {number|null} [stage3Count] ProtoNRabitGameStartResp stage3Count
         * @property {number|null} [awardTotalTimes] ProtoNRabitGameStartResp awardTotalTimes
         * @property {Array.<number>|null} [itemInfo] ProtoNRabitGameStartResp itemInfo
         * @property {Array.<boolean>|null} [shineArea] ProtoNRabitGameStartResp shineArea
         * @property {Array.<mini.ILineItem>|null} [lineItem] ProtoNRabitGameStartResp lineItem
         * @property {Array.<mini.IFreeSpin>|null} [freeResult] ProtoNRabitGameStartResp freeResult
         * @property {Array.<number>|null} [param] ProtoNRabitGameStartResp param
         * @property {number|null} [goldValue] ProtoNRabitGameStartResp goldValue
         * @property {string|null} [gameID] ProtoNRabitGameStartResp gameID
         * @property {string|null} [buff] ProtoNRabitGameStartResp buff
         * @property {string|null} [area] ProtoNRabitGameStartResp area
         * @property {number|null} [per] ProtoNRabitGameStartResp per
         * @property {number|null} [errorCode] ProtoNRabitGameStartResp errorCode
         */

        /**
         * Constructs a new ProtoNRabitGameStartResp.
         * @memberof mini
         * @classdesc Represents a ProtoNRabitGameStartResp.
         * @implements IProtoNRabitGameStartResp
         * @constructor
         * @param {mini.IProtoNRabitGameStartResp=} [properties] Properties to set
         */
        function ProtoNRabitGameStartResp(properties) {
            this.itemInfo = [];
            this.shineArea = [];
            this.lineItem = [];
            this.freeResult = [];
            this.param = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoNRabitGameStartResp stage2Count.
         * @member {number} stage2Count
         * @memberof mini.ProtoNRabitGameStartResp
         * @instance
         */
        ProtoNRabitGameStartResp.prototype.stage2Count = 0;

        /**
         * ProtoNRabitGameStartResp stage3Count.
         * @member {number} stage3Count
         * @memberof mini.ProtoNRabitGameStartResp
         * @instance
         */
        ProtoNRabitGameStartResp.prototype.stage3Count = 0;

        /**
         * ProtoNRabitGameStartResp awardTotalTimes.
         * @member {number} awardTotalTimes
         * @memberof mini.ProtoNRabitGameStartResp
         * @instance
         */
        ProtoNRabitGameStartResp.prototype.awardTotalTimes = 0;

        /**
         * ProtoNRabitGameStartResp itemInfo.
         * @member {Array.<number>} itemInfo
         * @memberof mini.ProtoNRabitGameStartResp
         * @instance
         */
        ProtoNRabitGameStartResp.prototype.itemInfo = $util.emptyArray;

        /**
         * ProtoNRabitGameStartResp shineArea.
         * @member {Array.<boolean>} shineArea
         * @memberof mini.ProtoNRabitGameStartResp
         * @instance
         */
        ProtoNRabitGameStartResp.prototype.shineArea = $util.emptyArray;

        /**
         * ProtoNRabitGameStartResp lineItem.
         * @member {Array.<mini.ILineItem>} lineItem
         * @memberof mini.ProtoNRabitGameStartResp
         * @instance
         */
        ProtoNRabitGameStartResp.prototype.lineItem = $util.emptyArray;

        /**
         * ProtoNRabitGameStartResp freeResult.
         * @member {Array.<mini.IFreeSpin>} freeResult
         * @memberof mini.ProtoNRabitGameStartResp
         * @instance
         */
        ProtoNRabitGameStartResp.prototype.freeResult = $util.emptyArray;

        /**
         * ProtoNRabitGameStartResp param.
         * @member {Array.<number>} param
         * @memberof mini.ProtoNRabitGameStartResp
         * @instance
         */
        ProtoNRabitGameStartResp.prototype.param = $util.emptyArray;

        /**
         * ProtoNRabitGameStartResp goldValue.
         * @member {number} goldValue
         * @memberof mini.ProtoNRabitGameStartResp
         * @instance
         */
        ProtoNRabitGameStartResp.prototype.goldValue = 0;

        /**
         * ProtoNRabitGameStartResp gameID.
         * @member {string} gameID
         * @memberof mini.ProtoNRabitGameStartResp
         * @instance
         */
        ProtoNRabitGameStartResp.prototype.gameID = "";

        /**
         * ProtoNRabitGameStartResp buff.
         * @member {string} buff
         * @memberof mini.ProtoNRabitGameStartResp
         * @instance
         */
        ProtoNRabitGameStartResp.prototype.buff = "";

        /**
         * ProtoNRabitGameStartResp area.
         * @member {string} area
         * @memberof mini.ProtoNRabitGameStartResp
         * @instance
         */
        ProtoNRabitGameStartResp.prototype.area = "";

        /**
         * ProtoNRabitGameStartResp per.
         * @member {number} per
         * @memberof mini.ProtoNRabitGameStartResp
         * @instance
         */
        ProtoNRabitGameStartResp.prototype.per = 0;

        /**
         * ProtoNRabitGameStartResp errorCode.
         * @member {number} errorCode
         * @memberof mini.ProtoNRabitGameStartResp
         * @instance
         */
        ProtoNRabitGameStartResp.prototype.errorCode = 0;

        /**
         * Creates a new ProtoNRabitGameStartResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoNRabitGameStartResp
         * @static
         * @param {mini.IProtoNRabitGameStartResp=} [properties] Properties to set
         * @returns {mini.ProtoNRabitGameStartResp} ProtoNRabitGameStartResp instance
         */
        ProtoNRabitGameStartResp.create = function create(properties) {
            return new ProtoNRabitGameStartResp(properties);
        };

        /**
         * Encodes the specified ProtoNRabitGameStartResp message. Does not implicitly {@link mini.ProtoNRabitGameStartResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoNRabitGameStartResp
         * @static
         * @param {mini.IProtoNRabitGameStartResp} message ProtoNRabitGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNRabitGameStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stage2Count != null && Object.hasOwnProperty.call(message, "stage2Count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.stage2Count);
            if (message.stage3Count != null && Object.hasOwnProperty.call(message, "stage3Count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stage3Count);
            if (message.awardTotalTimes != null && Object.hasOwnProperty.call(message, "awardTotalTimes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.awardTotalTimes);
            if (message.itemInfo != null && message.itemInfo.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.itemInfo.length; ++i)
                    writer.uint32(message.itemInfo[i]);
                writer.ldelim();
            }
            if (message.shineArea != null && message.shineArea.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.shineArea.length; ++i)
                    writer.bool(message.shineArea[i]);
                writer.ldelim();
            }
            if (message.lineItem != null && message.lineItem.length)
                for (let i = 0; i < message.lineItem.length; ++i)
                    $root.mini.LineItem.encode(message.lineItem[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.freeResult != null && message.freeResult.length)
                for (let i = 0; i < message.freeResult.length; ++i)
                    $root.mini.FreeSpin.encode(message.freeResult[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.param != null && message.param.length) {
                writer.uint32(/* id 8, wireType 2 =*/66).fork();
                for (let i = 0; i < message.param.length; ++i)
                    writer.int32(message.param[i]);
                writer.ldelim();
            }
            if (message.goldValue != null && Object.hasOwnProperty.call(message, "goldValue"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.goldValue);
            if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.gameID);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.buff);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.area);
            if (message.per != null && Object.hasOwnProperty.call(message, "per"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.per);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ProtoNRabitGameStartResp message, length delimited. Does not implicitly {@link mini.ProtoNRabitGameStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoNRabitGameStartResp
         * @static
         * @param {mini.IProtoNRabitGameStartResp} message ProtoNRabitGameStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoNRabitGameStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoNRabitGameStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoNRabitGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoNRabitGameStartResp} ProtoNRabitGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNRabitGameStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoNRabitGameStartResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage2Count = reader.uint32();
                    break;
                case 2:
                    message.stage3Count = reader.uint32();
                    break;
                case 3:
                    message.awardTotalTimes = reader.uint32();
                    break;
                case 4:
                    if (!(message.itemInfo && message.itemInfo.length))
                        message.itemInfo = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemInfo.push(reader.uint32());
                    } else
                        message.itemInfo.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.shineArea && message.shineArea.length))
                        message.shineArea = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shineArea.push(reader.bool());
                    } else
                        message.shineArea.push(reader.bool());
                    break;
                case 6:
                    if (!(message.lineItem && message.lineItem.length))
                        message.lineItem = [];
                    message.lineItem.push($root.mini.LineItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.freeResult && message.freeResult.length))
                        message.freeResult = [];
                    message.freeResult.push($root.mini.FreeSpin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                case 9:
                    message.goldValue = reader.uint32();
                    break;
                case 10:
                    message.gameID = reader.string();
                    break;
                case 11:
                    message.buff = reader.string();
                    break;
                case 12:
                    message.area = reader.string();
                    break;
                case 13:
                    message.per = reader.uint32();
                    break;
                case 14:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoNRabitGameStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoNRabitGameStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoNRabitGameStartResp} ProtoNRabitGameStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoNRabitGameStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoNRabitGameStartResp message.
         * @function verify
         * @memberof mini.ProtoNRabitGameStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoNRabitGameStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                if (!$util.isInteger(message.stage2Count))
                    return "stage2Count: integer expected";
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                if (!$util.isInteger(message.stage3Count))
                    return "stage3Count: integer expected";
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                if (!$util.isInteger(message.awardTotalTimes))
                    return "awardTotalTimes: integer expected";
            if (message.itemInfo != null && message.hasOwnProperty("itemInfo")) {
                if (!Array.isArray(message.itemInfo))
                    return "itemInfo: array expected";
                for (let i = 0; i < message.itemInfo.length; ++i)
                    if (!$util.isInteger(message.itemInfo[i]))
                        return "itemInfo: integer[] expected";
            }
            if (message.shineArea != null && message.hasOwnProperty("shineArea")) {
                if (!Array.isArray(message.shineArea))
                    return "shineArea: array expected";
                for (let i = 0; i < message.shineArea.length; ++i)
                    if (typeof message.shineArea[i] !== "boolean")
                        return "shineArea: boolean[] expected";
            }
            if (message.lineItem != null && message.hasOwnProperty("lineItem")) {
                if (!Array.isArray(message.lineItem))
                    return "lineItem: array expected";
                for (let i = 0; i < message.lineItem.length; ++i) {
                    let error = $root.mini.LineItem.verify(message.lineItem[i]);
                    if (error)
                        return "lineItem." + error;
                }
            }
            if (message.freeResult != null && message.hasOwnProperty("freeResult")) {
                if (!Array.isArray(message.freeResult))
                    return "freeResult: array expected";
                for (let i = 0; i < message.freeResult.length; ++i) {
                    let error = $root.mini.FreeSpin.verify(message.freeResult[i]);
                    if (error)
                        return "freeResult." + error;
                }
            }
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (let i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            if (message.goldValue != null && message.hasOwnProperty("goldValue"))
                if (!$util.isInteger(message.goldValue))
                    return "goldValue: integer expected";
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                if (!$util.isString(message.gameID))
                    return "gameID: string expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isString(message.buff))
                    return "buff: string expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isString(message.area))
                    return "area: string expected";
            if (message.per != null && message.hasOwnProperty("per"))
                if (!$util.isInteger(message.per))
                    return "per: integer expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        /**
         * Creates a ProtoNRabitGameStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoNRabitGameStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoNRabitGameStartResp} ProtoNRabitGameStartResp
         */
        ProtoNRabitGameStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoNRabitGameStartResp)
                return object;
            let message = new $root.mini.ProtoNRabitGameStartResp();
            if (object.stage2Count != null)
                message.stage2Count = object.stage2Count >>> 0;
            if (object.stage3Count != null)
                message.stage3Count = object.stage3Count >>> 0;
            if (object.awardTotalTimes != null)
                message.awardTotalTimes = object.awardTotalTimes >>> 0;
            if (object.itemInfo) {
                if (!Array.isArray(object.itemInfo))
                    throw TypeError(".mini.ProtoNRabitGameStartResp.itemInfo: array expected");
                message.itemInfo = [];
                for (let i = 0; i < object.itemInfo.length; ++i)
                    message.itemInfo[i] = object.itemInfo[i] >>> 0;
            }
            if (object.shineArea) {
                if (!Array.isArray(object.shineArea))
                    throw TypeError(".mini.ProtoNRabitGameStartResp.shineArea: array expected");
                message.shineArea = [];
                for (let i = 0; i < object.shineArea.length; ++i)
                    message.shineArea[i] = Boolean(object.shineArea[i]);
            }
            if (object.lineItem) {
                if (!Array.isArray(object.lineItem))
                    throw TypeError(".mini.ProtoNRabitGameStartResp.lineItem: array expected");
                message.lineItem = [];
                for (let i = 0; i < object.lineItem.length; ++i) {
                    if (typeof object.lineItem[i] !== "object")
                        throw TypeError(".mini.ProtoNRabitGameStartResp.lineItem: object expected");
                    message.lineItem[i] = $root.mini.LineItem.fromObject(object.lineItem[i]);
                }
            }
            if (object.freeResult) {
                if (!Array.isArray(object.freeResult))
                    throw TypeError(".mini.ProtoNRabitGameStartResp.freeResult: array expected");
                message.freeResult = [];
                for (let i = 0; i < object.freeResult.length; ++i) {
                    if (typeof object.freeResult[i] !== "object")
                        throw TypeError(".mini.ProtoNRabitGameStartResp.freeResult: object expected");
                    message.freeResult[i] = $root.mini.FreeSpin.fromObject(object.freeResult[i]);
                }
            }
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".mini.ProtoNRabitGameStartResp.param: array expected");
                message.param = [];
                for (let i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            if (object.goldValue != null)
                message.goldValue = object.goldValue >>> 0;
            if (object.gameID != null)
                message.gameID = String(object.gameID);
            if (object.buff != null)
                message.buff = String(object.buff);
            if (object.area != null)
                message.area = String(object.area);
            if (object.per != null)
                message.per = object.per >>> 0;
            if (object.errorCode != null)
                message.errorCode = object.errorCode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProtoNRabitGameStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoNRabitGameStartResp
         * @static
         * @param {mini.ProtoNRabitGameStartResp} message ProtoNRabitGameStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoNRabitGameStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.itemInfo = [];
                object.shineArea = [];
                object.lineItem = [];
                object.freeResult = [];
                object.param = [];
            }
            if (options.defaults) {
                object.stage2Count = 0;
                object.stage3Count = 0;
                object.awardTotalTimes = 0;
                object.goldValue = 0;
                object.gameID = "";
                object.buff = "";
                object.area = "";
                object.per = 0;
                object.errorCode = 0;
            }
            if (message.stage2Count != null && message.hasOwnProperty("stage2Count"))
                object.stage2Count = message.stage2Count;
            if (message.stage3Count != null && message.hasOwnProperty("stage3Count"))
                object.stage3Count = message.stage3Count;
            if (message.awardTotalTimes != null && message.hasOwnProperty("awardTotalTimes"))
                object.awardTotalTimes = message.awardTotalTimes;
            if (message.itemInfo && message.itemInfo.length) {
                object.itemInfo = [];
                for (let j = 0; j < message.itemInfo.length; ++j)
                    object.itemInfo[j] = message.itemInfo[j];
            }
            if (message.shineArea && message.shineArea.length) {
                object.shineArea = [];
                for (let j = 0; j < message.shineArea.length; ++j)
                    object.shineArea[j] = message.shineArea[j];
            }
            if (message.lineItem && message.lineItem.length) {
                object.lineItem = [];
                for (let j = 0; j < message.lineItem.length; ++j)
                    object.lineItem[j] = $root.mini.LineItem.toObject(message.lineItem[j], options);
            }
            if (message.freeResult && message.freeResult.length) {
                object.freeResult = [];
                for (let j = 0; j < message.freeResult.length; ++j)
                    object.freeResult[j] = $root.mini.FreeSpin.toObject(message.freeResult[j], options);
            }
            if (message.param && message.param.length) {
                object.param = [];
                for (let j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            if (message.goldValue != null && message.hasOwnProperty("goldValue"))
                object.goldValue = message.goldValue;
            if (message.gameID != null && message.hasOwnProperty("gameID"))
                object.gameID = message.gameID;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.per != null && message.hasOwnProperty("per"))
                object.per = message.per;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            return object;
        };

        /**
         * Converts this ProtoNRabitGameStartResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoNRabitGameStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoNRabitGameStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoNRabitGameStartResp;
    })();

    mini.ProtoPotionSpellsOpenGameReq = (function() {

        /**
         * Properties of a ProtoPotionSpellsOpenGameReq.
         * @memberof mini
         * @interface IProtoPotionSpellsOpenGameReq
         * @property {string|null} [clientType] ProtoPotionSpellsOpenGameReq clientType
         * @property {number|null} [gameId] ProtoPotionSpellsOpenGameReq gameId
         * @property {string|null} [gameStatus] ProtoPotionSpellsOpenGameReq gameStatus
         */

        /**
         * Constructs a new ProtoPotionSpellsOpenGameReq.
         * @memberof mini
         * @classdesc Represents a ProtoPotionSpellsOpenGameReq.
         * @implements IProtoPotionSpellsOpenGameReq
         * @constructor
         * @param {mini.IProtoPotionSpellsOpenGameReq=} [properties] Properties to set
         */
        function ProtoPotionSpellsOpenGameReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoPotionSpellsOpenGameReq clientType.
         * @member {string} clientType
         * @memberof mini.ProtoPotionSpellsOpenGameReq
         * @instance
         */
        ProtoPotionSpellsOpenGameReq.prototype.clientType = "";

        /**
         * ProtoPotionSpellsOpenGameReq gameId.
         * @member {number} gameId
         * @memberof mini.ProtoPotionSpellsOpenGameReq
         * @instance
         */
        ProtoPotionSpellsOpenGameReq.prototype.gameId = 0;

        /**
         * ProtoPotionSpellsOpenGameReq gameStatus.
         * @member {string} gameStatus
         * @memberof mini.ProtoPotionSpellsOpenGameReq
         * @instance
         */
        ProtoPotionSpellsOpenGameReq.prototype.gameStatus = "";

        /**
         * Creates a new ProtoPotionSpellsOpenGameReq instance using the specified properties.
         * @function create
         * @memberof mini.ProtoPotionSpellsOpenGameReq
         * @static
         * @param {mini.IProtoPotionSpellsOpenGameReq=} [properties] Properties to set
         * @returns {mini.ProtoPotionSpellsOpenGameReq} ProtoPotionSpellsOpenGameReq instance
         */
        ProtoPotionSpellsOpenGameReq.create = function create(properties) {
            return new ProtoPotionSpellsOpenGameReq(properties);
        };

        /**
         * Encodes the specified ProtoPotionSpellsOpenGameReq message. Does not implicitly {@link mini.ProtoPotionSpellsOpenGameReq.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoPotionSpellsOpenGameReq
         * @static
         * @param {mini.IProtoPotionSpellsOpenGameReq} message ProtoPotionSpellsOpenGameReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoPotionSpellsOpenGameReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientType != null && Object.hasOwnProperty.call(message, "clientType"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientType);
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.gameId);
            if (message.gameStatus != null && Object.hasOwnProperty.call(message, "gameStatus"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.gameStatus);
            return writer;
        };

        /**
         * Encodes the specified ProtoPotionSpellsOpenGameReq message, length delimited. Does not implicitly {@link mini.ProtoPotionSpellsOpenGameReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoPotionSpellsOpenGameReq
         * @static
         * @param {mini.IProtoPotionSpellsOpenGameReq} message ProtoPotionSpellsOpenGameReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoPotionSpellsOpenGameReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoPotionSpellsOpenGameReq message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoPotionSpellsOpenGameReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoPotionSpellsOpenGameReq} ProtoPotionSpellsOpenGameReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoPotionSpellsOpenGameReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoPotionSpellsOpenGameReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientType = reader.string();
                    break;
                case 2:
                    message.gameId = reader.uint32();
                    break;
                case 3:
                    message.gameStatus = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoPotionSpellsOpenGameReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoPotionSpellsOpenGameReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoPotionSpellsOpenGameReq} ProtoPotionSpellsOpenGameReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoPotionSpellsOpenGameReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoPotionSpellsOpenGameReq message.
         * @function verify
         * @memberof mini.ProtoPotionSpellsOpenGameReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoPotionSpellsOpenGameReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientType != null && message.hasOwnProperty("clientType"))
                if (!$util.isString(message.clientType))
                    return "clientType: string expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isInteger(message.gameId))
                    return "gameId: integer expected";
            if (message.gameStatus != null && message.hasOwnProperty("gameStatus"))
                if (!$util.isString(message.gameStatus))
                    return "gameStatus: string expected";
            return null;
        };

        /**
         * Creates a ProtoPotionSpellsOpenGameReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoPotionSpellsOpenGameReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoPotionSpellsOpenGameReq} ProtoPotionSpellsOpenGameReq
         */
        ProtoPotionSpellsOpenGameReq.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoPotionSpellsOpenGameReq)
                return object;
            let message = new $root.mini.ProtoPotionSpellsOpenGameReq();
            if (object.clientType != null)
                message.clientType = String(object.clientType);
            if (object.gameId != null)
                message.gameId = object.gameId >>> 0;
            if (object.gameStatus != null)
                message.gameStatus = String(object.gameStatus);
            return message;
        };

        /**
         * Creates a plain object from a ProtoPotionSpellsOpenGameReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoPotionSpellsOpenGameReq
         * @static
         * @param {mini.ProtoPotionSpellsOpenGameReq} message ProtoPotionSpellsOpenGameReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoPotionSpellsOpenGameReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.clientType = "";
                object.gameId = 0;
                object.gameStatus = "";
            }
            if (message.clientType != null && message.hasOwnProperty("clientType"))
                object.clientType = message.clientType;
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            if (message.gameStatus != null && message.hasOwnProperty("gameStatus"))
                object.gameStatus = message.gameStatus;
            return object;
        };

        /**
         * Converts this ProtoPotionSpellsOpenGameReq to JSON.
         * @function toJSON
         * @memberof mini.ProtoPotionSpellsOpenGameReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoPotionSpellsOpenGameReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoPotionSpellsOpenGameReq;
    })();

    mini.ProtoPotionSpellsOpenGameResp = (function() {

        /**
         * Properties of a ProtoPotionSpellsOpenGameResp.
         * @memberof mini
         * @interface IProtoPotionSpellsOpenGameResp
         * @property {string|null} [url] ProtoPotionSpellsOpenGameResp url
         */

        /**
         * Constructs a new ProtoPotionSpellsOpenGameResp.
         * @memberof mini
         * @classdesc Represents a ProtoPotionSpellsOpenGameResp.
         * @implements IProtoPotionSpellsOpenGameResp
         * @constructor
         * @param {mini.IProtoPotionSpellsOpenGameResp=} [properties] Properties to set
         */
        function ProtoPotionSpellsOpenGameResp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtoPotionSpellsOpenGameResp url.
         * @member {string} url
         * @memberof mini.ProtoPotionSpellsOpenGameResp
         * @instance
         */
        ProtoPotionSpellsOpenGameResp.prototype.url = "";

        /**
         * Creates a new ProtoPotionSpellsOpenGameResp instance using the specified properties.
         * @function create
         * @memberof mini.ProtoPotionSpellsOpenGameResp
         * @static
         * @param {mini.IProtoPotionSpellsOpenGameResp=} [properties] Properties to set
         * @returns {mini.ProtoPotionSpellsOpenGameResp} ProtoPotionSpellsOpenGameResp instance
         */
        ProtoPotionSpellsOpenGameResp.create = function create(properties) {
            return new ProtoPotionSpellsOpenGameResp(properties);
        };

        /**
         * Encodes the specified ProtoPotionSpellsOpenGameResp message. Does not implicitly {@link mini.ProtoPotionSpellsOpenGameResp.verify|verify} messages.
         * @function encode
         * @memberof mini.ProtoPotionSpellsOpenGameResp
         * @static
         * @param {mini.IProtoPotionSpellsOpenGameResp} message ProtoPotionSpellsOpenGameResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoPotionSpellsOpenGameResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
            return writer;
        };

        /**
         * Encodes the specified ProtoPotionSpellsOpenGameResp message, length delimited. Does not implicitly {@link mini.ProtoPotionSpellsOpenGameResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mini.ProtoPotionSpellsOpenGameResp
         * @static
         * @param {mini.IProtoPotionSpellsOpenGameResp} message ProtoPotionSpellsOpenGameResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoPotionSpellsOpenGameResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtoPotionSpellsOpenGameResp message from the specified reader or buffer.
         * @function decode
         * @memberof mini.ProtoPotionSpellsOpenGameResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mini.ProtoPotionSpellsOpenGameResp} ProtoPotionSpellsOpenGameResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoPotionSpellsOpenGameResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mini.ProtoPotionSpellsOpenGameResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtoPotionSpellsOpenGameResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mini.ProtoPotionSpellsOpenGameResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mini.ProtoPotionSpellsOpenGameResp} ProtoPotionSpellsOpenGameResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoPotionSpellsOpenGameResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtoPotionSpellsOpenGameResp message.
         * @function verify
         * @memberof mini.ProtoPotionSpellsOpenGameResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoPotionSpellsOpenGameResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            return null;
        };

        /**
         * Creates a ProtoPotionSpellsOpenGameResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mini.ProtoPotionSpellsOpenGameResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mini.ProtoPotionSpellsOpenGameResp} ProtoPotionSpellsOpenGameResp
         */
        ProtoPotionSpellsOpenGameResp.fromObject = function fromObject(object) {
            if (object instanceof $root.mini.ProtoPotionSpellsOpenGameResp)
                return object;
            let message = new $root.mini.ProtoPotionSpellsOpenGameResp();
            if (object.url != null)
                message.url = String(object.url);
            return message;
        };

        /**
         * Creates a plain object from a ProtoPotionSpellsOpenGameResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mini.ProtoPotionSpellsOpenGameResp
         * @static
         * @param {mini.ProtoPotionSpellsOpenGameResp} message ProtoPotionSpellsOpenGameResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoPotionSpellsOpenGameResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.url = "";
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            return object;
        };

        /**
         * Converts this ProtoPotionSpellsOpenGameResp to JSON.
         * @function toJSON
         * @memberof mini.ProtoPotionSpellsOpenGameResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoPotionSpellsOpenGameResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtoPotionSpellsOpenGameResp;
    })();

    return mini;
})();

export { $root as default };
